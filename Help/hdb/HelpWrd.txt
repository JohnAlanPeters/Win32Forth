: !DEFAULT-SIZE ( not the default size, eg. change 16bit to 32bit ) 
( -- size ) 
: !IN-MACRO ( flag the fact that we've left a macro ) 
( -- ) 
: !LABEL ( bind a label to code-here ) 
( ref# -- ) 
ASM-OP # 
NUMBERS: &NO-XMM-MOVE ( - adr n ) 
NUMBERS: &NOT-TO-R32? ( - adr n ) 
NUMBERS: &R32 ( - adr n ) 
: (ASM-ABORT") ( f - ) 
: (MMX-DIR?) ( x \ param -- n ) 
: (MOVD-COMPILE) ( param -- | x \ param -- | x \ x \ param -- ) 
: (XMM-COMPILE) ( param -- | x \ param -- | x \ x \ param -- ) 
: +DIRECT-BIT ( adjust an opcode for the direction of the operands ) 
( op-code -- op-code' ) 
: +FP-DIRECT-BIT ( add 4, depending on the direction of the operands ) 
( x -- x' ) 
: +FP-SIZE ( add 4 if the operation size is 64bit: ie., default float ) 
( n -- n' ) 
: +MACRO ( get an index into the label table from an offset ) 
( offset -- index ) 
: +MACRO-BIND ( bind a label offset from the macro level ) 
( offset -- ) 
: +MACRO-REF ( reference a label offset from the macro level ) 
( offset -- addr ) 
: +SIZE-BIT ( adjust an opcode for the size of the operation ) 
( op-code -- op-code' ) 
ASM-OP , \ As reported by Michael Glassanenko, and verified by the
\ Intel i486 Processor Programmer's Reference Manual 1990 on page
\ 2-21, "The ESP register cannot be used as an index register".
\ REMOVED THE FOLLOWING INDEXED ADDRESSING MODES **
\ unknown   32bit     index      0c asm-op  [esp*2]
\ unknown   32bit     index      14 asm-op  [esp*4]
\ unknown   32bit     index      1c asm-op  [esp*8]
( variables used for instruction coding ) 
: /POSTFIX 
: /POSTFIX? ( are we in postfix mode? ) 
\ rls March 3rd, 2002 - 11:13
( -- flag ) 
: /PREFIX 
: /PREFIX? ( are we in prefix mode? ) 
( -- flag ) 
: /R&FREG>MOD-R/M ( turn /r and fp reg into the rqd mod-r/m ) 
( /r \ freg -- mod-r/m ) 
: /SET-POSTFIX ( set the assembler to postfix mode, leave a mode flag ) 
( -- prev. mode==prefix ) 
: /SET-PREFIX ( set the assembler to prefix mode, leave a mode flag ) 
( -- prev. mode==postfix ) 
: 0MODE-BIT! ( clear a mode bit ) 
( bit constant -- ) 
: 16*+ 
: 16/MOD 
CONSTANT 16B-ABS ( 16 bit absolute addressing ) 
CONSTANT 16B-REL ( 16 bit relative addressing ) 
CONSTANT 16BIT 
: 1BYTE ( compile a single byte, no operand, no override opcode ) 
( param -- ) 
: 1MODE-BIT! ( set a mode bit ) 
( bit constant -- ) 
: 2+ 
: 2- 
: 2BYTE ( compile a two byte, no operand, no override opcode ) 
( param -- ) 
CONSTANT 32B-ABS ( 32 bit absolute addressing ) 
CONSTANT 32B-REL ( 32 bit relative addressing ) 
( defer the error handler words so they can be individually turned off ) 
( defer them here so they can be used before they are actually defined ) 
CONSTANT 32BIT 
: 3BYTE ( compile a three byte, no operand, no override opcode ) 
( param -- ) 
: 4+ 
CONSTANT 64BIT 
: 8* 
: 8*+ 
: 8+ 
: 8- 
: 8/ 
CONSTANT 80BIT ( determine what size code to generate ) 
CONSTANT 8B-ABS ( 8 bit absolute addressing ) 
CONSTANT 8B-REL ( 8 bit relative addressing ) 
CONSTANT 8BIT 
: 8BIT? ( is the operation 8 bits wide? ) 
( -- flag ) 
DEFER ;C 
DEFER ;CODE 
: ;MACRO ( end a macro definition ) 
: <DEC-REG> ( decode the single cell operand representation to its ) 
( constituent parts ) 
( reg val -- data size \ addr size \ type \ r/m or s-i-b ) 
: <ENC-REG> ( encode the single cell operand representation from the values ) 
( on the stack ) 
( data size \ addr size \ type \ r/m or s-i-b -- reg val ) 
: <_?MATCH> ( the error action for ?match and ?nomatch ) 
( flag -- ) 
: >DEFAULT-SIZE ( change a zero size to the default size ) 
( size -- size' ) 
DEFER ?ADSIZE 
DEFER ?BADCOMBINE 
DEFER ?BADMODE 
DEFER ?BADTYPE 
: ?CLR-OPSTACK ( clear the operand stack when the flag is non-zero ) 
( f -- ) 
DEFER ?FINISHED 
DEFER ?INST-PRE 
: ?LEAVE-MACRO ( conditionally unnest a macro ) 
DEFER ?LOCK 
DEFER ?MATCH 
DEFER ?MEM 
: ?MEM,REG ( is the instruction coded as memory,register? ) 
( -- ) 
DEFER ?NOADSIZE 
DEFER ?NOFAR 
DEFER ?NOIMMED 
DEFER ?NOMATCH 
: ?NOSHORT ( do we have an illegal short? ) 
( -- ) 
DEFER ?NOTENOUGH 
DEFER ?OPERANDS 
DEFER ?OPSIZE 
DEFER ?PARAMS 
DEFER ?R/M,REG 
DEFER ?REG 
: ?REG,MEM ( is the instruction coded as register,memory? ) 
( -- ) 
DEFER ?REG,R/M 
: ?REGEXCLUS ( is the addressing mode exclusive? ) 
( -- ) 
DEFER ?REP 
DEFER ?SEG 
DEFER ?SHORT 
DEFER ?TOOFAR 
DEFER ?TOOMANYOPS 
DEFER ?UNRES 
CREATE-REF @@1 
CREATE-BIND @@1: 
CREATE-REF @@2 
CREATE-BIND @@2: 
CREATE-REF @@3 
CREATE-BIND @@3: 
CREATE-REF @@4 
CREATE-BIND @@4: 
CREATE-REF @@5 
CREATE-BIND @@5: 
CREATE-REF @@6 
CREATE-BIND @@6: 
CREATE-REF @@7 
CREATE-BIND @@7: 
CREATE-REF @@8 
CREATE-BIND @@8: 
CREATE-REF @@9 
CREATE-BIND @@9: 
CREATE-MACRO-REF @@M0 
CREATE-MACRO-BIND @@M0: 
CREATE-MACRO-REF @@M1 
CREATE-MACRO-BIND @@M1: 
CREATE-MACRO-REF @@M2 
CREATE-MACRO-BIND @@M2: 
CREATE-MACRO-REF @@M3 
CREATE-MACRO-BIND @@M3: 
CREATE-MACRO-REF @@M4 
CREATE-MACRO-BIND @@M4: 
CREATE-MACRO-REF @@M5 
CREATE-MACRO-BIND @@M5: 
CREATE-MACRO-REF @@M6 
CREATE-MACRO-BIND @@M6: 
CREATE-MACRO-REF @@M7 
CREATE-MACRO-BIND @@M7: 
CREATE-MACRO-REF @@M8 
CREATE-MACRO-BIND @@M8: 
CREATE-MACRO-REF @@M9 
CREATE-MACRO-BIND @@M9: ( Create alternative label reference and binding names for Tom ) 
: @LABEL ( fetch the binding of a label, or return a pseudo address if not ) 
( yet bound to an address ) 
( ref# -- addr ) 
: A16BIT? ( is the address size 16 bits? ) 
( -- flag ) 
: A32BIT? ( is the address size 32 bits? ) 
( -- flag ) 
: A; ( finish the assembly of the previous instruction ) 
( -- ) 
OPCODE AAA 
OPCODE AAD 
OPCODE AAM 
OPCODE AAS 
VARIABLE AD-SIZE ( address size ) 
OPCODE ADC 
OPCODE ADD 
VARIABLE ADDMODE ( addressing mode flags ) 
: ADDR, ( generate a necessary address size prefix ) 
( -- ) 
VARIABLE ADDR-PREFIX ( address size prefix ) 
: ADDREF ( add a forward reference at code-here ) 
( ref# -- ref# ) 
ASM-OP AH 
ASM-OP AL 
: ALL-EXCEPT ( process all operands except one in particular ) 
( x \ n -- type \ mod-r/m {x!=n} | -- 0 \ 0 ) 
OPCODE AND 
: ANY= ( char addr count - flag ) 
OPCODE ARPL 
: ARPL-COMPILE ( compile the arpl instruction ) 
( param -- | x \ param -- ) 
: ASM-ABORT" ( -<string">- ) 
VOCABULARY ASM-HIDDEN 
: ASM-OP ( create the assembler operands from operand descriptions ) 
( c:: data size \ addr size \ type \ r/m or s-i-b -- ) 
( r:: -- ) 
( r::os: -- x ) 
ASM-OP AX 
: BACKPATCH ( backpatch a forward reference to here ) 
( address \ size -- ) 
CONSTANT BASED ( 32 bit register indirect or scaled index/base ) 
CONSTANT BASED-BIT ( flag that we've seen a base ) 
ASM-OP BH 
ASM-OP BL 
OPCODE BOUND 
: BOUND-COMPILE ( compile the bound instruction ) 
( param -- | x \ param -- ) 
ASM-OP BP 
: BS-COMPILE ( compile a bit scan instruction, and also selector validation ) 
( param -- | x \ param -- ) 
OPCODE BSF 
OPCODE BSR 
OPCODE BSWAP 
: BSWAP-COMPILE ( compile BSWAP ) 
( param -- ) 
OPCODE BT 
OPCODE BTC 
OPCODE BTR 
OPCODE BTS 
ASM-OP BX 
ASM-OP BYTE 
: BYTE-STR-INST ( byte string instructions ) 
( param -- ) 
: C0+ 
: C0- 
: C0-8* 
OPCODE CALL 
: CALL-COMPILE ( compile CALL ) 
( param -- | x \ param -- ) 
: CALL/JMP-ENTRY ( entry for call and jump ) 
( param -- ) 
OPCODE CBW 
OPCODE CDQ 
: CELL/ 
ASM-OP CH 
: CHECK-AD-SIZE ( check the address size ) 
( -- ) 
: CHECK-DT-SIZE ( check the operand size ) 
( -- ) 
: CHECK-SIZES ( check the address and operand sizes ) 
( -- ) 
ASM-OP CL 
OPCODE CLC 
OPCODE CLD 
OPCODE CLI 
: CLR-OPSTACK 
OPCODE CLTS 
OPCODE CMC 
OPCODE CMOVA 
OPCODE CMOVAE 
OPCODE CMOVB 
OPCODE CMOVBE 
OPCODE CMOVC 
OPCODE CMOVE 
OPCODE CMOVG 
OPCODE CMOVGE 
OPCODE CMOVL 
OPCODE CMOVLE 
OPCODE CMOVNA 
OPCODE CMOVNAE 
OPCODE CMOVNB 
OPCODE CMOVNBE 
OPCODE CMOVNC 
OPCODE CMOVNE 
OPCODE CMOVNG 
OPCODE CMOVNGE 
OPCODE CMOVNL 
OPCODE CMOVNLE 
OPCODE CMOVNO 
OPCODE CMOVNP 
OPCODE CMOVNS 
OPCODE CMOVNZ 
OPCODE CMOVO 
OPCODE CMOVP 
OPCODE CMOVPE 
OPCODE CMOVPO 
OPCODE CMOVS 
OPCODE CMOVZ 
OPCODE CMP 
OPCODE CMPS 
OPCODE CMPSB 
OPCODE CMPSD 
OPCODE CMPSW 
OPCODE CMPXCHG 
OPCODE CMPXCHG8B 
: CMPXCHG8B-COMP ( assemble CMPXCHG8B ) 
( param -- ) 
DEFER CODE 
DEFER CODE-ALIGN 
DEFER CODE-C! 
DEFER CODE-C, 
DEFER CODE-C@ 
DEFER CODE-D! 
DEFER CODE-D, 
DEFER CODE-D@ 
DEFER CODE-HEADER 
DEFER CODE-HERE 
DEFER CODE-W! 
DEFER CODE-W, 
DEFER CODE-W@ 
: COMPILE-FIELDS ( compile the mod-r/m, s-i-b, displacement, and immed fields ) 
( -- ) 
: COMPILE-OPCODE ( compile the bytes in an opcode ) 
( 0 -- | a -- | x \ a -- | x \ x' \ a -- ) 
( os: x ... -- ) 
( a is the address of a two cell data structure: ) 
( offset 0 -- xt of the actual routine to compile the code ) 
( offset 1 -- parameter used to generate the code ) 
OPCODE CPUID 
ASM-OP CR0 
ASM-OP CR2 
ASM-OP CR3 
ASM-OP CR4 
: CREATE-BIND ( create words to bind local labels ) 
( c:: index -- ) 
( r:: -- ) 
: CREATE-MACRO-BIND ( create macro-safe local label bindings ) 
( c:: label offset -- ) 
( r:: -- ) 
: CREATE-MACRO-REF ( create macro-safe local label references ) 
( c:: label offset -- ) 
( r:: -- addr ) 
: CREATE-REF ( create words to reference local labels ) 
( c:: index -- ) 
( r:: -- addr ) 
CONSTANT CREG ( a control register ) 
ASM-OP CS 
SEG-PRE CS: 
VARIABLE CURRENT-SV ( needed for stashing the current vocabulary ) 
OPCODE CWD 
OPCODE CWDE 
ASM-OP CX 
OPCODE DAA 
OPCODE DAS 
: DATA, ( generate a necessary data size prefix ) 
( -- ) 
DEFER DATA-! 
DEFER DATA-+! 
DEFER DATA-, 
DEFER DATA-@ 
DEFER DATA-HERE 
VARIABLE DATA-PREFIX ( data size prefix ) 
OPCODE DEC 
: DEF-ERR-HAND ( the default error handler for uninitialized error handlers ) 
( x*i -- x*j ) 
: DEFAULT-8BIT ( change a zero size to 8bit ) 
( size -- size' ) 
VALUE DEFAULT-SIZE ( the default use size ) 
CONSTANT DEH-XT 
: DEPTH-CHANGE ( report on a change of depth ) 
ASM-OP DH 
ASM-OP DI 
CONSTANT DIRECT-BIT ( flag the direction ) 
: DIRECTION? ( is the destination a register? ) 
( -- flag ) 
: DISP, ( compile the displacement ) 
( -- ) 
: DISPLACEMENT? ( does the address mode have a pure displacement? ) 
( -- flag ) 
OPCODE DIV 
ASM-OP DL 
: DO-1OP ( process a single operand ) 
( -- | x -- | x \ x' -- ) 
CONSTANT DO-1OP-BIT ( flag we've been through do-1op once ) 
: DO-1OP-EXED ( we've exec'd do-1op ) 
( -- ) 
: DO-1OP-EXED? ( have we exec'd do-1op? ) 
( -- flag ) 
: DO-2OPS ( do two operands and set size prefixes ) 
( -- | x -- | x \ x -- ) 
: DO-BASED ( do a base register addressing mode ) 
( reg -- ) 
: DO-DISP ( process a displacement ) 
( -- ) 
: DO-IMMED ( do an immediate addressing mode operand ) 
( x \ 0 -- ) 
: DO-INDEX ( do a scaled index addressing mode ) 
( reg -- ) 
: DO-INDIRE ( do an indirect addressing mode operand ) 
( reg -- ) 
: DO-MMXREG ( do any register addressing mode translation ) 
( reg \ type -- ) 
DEFER DO-OPCODE 
: DO-REG ( do any register addressing mode translation ) 
( reg \ type -- ) 
: DO-XMMREG ( do any register addressing mode translation ) 
( reg \ type -- ) 
: DO-[(E)BP] ( do a naked [bp] or [ebp] ) 
( -- ) 
: DO-[ESP] ( do [esp] only ) 
( -- ) 
: DO-[ESP][REG] ( swap index and base registers in s-i-b ) 
( -- ) 
: DO-[REG*N] ( process a naked index ) 
( -- ) 
ASM-OP DOUBLE 
: DOUBLE-SHIFT ( compile SHLD, SHRD ) 
( param -- | x \ param -- | x \ x' \ param -- ) 
ASM-OP DR0 
ASM-OP DR1 
ASM-OP DR2 
ASM-OP DR3 
ASM-OP DR6 
ASM-OP DR7 
CONSTANT DREG ( a debug register ) 
ASM-OP DS 
SEG-PRE DS: 
VARIABLE DT-SIZE ( data item size ) 
ASM-OP DWORD 
: DWORD-STR-INST ( dword string instructions ) 
( param -- ) 
ASM-OP DX 
ASM-OP EAX 
ASM-OP EBP 
ASM-OP EBX 
ASM-OP ECX 
ASM-OP EDI 
ASM-OP EDX 
: END-ASM 
DEFER END-CODE 
: ENDM ( end a macro definition ) 
OPCODE ENTER 
: ENTER-COMPILE ( compile the enter instruction ) 
( x \ x' \ param -- ) 
: ENTER-MACRO ( set up macro relative local labels ) 
( -- ) 
ASM-OP ES 
SEG-PRE ES: 
ASM-OP ESI 
ASM-OP ESP 
: EXIT ( redefine exit to take care of macros ) 
ASM-OP EXTENDED 
OPCODE F2XM1 
OPCODE FABS 
: FAD/FMUL-COMPILE ( compile FADD and FMUL ) 
( param -- | x \ param -- ) 
OPCODE FADD 
OPCODE FADDP 
ASM-OP FAR 
CONSTANT FAR-BIT ( flag far ) 
OPCODE FBLD 
: FBLD/STP-COMPILE ( compile FBLD & FBSTP ) 
( param -- | x \ param -- ) 
OPCODE FBSTP 
OPCODE FCHS 
OPCODE FCLEX 
OPCODE FCMOVB 
OPCODE FCMOVBE 
OPCODE FCMOVE 
OPCODE FCMOVNB 
OPCODE FCMOVNBE 
OPCODE FCMOVNE 
OPCODE FCMOVNU 
OPCODE FCMOVU 
OPCODE FCOM 
: FCOM-COMPILE ( compile FCOM and FCOMP ) 
( param -- | x \ param -- ) 
OPCODE FCOMI 
OPCODE FCOMIP 
OPCODE FCOMP 
OPCODE FCOMPP 
OPCODE FCOS 
OPCODE FDECSTP 
OPCODE FDIV 
: FDIV/SUB-COMPILE ( compile FDIV, FDIVR, FSUB, & FSUBR ) 
( param -- | x \ param -- ) 
OPCODE FDIVP 
OPCODE FDIVPR 
OPCODE FDIVR 
OPCODE FDIVRP \ added for compatibility with some other assemblers
OPCODE FFREE 
OPCODE FFREEP 
OPCODE FIADD 
OPCODE FICOM 
OPCODE FICOMP 
OPCODE FIDIV 
OPCODE FIDIVR 
OPCODE FILD 
: FILD-COMPILE ( compile FILD ) 
( param -- | x \ param -- ) 
OPCODE FIMUL 
OPCODE FINCSTP 
OPCODE FINIT 
OPCODE FIST 
: FIST-COMPILE ( compile FIST & FISTP ) 
( param -- | x \ param -- ) 
OPCODE FISTP 
OPCODE FISUB 
OPCODE FISUBR 
: FIX-COMPILE ( compile FIx instructions ) 
( param -- | x \ param -- ) 
: FLAG-FOR-SIZE-PREFIX ( do we need a size prefix? ) 
( size -- flag ) 
OPCODE FLD 
: FLD-COMPILE ( compile FLD ) 
( param -- | x \ param -- ) 
OPCODE FLD1 
OPCODE FLDCW 
OPCODE FLDENV 
OPCODE FLDL2E 
OPCODE FLDL2T 
OPCODE FLDLG2 
OPCODE FLDLN2 
OPCODE FLDPI 
OPCODE FLDZ 
ASM-OP FLOAT 
: FMISC-COMPILE ( compile miscellaneous fp instructions ) 
( param -- ) 
OPCODE FMUL 
OPCODE FMULP 
OPCODE FNCLEX 
OPCODE FNINIT 
OPCODE FNOP 
OPCODE FNSAVE 
OPCODE FNSTCW 
OPCODE FNSTENV 
OPCODE FNSTSW 
: FP-DIRECTION? ( which direction is the floating point data going? ) 
( -- flag ) 
: FP-GENERIC-ASSEMBLE ( generic assembly of floating point instructions ) 
( opcode \ /r field -- ) 
OPCODE FPATAN 
OPCODE FPREM 
OPCODE FPREM1 
OPCODE FPTAN 
CONSTANT FREG ( a floating point register ) 
\ 0B constant offs     ( offset; relative or absolute address ) \ reserved, not in use
\ 0C constant moffs    ( memory offset; relative or absolute address ) \ reserved not in use
CONSTANT FRMAX ( max number of unresolved forward references ) 
OPCODE FRNDINT 
OPCODE FRSTOR 
CREATE FRTABLE 
ASM-OP FS 
SEG-PRE FS: 
OPCODE FSAVE 
OPCODE FSCALE 
OPCODE FSIN 
OPCODE FSINCOS 
OPCODE FSQRT 
OPCODE FST 
: FST-COMPILE ( compile FST and FSTP ) 
( param -- | x \ param -- ) 
OPCODE FSTCW 
OPCODE FSTENV 
OPCODE FSTP 
OPCODE FSTSW 
: FSTSW-COMPILE ( compile FSTSW & FNSTSW ) 
( param -- | x \ param -- ) 
OPCODE FSUB 
OPCODE FSUBP 
OPCODE FSUBPR 
OPCODE FSUBR 
OPCODE FSUBRP \ added for compatibility with some other assemblers
OPCODE FTST 
OPCODE FUCOM 
OPCODE FUCOMI 
OPCODE FUCOMIP 
OPCODE FUCOMP 
OPCODE FUCOMPP 
CONSTANT FULL-OFF-BIT ( flag a full offset ) 
OPCODE FWAIT 
OPCODE FXAM 
OPCODE FXCH 
: FXP-COMPILE ( compile FxP instructions ) 
( param -- ) 
OPCODE FXTRACT 
OPCODE FYL2X 
OPCODE FYL2XP1 
: GENERATE-PREFIXES ( generate necessary prefixes ) 
( -- ) 
: GENERIC-ENTRY2 ( generic entry sequence for two operand instructions ) 
( param \ max type -- ) 
( | x \ param \ max type -- ) 
( | x \ x' \ param \ max type -- ) 
: GENERIC-FP-ENTRY1 ( generic entry sequence for fp inst that take one memory ) 
( operand ) 
( param -- param | x \ param -- param ) 
: GET-AD-SIZE ( get the current address size, default is default-size ) 
( -- address size ) 
: GET-DT-SIZE ( get the current data size, default is 8 bit ) 
( -- data size ) 
: GET-FP-SIZE ( get the size of fp operand, default is default-size ) 
: GROUP1-COMPILE ( compile group 1 instructions ) 
( param -- | x \ param -- | x \ x \ param -- ) 
: GROUP2-COMPILE ( compile group 2 instructions ) 
( param -- | x \ param -- | x \ x \ param -- ) 
: GROUP3-COMPILE ( compile group 3 instructions ) 
( param -- | x \ param -- ) 
: GROUP6&7-COMPILE ( compile a group 6 or 7 instruction ) 
( param -- | x \ param -- ) 
: GROUP8-COMPILE ( compile a group 8 instruction ) 
( param -- | x \ param -- | x \ x' \ param -- ) 
ASM-OP GS 
SEG-PRE GS: 
: HAS-BASE ( we have a base ) 
( -- ) 
: HAS-BASE? ( do we have a base? ) 
( -- flag ) 
: HAS-FULL-OFF ( must generate a full offset ) 
( -- ) 
: HAS-FULL-OFF? ( do we need a full offset? ) 
( -- flag ) 
: HAS-IMMED ( flag an immediate operand ) 
( -- ) 
: HAS-IMMED? ( do we have an immediate operand? ) 
( -- flag ) 
: HAS-MOD-R/M ( we've seen at least one operand ) 
( -- ) 
: HAS-MOD-R/M? ( have we seen an operand? ) 
( -- flag ) 
: HAS-OFFSET ( flag that we do have an offset ) 
( -- ) 
: HAS-OFFSET? ( do we have an offset? ) 
( -- flag ) 
: HAS-S-I-B ( we've started work on the s-i-b ) 
( -- ) 
: HAS-S-I-B? ( have we started work on the s-i-b ) 
( -- flag ) 
VARIABLE HAS-XMM-OFFSET? ( forcing 8bit for shufps shufpd dpps dppd ) 
OPCODE HLT 
: I/O-COMPILE ( compile an IN or OUT ) 
( param -- | x \ param -- ) 
OPCODE IDIV 
: IMMED, ( compile the immediate operand ) 
( -- ) 
CONSTANT IMMED-BIT ( flag an immediate operand ) 
VARIABLE IMMED-SV ( save the immediate part ) 
CONSTANT IMMEDIATE ( an immediate operand ) 
OPCODE IMUL 
OPCODE IN 
: IN-ASM ( all later words are defined in the assembler vocabulary ) 
: IN-FORTH ( all later words are defined in the forth vocabulary ) 
: IN-HIDDEN ( all later words are defined in the hidden vocabulary ) 
: IN-MACRO ( flag the fact that we are in a macro ) 
( -- ) 
VALUE IN-MACRO? ( a semaphore to tell if we're in execution of a macro ) 
OPCODE INC 
: INC-DEC-COMPILE ( compile an INC or DEC ) 
( param -- | x \ param -- ) 
CONSTANT INDEX ( 32 bit scaled index ) 
CONSTANT INDIRECT ( 16 bit register indirect ) 
: INIT-ASM ( initalize assembly ) 
( -- ) 
OPCODE INS 
OPCODE INSB 
OPCODE INSD 
: INST, ( generate a necessary instruction prefix ) 
( -- ) 
: INST-PRE 
VARIABLE INST-PREFIX ( instruction prefixes ) 
VARIABLE INST-SAVE ( the previously executed instruction ) 
: INSTALL-/R ( install the /r field in a mod-r/m byte ) 
( /r value -- ) 
OPCODE INSW 
OPCODE INT 
: INT-COMPILE ( compile the INT instruction ) 
( x \ param -- ) 
OPCODE INTO 
OPCODE INVD 
OPCODE INVLPG 
OPCODE IRET 
OPCODE IRETD 
: IS-FAR ( we have a far pointer ) 
( -- ) 
: IS-FAR? ( do we have a far displacement? ) 
( -- flag ) 
: IS-NEAR ( we have a near displacement ) 
( -- ) 
: IS-NEAR? ( do we have a near displacement? ) 
( -- flag ) 
: IS-SHORT ( we have a short displacement ) 
( -- ) 
: IS-SHORT? ( is the displacement short? ) 
( -- flag ) 
OPCODE JA 
OPCODE JAE 
OPCODE JB 
OPCODE JBE 
OPCODE JC 
: JCC-16/32BIT ( compile a 16 or 32bit conditional branch ) 
( addr \ param \ size -- ) 
: JCC-8BIT ( compile an 8 bit conditional branch ) 
( addr \ param -- ) 
: JCC-COMPILE ( compile a conditional branch ) 
( addr \ param -- ) 
: JCC-ENTRY ( the entry sequence for conditional branch instructions ) 
( -- ) 
: JCC-UNKNOWN ( compile a conditional branch with an unknown size ) 
( addr \ param -- ) 
OPCODE JCXZ 
: JCXZ-COMPILE ( compile jcxz ) 
( address \ param -- ) 
OPCODE JE 
OPCODE JECXZ \ DO NOT MAKE an alias of jcxz.
: JECXZ-COMPILE ( compile jecxz ) 
( address \ param -- ) 
OPCODE JG 
OPCODE JGE 
OPCODE JL 
OPCODE JLE 
OPCODE JMP 
: JMP-COMPILE ( compile JMP ) 
( param -- | x \ param -- ) 
OPCODE JNA 
OPCODE JNAE 
OPCODE JNB 
OPCODE JNBE 
OPCODE JNC 
OPCODE JNE 
OPCODE JNG 
OPCODE JNGE 
OPCODE JNL 
OPCODE JNLE 
OPCODE JNO 
OPCODE JNP 
OPCODE JNS 
OPCODE JNZ 
OPCODE JO 
OPCODE JP 
OPCODE JPE 
OPCODE JPO 
OPCODE JS 
OPCODE JZ 
CREATE-MACRO-REF L$0 
CREATE-MACRO-BIND L$0: 
CREATE-MACRO-REF L$1 
CREATE-MACRO-BIND L$1: 
CREATE-MACRO-REF L$2 
CREATE-MACRO-BIND L$2: 
CREATE-MACRO-REF L$3 
CREATE-MACRO-BIND L$3: 
CREATE-MACRO-REF L$4 
CREATE-MACRO-BIND L$4: 
CREATE-MACRO-REF L$5 
CREATE-MACRO-BIND L$5: 
CREATE-MACRO-REF L$6 
CREATE-MACRO-BIND L$6: 
CREATE-MACRO-REF L$7 
CREATE-MACRO-BIND L$7: 
CREATE-MACRO-REF L$8 
CREATE-MACRO-BIND L$8: 
CREATE-MACRO-REF L$9 
CREATE-MACRO-BIND L$9: ( constants for operand typing ) 
( operand types ) 
OPCODE LAHF 
OPCODE LAR 
CONSTANT LBMAX ( max number of local labels ) 
CREATE LBTABLE 
OPCODE LDS 
OPCODE LEA 
OPCODE LEAVE 
: LEAVE-MACRO ( go back to the old regime ) 
( old macro label level -- ) 
OPCODE LES 
OPCODE LFS 
OPCODE LGDT 
OPCODE LGS 
OPCODE LIDT 
: LIT-OP ( instert the literal value of an operand into code ) 
( C:: -- ) 
( R:: -- x ) 
OPCODE LLDT 
OPCODE LMSW 
: LOAD-PTR-COMP ( compile a pointer load instruction ) 
( param -- | x \ param -- ) 
: LOC-INIT ( initialize the tables and variables ) 
( -- ) 
INST-PRE LOCK ( save the p-stack depth ) 
OPCODE LODS 
OPCODE LODSB 
OPCODE LODSD 
OPCODE LODSW 
ASM-OP LONG 
OPCODE LOOP 
: LOOP-COMPILE ( compile a loop instruction ) 
( address \ param -- ) 
: LOOP-ENTRY ( the entry sequence for loop instructions ) 
( -- ) 
OPCODE LOOPE 
OPCODE LOOPNE 
OPCODE LOOPNZ 
OPCODE LOOPZ 
OPCODE LSL 
OPCODE LSS 
OPCODE LTR 
VARIABLE MACRO-LABEL-LEVEL ( for labels to use in macros ) 
VALUE MACRO-LABELS ( the first label used for macros ) 
: MACRO: ( create a macro in the assembler vocabulary ) 
: MATCH-R/M? ( does the value match the r/m field of the mod-r/m? ) 
( value -- flag ) 
CONSTANT MAX-OPERANDS ( maximum number of operands on the opstack ) 
VARIABLE MAXTYPE ( the maximum numerical type value encountered ) 
: MAYBE-HAS-OFFSET ( flag that we've picked something up from the stack ) 
( -- ) 
: MAYBE-HAS-OFFSET? ( have we picked up something from the stack? ) 
( -- flag ) 
CONSTANT MAYBE-OFFSET-BIT ( flag that maybe we've got an offset ) 
: MAYBE-S-I-B? ( do we have a possible s-i-b? ) 
( -- flag ) 
ASM-OP MM0 
ASM-OP MM1 
ASM-OP MM2 
ASM-OP MM3 
ASM-OP MM4 
ASM-OP MM5 
ASM-OP MM6 
ASM-OP MM7 
CONSTANT MMX-DIR-BIT ( flag the direction in case of MMX register(s) 
: MMX-DIR? ( is the destination an mmx-register? ) 
( -- flag ) 
CONSTANT MMXREG ( an MMX or 3D-Now! register ) 
: MMXREG,R/M ( addressing mode is mmx-register, register/memory ) 
( -- ) 
VARIABLE MOD-R/M ( the working area for the mod-r/m byte ) 
: MOD-R/M, ( compile the mod-r/m field ) 
( -- ) 
CONSTANT MOD-R/M-BIT ( flag that we've started the mod-r/m ) 
: MOD-R/M>FREG ( convert mod-r/m byte into an fp register number ) 
( -- n ) 
: MODE-BIT@ ( fetch a mode bit ) 
( bit mask -- flag ) 
CONSTANT MODE-MASK ( all mode bits set ) 
OPCODE MOV 
: MOV-COMPILE ( compile a mov instruction ) 
( param -- | x \ param -- | x \ x' \ param -- ) 
OPCODE MOVS 
OPCODE MOVSB 
OPCODE MOVSD 
OPCODE MOVSW 
OPCODE MOVSX 
: MOVX-COMPILE ( compile MOVSX/MOVZX ) 
( param -- | x \ param -- ) 
OPCODE MOVZX 
OPCODE MUL 
ASM-OP NEAR 
CONSTANT NEAR-BIT ( flag near ) 
OPCODE NEG 
: NEXT-IS-, ( make sure the next operand is a comma ) 
( -- ) 
VARIABLE NO-DO-DISP ( No change to the mod-r/m byte ) 
: NO-ERRORS ( turn off error reporting ) 
: NO-OPCODE-HANDLER 
: NO-XMM-MOVE ( opcode - opcode flag ) 
OPCODE NOP 
OPCODE NOT 
: NOT-ANY-MOD-R/M= ( addr count - flag ) 
: NOT-ANY= ( char addr count - flag ) 
: NOT-TO-R32? ( - flag ) 
CONSTANT OFFSET-BIT ( flag an offset ) 
VARIABLE OFFSET-SV ( save the offset part ) 
: OFFSET16, ( create a 16 bit code-here relative offset ) 
( addr -- ) 
: OFFSET16/32, ( create a 16 or 32 bit code-here relative offset ) 
( addr \ 16bit? -- ) 
: OFFSET32, ( create a 32 bit code-here relative offset ) 
( addr -- ) 
: OFFSET8, ( create an 8 bit code-here relative offset ) 
( addr -- ) 
: OP-DEPTH ( check the depth of the operand stack ) 
: OPCODE ( c:: parameter \ xt -- ) 
( r:: -- | x -- | x \ x' -- ) 
( r::os: x ... -- ) 
: OPERAND-CASES ( process an operand based on its type ) 
( reg \ type -- | x \ reg \ type -- ) 
CREATE OPSTACK 
CONSTANT OPSTACK-END 
OPCODE OR 
OPCODE OUT 
OPCODE OUTS 
OPCODE OUTSB 
OPCODE OUTSD 
OPCODE OUTSW 
: PARSE-CALL/JMP-OPERANDS ( parse the operands for calls and jumps ) 
( -- | x -- ) 
: PARSE-FP-OPS ( parse floating point instruction operands ) 
( -- n | x -- n ) 
VALUE PFA-MNEMONIC 
OPCODE POP 
: POP-COMPILE ( compile POP ) 
( param -- | x \ param -- ) 
: POP-OP ( move an item from the operand stack to the parameter stack ) 
( -- x ) 
OPCODE POPA 
OPCODE POPAD 
OPCODE POPF 
OPCODE POPFD 
: PURE-REG? ( is the mod field of the mod-r/m = 3? ) 
( -- flag ) 
OPCODE PUSH 
: PUSH-COMPILE ( compile PUSH ) 
( param -- | x \ param -- ) 
: PUSH-OP ( move a parameter stack item to the opstack ) 
( x -- ) 
: PUSH/POP-ENTRY ( entry sequence for push and pop compilers ) 
( param -- ) 
OPCODE PUSHA 
OPCODE PUSHAD 
OPCODE PUSHF 
OPCODE PUSHFD 
ASM-OP QWORD 
: R/M,MMXREG ( addressing mode is register/memory, mmx-register   ) 
( -- ) 
: R/M,REG ( addressing mode is register/memory, register ) 
( -- ) 
: R/M,XMMREG ( addressing mode is register/memory, xmm-register ) 
( -- ) 
: R32? ( - flag ) 
OPCODE RCL 
OPCODE RCR 
OPCODE RDMSR 
OPCODE RDTSC 
: REFSIZE ( determine the size of a bound reference ) 
( addr of instr -- addr of operand \ size ) 
: REG,R/M ( addressing mode is register, register/memory ) 
( -- ) 
CONSTANT REGISTER ( a general purpose machine register ) 
DEFER REGISTER-ASM 
DEFER REGISTER-REF 
INST-PRE REP 
INST-PRE REPE 
INST-PRE REPNE 
INST-PRE REPNZ 
: REPORT-ERRORS ( turn on error reporting ) 
INST-PRE REPZ 
: RESET-ASM 
: RESET-FOR-NEXT-INSTR ( store a 0 into intermediate coding variables ) 
: RESET-SYNTAX ( reset the assembler to the previously flagged syntax ) 
( prev. mode==postfix -- ) 
: RESET-VARS ( store 0 into all instruction coding variables ) 
: RESOLVE ( resolve a forward reference to code-here ) 
( ref# -- ref# ) 
: RESTORE-CURRENT ( restore current to its previously saved value ) 
( -- ) 
OPCODE RET 
: RET-COMPILE ( compile the RET instruction ) 
( param -- | x \ param -- ) 
OPCODE RETF 
: RETF-COMPILE ( compile RETF ) 
( param -- | x \ param -- ) 
: RETF? ( adjust opcode for far return ) 
( x -- x' ) 
OPCODE ROL 
OPCODE ROR 
OPCODE RSM 
VARIABLE RTYPE ( the working register type ) 
: RTYPE! ( store the addressing mode type and update maxtype ) 
( type -- ) 
VARIABLE S-I-B ( the working area for the s-i-b byte ) 
: S-I-B, ( compile the s-i-b byte ) 
( -- ) 
CONSTANT S-I-B-BIT ( flag the beginning of s-i-b creation ) 
OPCODE SAHF 
OPCODE SAL 
OPCODE SAR 
: SAVE-CURRENT ( save the current vocabulary linkage ) 
( -- ) 
: SAVE-DEPTH ( -- ) 
: SAVE-IMMED ( save immediate operands for double-shift ) 
( x \ param -- param ) 
DEFER SAVE-INST ( save the current instruction -- used in postfix mode ) 
: SAVE-OFFSET ( save the offset, if it's present ) 
( x -- | -- ) 
OPCODE SBB 
OPCODE SCAS 
OPCODE SCASB 
OPCODE SCASD 
OPCODE SCASW 
: SEG, ( generate a necessary segment override prefix ) 
( -- ) 
: SEG-PRE 
VARIABLE SEG-PREFIX ( segment override prefix ) 
: SET-REGISTER-ASM 
: SET-REGISTER-REF 
OPCODE SETA 
OPCODE SETAE 
OPCODE SETB 
OPCODE SETBE 
OPCODE SETC 
: SETCC-COMPILE ( compile SETcc instructions ) 
( param -- | x \ param -- ) 
OPCODE SETE 
OPCODE SETG 
OPCODE SETGE 
OPCODE SETL 
OPCODE SETLE 
OPCODE SETNA 
OPCODE SETNAE 
OPCODE SETNB 
OPCODE SETNBE 
OPCODE SETNC 
OPCODE SETNE 
OPCODE SETNG 
OPCODE SETNGE 
OPCODE SETNL 
OPCODE SETNLE 
OPCODE SETNO 
OPCODE SETNP 
OPCODE SETNS 
OPCODE SETNZ 
OPCODE SETO 
OPCODE SETP 
OPCODE SETPE 
OPCODE SETPO 
OPCODE SETS 
OPCODE SETZ 
OPCODE SGDT 
OPCODE SHL 
OPCODE SHLD 
ASM-OP SHORT 
CONSTANT SHORT-BIT ( flag short ) 
OPCODE SHR 
OPCODE SHRD 
ASM-OP SI 
OPCODE SIDT 
: SIZE-COND-COMP ( compile a size conditional assembly sequence ) 
( param -- ) 
OPCODE SLDT 
OPCODE SMSW 
ASM-OP SP 
VARIABLE SP-SAVE ( the stack pointer ) 
: SPECIAL-PROCESS? ( do we need to specially process this register? ) 
( -- flag ) 
: SPECIAL-REGISTER? ( is this a special register? MMX/XMM registers are NOT special ) 
( -- flag ) 
CONSTANT SREG ( a segment register ) 
ASM-OP SS 
SEG-PRE SS: 
ASM-OP ST 
ASM-OP ST(0) 
ASM-OP ST(1) 
ASM-OP ST(2) 
ASM-OP ST(3) 
ASM-OP ST(4) 
ASM-OP ST(5) 
ASM-OP ST(6) 
ASM-OP ST(7) 
OPCODE STC 
OPCODE STD 
OPCODE STI 
OPCODE STOS 
OPCODE STOSB 
OPCODE STOSD 
OPCODE STOSW 
OPCODE STR 
: STR-ENTRY ( check for entry error conditions ) 
( param -- param ) 
: STR-INST ( the engine to create string instructions ) 
( param -- ) 
: STR-OPERANDS ( process operands for string instructions ) 
( -- ) 
OPCODE SUB 
: SUBR: ( create a subroutine in the assembler vocabulary ) 
VARIABLE SV-INST-PREFIX ( the saved instruction prefix ) 
: SWAP-REGS ( swap the order of registers in the mod-r/m byte ) 
( -- ) 
ASM-OP TBYTE 
OPCODE TEST 
: TEST-COMPILE ( compile the test instruction, which is a special group3 ins ) 
( param -- | x \ param -- | x \ x' \ param -- ) 
ASM-OP TR3 
ASM-OP TR4 
ASM-OP TR5 
ASM-OP TR6 
ASM-OP TR7 
CONSTANT TREG ( a test register ) 
CONSTANT UNKNOWN ( also, operand type and number ) 
: UNSAVE-CURRENT ( reset current-sv ) 
( -- ) 
: USE16 ( generate 16 bit code by default ) 
: USE32 ( generate 32 bit code by default ) 
OPCODE VERR 
OPCODE VERW 
OPCODE WAIT 
OPCODE WBINVD 
ASM-OP WORD 
: WORD-STR-INST ( word string instructions ) 
( param -- ) 
OPCODE WRMSR 
OPCODE XADD 
OPCODE XCHG 
: XCHG&ALU-COMPILE ( compile CMPXCHG or XADD ) 
( param -- | x \ param -- ) 
: XCHG-COMPILE ( compile the XCHG instruction ) 
( param -- | x \ param -- ) 
OPCODE XLAT 
: XLAT-COMPILE ( compile XLAT ) 
( param -- ) 
OPCODE XLATB 
: XLATB-COMPILE ( compile XLATB ) 
( param -- ) 
CONSTANT XMM-DIR-BIT ( flag the direction in case of XMM register(s) 
: XMM-DIR? ( is the destination an xmm-register? ) 
( -- flag ) 
VARIABLE XMM/MMX-PREFIX \ xmm (2) or mmx (1) or neither (0) regs used )
ASM-OP XMM0 
ASM-OP XMM1 
ASM-OP XMM2 
ASM-OP XMM3 
ASM-OP XMM4 
ASM-OP XMM5 
ASM-OP XMM6 
ASM-OP XMM7 
CONSTANT XMMREG ( an XMM register ) 
( encode and decode register representations ) 
( register encoding: ) 
( bits  use ) 
( 0-3   data size ) 
( 4-7   address size ) 
( 8-11  type ) 
( 12-13 r/m or s-i-b ) 
: XMMREG,R/M ( addressing mode is xmm-register, register/memory ) 
( -- ) 
OPCODE XOR ( create code definitions ) 
: [(E)BP]? ( does the address mode have either [bp] or [ebp] alone, or [ebp] as base? ) 
( -- flag ) 
\ arm 02/12/2003 19:20:37 correction for <0 [ebp] [reg]>
ASM-OP [BP+DI] 
ASM-OP [BP+SI] 
ASM-OP [BP] 
ASM-OP [BX+DI] 
ASM-OP [BX+SI] 
ASM-OP [BX] 
ASM-OP [DI] 
ASM-OP [DWORD] 
ASM-OP [EAX*2] 
ASM-OP [EAX*4] 
ASM-OP [EAX*8] 
ASM-OP [EAX] 
ASM-OP [EBP*2] 
ASM-OP [EBP*4] 
ASM-OP [EBP*8] 
ASM-OP [EBP] 
ASM-OP [EBX*2] 
ASM-OP [EBX*4] 
ASM-OP [EBX*8] 
ASM-OP [EBX] 
ASM-OP [ECX*2] 
ASM-OP [ECX*4] 
ASM-OP [ECX*8] 
ASM-OP [ECX] 
ASM-OP [EDI*2] 
ASM-OP [EDI*4] 
ASM-OP [EDI*8] 
ASM-OP [EDI] 
ASM-OP [EDX*2] 
ASM-OP [EDX*4] 
ASM-OP [EDX*8] 
ASM-OP [EDX] 
ASM-OP [ESI*2] 
ASM-OP [ESI*4] 
ASM-OP [ESI*8] 
ASM-OP [ESI] 
ASM-OP [ESP] 
: [ESP]? ( does it have only a base of esp? ) 
( -- flag ) 
: [ESP][REG]? ( does it have esp as an index register? ) 
( -- flag ) 
: [REG*N]? ( does it have only an index register? ) 
( -- flag ) 
ASM-OP [SI] 
ASM-OP [WORD] 
: _;CODE ( create the [;code] part of a low level defining word ) 
: _?ADSIZE1 ( is the address size mismatched? ) 
( n -- ) 
: _?ADSIZE2 ( just store the address size ) 
( n -- ) 
: _?BADCOMBINE ( can the operand types be combined? ) 
( flag -- ) 
: _?BADMODE ( is the address mode illegal? ) 
( flag -- ) 
: _?BADTYPE ( is the operand type allowed? ) 
( max type allowed -- ) 
: _?FINISHED ( are there operands left? ) 
( -- ) 
: _?INST-PRE ( is there any instruction prefix? ) 
: _?LOCK ( is there a LOCK prefix? ) 
: _?MATCH ( error if the parameters match ) 
( x1 \ x2 -- ) 
: _?MEM ( is one of the operands in memory? ) 
( -- ) 
: _?NOADSIZE ( no or unknown address size ) 
( -- ) 
: _?NOFAR ( is there an unallowed far reference? ) 
( -- ) 
: _?NOIMMED ( is there an illegal immediate operand? ) 
( -- ) 
: _?NOMATCH ( error if the parameters don't match ) 
( x1 \ x2 -- ) 
: _?NOTENOUGH ( are there not enough operands? ) 
( n -- ) 
: _?OPERANDS ( are there any operands? ) 
: _?OPSIZE1 ( is the operand size mismatched? ) 
( n -- ) 
: _?OPSIZE2 ( just store the operand size ) 
( n -- ) 
: _?PARAMS ( are there parameters on the stack? ) 
: _?R/M,REG ( is the source a register? ) 
( -- ) 
: _?REG ( are all of the operands register? ) 
( -- ) 
: _?REG,R/M ( is the destination a register? ) 
( -- ) 
: _?REP ( is there a repeat prefix? ) 
: _?SEG ( is there a segment override? ) 
: _?SHORT ( is the address short? ) 
( -- ) 
: _?TOOFAR ( is the branch offset to far? ) 
( flag -- ) 
: _?TOOMANYOPS ( are there too many operands? ) 
( max allowed operands -- ) 
: _?UNRES ( are there any unresolved forward reference labels? ) 
( -- ) 
: _CODE ( start a native code definition ) 
: _DO-OPCODE ( create the actual opcode, or at least call the functions ) 
( that do ... ) 
( x? \ x? \ 0|addr -- ) 
: _END-CODE ( end a code definition ) 
: _SAVE-INST ( save the current instruction, and fetch the previous one ) 
( also swaps instruction prefixes ) 
( a -- a' ) 
NEWUSER #FILES \ number of files found
: (DOSTIME) ( n -- ) 
: .DIR->FILE-NAME ( -- ;print file name in the dir ) 
: .DIR->FILE-SIZE ( -- ) 
\ Print the size or directory indication of a file 
\ Need to call find-first-file or find-next-file word before using this word. 
\ Can be used in combination with ForAllFileNames
: .FILE-SIZE-NAME ( adr len - ) 
\ Print the size or directory indication and the name of file.
\ It also formats the line. 
\ Need to call find-first-file or find-next-file word before using this word. 
\ Can be used in combination with ForAllFileNames
: ASCIIZ->ASC-LEN ( adrz -- sadr slen ) 
: CAPS-COMPARE { sa1 sn1 sa2 sn2 \ st1 st2 -- f1 } 
: CAPS-SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag ) 
\ Search the string specified by c-addr1 u1 for the string specified by c-addr2 u2,
\ using a case-insensitive search. 
\ If flag is true, a match was found at c-addr3 with u3 characters remaining. 
\ If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
{ s-adr s-len t-adr t-len \ t-buf t-str -- adr len flag } 
: DIR ( "name" -- ) 
\ W32F      Files Extra
\ Print all the files and sub-directories in a directory that match a specific
\ pattern. 
\ If "name" is missing or ends in \ or / search for all files that match *.* \n
\ If "name" contains a relative path then it's relative to the current directory. 
\ If "name" ends in : assume a drive use "name"\*.* for the search pattern. \n
\ The pattern can contain the standard Windows wildcards.
: DIR->FILE-NAME ( -- adr count ) 
\ Returns the address and count of a file in a directory. 
\ Need to call find-first-file or find-next-file word before using this word. 
\ Can be used in combination with ForAllFileNames
: DIR-ATTRIBUTE? ( - flag ) 
\ Returns true when a file is a directory. 
\ You need to call find-first-file or find-next-file word in the current task
\ before using this word. 
\ Can be used in combination with ForAllFileNames
: DO-RENAME-AFILE { RenamePart1$ RenamePart2$ \ RenameTemp$ -- } 
\ rename one file
NEWUSER FILE-TIME-BUF \ 2Variable to hold the FILETIME structure, which is a little endian (i.e. reversed order)
\ 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.
: FILETIME-TO-SYSTEMTIME ( cell# -- ; convert file time to system time ) 
\ need to call find-first-file or find-next-file word
\ before using this word
\ cell# is offset in number of cells to _win32-find-data
\ 1 for creation time; 3 for access time; and 5 for write time
\ normaly 5 should be used
: FIND-CLOSE ( -- ior ) 
\ Close the _hdl-search handle.
: FIND-FIRST-FILE ( addr1 len1 -- addr2 ior ) 
\ addr1 len1 is a string that specifies a valid directory or path
\ and filename, which can contain wildcard characters (* and ?).
\ This string must not exceed MAX_PATH characters.
\ addr2 is the address of the _win32-find-data structure.
\ ior is 0 for success in which case _hdl-search contains a valid handle.
\ Find-First-File searches a directory for a file whose name matches the
\ specified filename. Find-First-File examines subdirectory names as well as filenames.
\ Find-First-File opens a search handle and returns information about the first
\ file whose name matches the specified pattern. Once the search handle is established, you
\ can use Find-Next-File to search for other files that match the same pattern.
\ When the search handle is no longer needed, close it by using Find-Close.
\ Find-First-File searches for files by name only; it cannot be used for attribute-based
\ searches.
: FIND-NEXT-FILE ( -- addr ior ) 
\ Find-first-file word must be called
\ before this word can be called due to the fact that _hdl-search is needed
: FORALLFILENAMES { cfa } 
( adr slen cfa -- ) 
\ Executes the CFA for each found file in a directory. 
\ A file specification adr slen may contain wildcards 
\ NOTE: Directory names are also considered to be a file-name. 
\ Directory names can be detected by dir-attribute?
: FORALLFILES ( cfa -- ) 
\ Executes the CFA on ALL found files in a directory. 
\ NOTE: Directory names are also considered to be a file-name. 
\ Directory names can be detected by dir-attribute? 
: GET-DOS-ACCESS-DATETIME ( -- ;convert 64 bit file time to MS_DOS ) 
\ date and time values of last access. 
\ You need to call find-first-file or find-next-file word in the current task
\ before using this word.
: GET-DOS-CREATE-DATETIME ( -- ;convert 64 bit file time to MS_DOS ) 
\ Date and time values of creation. 
\ You need to call find-first-file or find-next-file word in the current task
\ before using this word.
: GET-DOS-WRITE-DATETIME ( -- ;convert 64 bit file time to MS_DOS ) 
\ Date and time values of last write. 
\ You need to call find-first-file or find-next-file word in the current task
\ before using this word.
: GET-FILE-MODIFIED ( fileid -- system-time ) 
: GET-FILE-NAME ( -- adr; address for file name ) 
\ get the name of the last found file. 
\ You need to call find-first-file or find-next-file word in the current task
\ before using this word.
: GET-FILE-SIZE ( -- size ) 
\ W32F               Files Extra
\ Size of the last found file. 
\ You need to call find-first-file or find-next-file word in the current task
\ before using this word.
: GET-FSPACE { zroot \ clus freclus b/sec s/clus -- as bs cs ds } 
\ Get a drive's free space, cluster and sector information
\ "zroot" is the root directory spec zString for the desired drive in the
\ format z" x:\", where x can be a, b, c, d or e etc...
: PRINT-DIR-FILES ( adr slen -- ) 
\ W32F      Files Extra
\ Print all the files and sub-directories in a directory that match a specific
\ pattern.
NEWUSER PTR-DOS-DATE \ ptr to 16 bit DOS date
NEWUSER PTR-DOS-TIME \ ptr to 16 bit DOS time
: RENAME ( -<name1 part1 part2>- ) 
\ rename file or files
{ \ RenameFrom$ RenamePart1$ RenamePart2$ -- } 
CONSTANT SIZEOF(_SYSTEMTIME) 
NEWUSER TOTAL-FILE-BYTES \ total bytes in files found
NEWUSER WDAY 
NEWUSER WDAYOFWEEK 
NEWUSER WHOUR 
NEWUSER WMILLISECONDS \ ------------------------------------------------------------------------
\ Some case insensitive version of search and compare
\ ------------------------------------------------------------------------
\ enhanced caps-search for source string > 255 bytes
\ search for t-adr,t-len within string s-adr,s-len. f1=true if string was found
NEWUSER WMINUTE 
NEWUSER WMONTH 
NEWUSER WSECOND 
NEWUSER WYEAR 
NEWUSER _HDL-SEARCH ( -- addr ) 
\ Variable holding handle.
: _PRINT-DIR-FILES ( adr slen -- ) 
NEWUSER _SYSTEMTIME \ Structure FileTimeToSystemTime
\ function; this struc is same as time-buf in kernel.tom
NEWUSER _WIN32-FIND-DATA \ struct FindFileFirst or
\ FindNextFile Functions
\ 0 ,                                 \ dwFile Attributees
\ 0 , 0 ,                             \ ftCreationTime - FILETIME -
\ \ (struct) dwLowDateTime
\ \          dwHighDateTime
\ 0 , 0 ,                             \ ftLastAccessTime - FILETIME
\ 0 , 0 ,                             \ ftLastWriteTime - FILETIME
\ 0 ,                                 \ nFileSizeHigh
\ 0 ,                                 \ nFileSizeLowh
\ 0 ,                                 \ dwReserved0
\ 0 ,                                 \ dwReserved1
\ MAX-PATH allot                      \ cFileName[MAX_PATH]
\ 14 allot                            \ cAlternateFileName[14]
MACRO: ;M 
MACRO: AH, 
MACRO: AL, 
MACRO: AX, 
MACRO: BH, 
MACRO: BL, 
MACRO: BP, 
MACRO: BX, 
MACRO: CH, 
MACRO: CL, 
MACRO: CR0, 
MACRO: CR2, 
MACRO: CR3, 
MACRO: CR4, 
MACRO: CS, 
MACRO: CX, 
MACRO: DH, 
MACRO: DI, 
MACRO: DL, 
MACRO: DR0, 
MACRO: DR1, 
MACRO: DR2, 
MACRO: DR3, 
MACRO: DR6, 
MACRO: DR7, 
MACRO: DS, 
MACRO: DX, 
MACRO: EAX, 
MACRO: EBP, 
MACRO: EBX, 
MACRO: ECX, 
MACRO: EDI, 
MACRO: EDX, 
MACRO: ES, 
MACRO: ESI, 
MACRO: ESP, 
MACRO: FS, 
MACRO: GS, 
MACRO: SI, 
MACRO: SP, 
MACRO: SS, 
MACRO: ST(0), 
MACRO: ST(1), 
MACRO: ST(2), 
MACRO: ST(3), 
MACRO: ST(4), 
MACRO: ST(5), 
MACRO: ST(6), 
MACRO: ST(7), 
MACRO: ST, 
MACRO: TR3, 
MACRO: TR4, 
MACRO: TR5, 
MACRO: TR6, 
MACRO: TR7, 
MACRO: XMM0, 
MACRO: XMM1, 
MACRO: XMM2, 
MACRO: XMM3, 
MACRO: XMM4, 
MACRO: XMM5, 
MACRO: XMM6, 
MACRO: XMM7, 
MACRO: [BP+DI], 
MACRO: [BP+SI], 
MACRO: [BP], 
MACRO: [BX+DI], 
MACRO: [BX+SI], 
MACRO: [BX], 
MACRO: [DI], 
MACRO: [EAX*2], 
MACRO: [EAX*4], 
MACRO: [EAX*8], 
MACRO: [EAX], 
MACRO: [EBP*2], 
MACRO: [EBP*4], 
MACRO: [EBP*8], 
MACRO: [EBP], 
MACRO: [EBX*2], 
MACRO: [EBX*4], 
MACRO: [EBX*8], 
MACRO: [EBX], 
MACRO: [ECX*2], 
MACRO: [ECX*4], 
MACRO: [ECX*8], 
MACRO: [ECX], 
MACRO: [EDI*2], 
MACRO: [EDI*4], 
MACRO: [EDI*8], 
MACRO: [EDI], 
MACRO: [EDX*2], 
MACRO: [EDX*4], 
MACRO: [EDX*8], 
MACRO: [EDX], 
MACRO: [ESI*2], 
MACRO: [ESI*4], 
MACRO: [ESI*8], 
MACRO: [ESI], 
MACRO: [ESP], 
MACRO: [SI], 
: (MACRO[) 
: (]MACRO) 
MACRO: C; ( -- ) 
\ alias for ;c and end-code
: CODE-HEADER ( -- ) 
: MACRO[ ( create a macro in the assembler vocabulary ) 
DEFER NCODE 
MACRO: NEXT, ( -- ) 
\ an alias name for next
MACRO: PTR ( -- ) 
\ does nothing in this assembler
: RESOLVE-OFA ( -- ) 
\ resolve OFA to contain code length in bytes
: SUBR: 
MACRO: TOS ( -- ) 
MACRO: TOS, ( -- ) 
MACRO: WINCALL ( "Proc" ) 
\ A macro: to call a windows procedure. The arguments must be pushed onto the system stack
\ beforehand and the return value is in eax. For calls with a C convention rather than
\ standard call the stack must be cleaned up.
MACRO: [TOS] ( -- ) 
MACRO: [TOS], ( -- ) 
MACRO: [UP] ( n1 -- ) 
\ calculate offset for [edx]
MACRO: [UP], ( n1 -- ) 
\ calculate offset for [edx]
: ]MACRO ( end a macro definition ) 
: _CODE> ( -- ) 
\ create the ;code part of a low level defining word
: _ENTER-ASSEMBLER ( -- ) 
: _EXIT-ASSEMBLER ( -- ) 
: _NOPT-CODE 
: _OPT-CODE ( -<name>- ) 
\ redefine to resolve code length in bytes
CREATE CONFIG$ 
: FORTHBOOT ( -- ) 
: LOADCONFIGFILE { addr -- } 
: SET-SHELL 
CREATE USERCONFIG$ 
BYTES &PS 
: (CLASSINIT) ( -- ) 
: (CLASSINIT) ( n1 -- ) 
: (CLASSINIT) ( x y width height -- ) 
CONSTANT 1/1 
CONSTANT 1/2 
CONSTANT 1/4 
CONSTANT 2/2 
CONSTANT 2/4 
CONSTANT 3/4 
CONSTANT 4/4 
|CLASS ADDBUTTON 
|CLASS ADDBUTTON 
|CLASS ADDXYBUTTON 
|CLASS ADDXYBUTTON 
:M AMFORGROUND?: ( -- f1 ) 
INT BAR-NAME 
INT BCNT \ count of buttons in bar
INT BFUNC 
:CLASS BHBUTTONBAR 
:CLASS BHBUTTONBAR 
INT BHEIGHT 
INT BHEIGHT 
INT BHOFFSET \ horizontal offset
INT BHOFFSET \ horizontal offset
INT BHOFFSET \ horizontal offset
INT BID \ button id counter
INT BMP-ADR 
INT BMP-LEN 
INT BMP-OFF 
CREATE BMPBITMAP 
CREATE BMPHEADER 
CREATE BMPINFOHEADER 
CREATE BMPRECT 
CONSTANT BORDER-WIDTH 
INT BPREV 
INT BPREV 
INT BPREV 
VALUE BUILDBAR \ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ Define a Generic Push Button Bar class
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
:CLASS BUTTON 
:CLASS BUTTON 
: BUTTON+H ( -- n1 ) 
: BUTTON+H ( -- n1 ) 
: BUTTON+H ( -- n1 ) 
: BUTTON+V ( -- n1 ) 
INT BVOFFSET \ vertical   offset
INT BVOFFSET \ Vertical offset
INT BWIDTH 
INT BX 
INT BY 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( n1 -- ) 
:M CLASSINIT: ( n1 -- ) 
:M CLASSINIT: ( x y width height -- ) 
:M CLASSINIT: ( editWidth -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( editWidth -- ) 
:M CLASSINIT: ( -<toolbarname>- ) 
\ follow by .BMP toolbar filename
:M CLASSINIT: ( -- ) 
:M CLOSE: ( -- ) 
:CLASS COMBOFIELD 
:CLASS COMBOFIELD 
INT COMBOHEIGHT 
INT COMBOWIDTH 
WINDC DC \ The window's device context
VALUE DEFBHEIGHT 
VALUE DEFBWIDTH \ should be an ODD number for things to work well
VALUE DEFTOOLHEIGHT 
VALUE DEFTOOLSPACING \ one pixel overlap between buttons
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ Define the Button Bar for Exec
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
VALUE DEFTOOLWIDTH 
:M DOBUTTON: ( -- ) 
\ a NOOP needed by TOOLBAR
:M DOBUTTON: ( -- ) 
\ a NOOP needed by TOOLBAR
:M DOBUTTON: ( -- ) 
:CLASS EDITFIELD 
:CLASS EDITFIELD 
INT EDITHEIGHT 
INT EDITWIDTH 
:M EXWINDOWSTYLE: ( -- extended_style ) 
INT FLOATBAR \ -------------------- Methods --------------------
:CLASS GENERIC-BUTTONBAR 
:CLASS GENERIC-BUTTONBAR 
:M GETBAR: ( -- hbb ) 
:M GETBCNT: ( -- bcnt ) 
:M GETBHEIGHT: ( -- button_height ) 
:M GETBHEIGHT: ( -- edit_height ) 
:M GETBHEIGHT: ( -- edit_height ) 
:M GETBWIDTH: ( -- edit_width ) 
:M GETBWIDTH: ( -- edit_width ) 
:M GETBWIDTH: ( -- button_width ) 
:M GETORIGIN: ( -- x y ) 
:M GETPREV: ( -- bprev ) 
:M GETPREV: ( -- bprev ) 
:M GETPREV: ( -- bprev ) 
:M GETWINDC: ( -- dc ) 
INT HB \ handle to current button
INT HBB \ Handle to the button bar
:CLASS HBUTTONBAR 
:CLASS HBUTTONBAR 
CONSTANT HORIZONTAL-OFFSET 
|CLASS HSPACE 
|CLASS HSPACE 
:CLASS LRBUTTONBAR 
:CLASS LRBUTTONBAR 
:M MOVE: ( x y x y -- ) 
:M NEXTBID: ( -- bid ) 
:M ONWMCOMMAND: ( hwnd msg wparam lparam -- hwnd msg wparam lparam ) 
:M ON_BUTTON: { bidl \ hbl -- } 
:M ON_DONE: ( -- ) 
:M ON_DONE: { \ hbl -- } 
\ initialize the class
:M ON_INIT: { \ hbl -- } 
\ initialize the class
:M ON_LBUTTONUP: ( h m w l -- ) 
:M ON_PAINT: ( -- ) 
:M ON_SIZE: ( -- ) 
\ handle resize message
:M ON_SIZE: ( -- ) 
\ handle resize message
:M ON_SIZE: ( -- ) 
\ handle resize message
:M ON_SIZE: ( -- ) 
\ handle resize message
:M ON_SIZE: ( -- ) 
\ handle resize message
INT PICTURE-BITMAP 
WINDC PICTURE-DC 
INT PICTURE-NUMBER 
|CLASS PICTUREBUTTON 
|CLASS PICTUREBUTTON 
INT PREV-BITMAP 
:M PUTBAR: ( hbb -- ) 
:M PUTBCNT: ( bcnt -- ) 
: READ-BMP ( a1 n1 -- ) 
:M REMOVEFOCUS: ( -- f1 ) 
:M REMOVEFOCUS: ( -- f1 ) 
:M REMOVEFOCUS: ( -- f1 ) 
:M SETBHEIGHT: ( button_height -- ) 
:M SETBUTTONHEIGHT: ( height -- ) 
:M SETBUTTONWIDTH: ( width --  ) 
:M SETBWIDTH: ( button_width -- ) 
:M SETHEIGHT: ( height -- ) 
:M SETPREV: ( bprev -- ) 
:M SETPREV: ( bprev -- ) 
:M SETPREV: ( bprev -- ) 
CONSTANT SIZEOF(BMPBITMAP) 
CONSTANT SIZEOF(BMPHEADER) 
CONSTANT SIZEOF(BMPINFOHEADER) 
CONSTANT SIZEOF(RGBQUAD) 
:M START: { theParent \ hmem1 hmem2 lpbmi lpvBits hdcMem hbm -- } 
:M START: ( parent -- ) 
:M START: ( parent -- ) 
:M START: ( parent -- ) 
INT STARTED? 
:M STARTPOS: ( -- x y ) 
\ Starting Position
:M STARTPOS: ( -- x y ) 
\ Starting Position
:M STARTPOS: ( -- x y ) 
\ Starting Position
:M STARTPOS: ( -- x y ) 
\ Starting Position
:M STARTSIZE: ( width height ) 
:M STARTSIZE: ( -- width height ) 
\ starting window size
:M STARTSIZE: { \ Brows -- width height } 
\ starting window size
:M STARTSIZE: ( -- width height ) 
\ starting window size
:M STARTSIZE: ( width height ) 
:M STARTSIZE: ( -- width height ) 
\ starting window size
:M STARTSIZE: ( -- width height ) 
\ starting window size
INT TOOL-SPACING \ space between buttons
:CLASS TOOLBAR 
:CLASS TOOLBAR 
INT TOOLHEIGHT 
INT TOOLWIDTH 
:CLASS VBUTTONBAR 
:CLASS VBUTTONBAR 
CONSTANT VERTICAL-OFFSET 
:M WINDOWSTYLE: ( -- style ) 
\ return the window style
:M WINDOWSTYLE: ( -- style ) 
:M WINDOWSTYLE: ( -- style ) 
\ return the window style
:M WM_LBUTTONDOWN ( h m w l -- res ) 
:M WM_LBUTTONDOWN ( h m w l -- res ) 
:M WM_LBUTTONUP ( h m w l -- res ) 
:M WM_LBUTTONUP ( h m w l -- res ) 
:M WM_PAINT ( hwnd msg wparam lparam -- res ) 
: .FONTS ( -- ) 
\ w32f sys
\ Dump all installed Fonts to the console window.
\ The callback name is passed to windows as shown.
: BUILD-CALLBACK ( n1 -- a1 a2 ) 
\ w32f sys
\ Define a callback procedure.
: CALLBACK ( n "name" "function" -- ) 
\ w32f sys
\ Define a callback with "name" that has n arguments.
\ "name" will return the address of the callback at runtime.
\ Note that a maximum of 19 arguments is supported by Win32Forth.
CFA-CODE CALLBACK-BEGIN \ w32f intern
\ General start code, don't disturb EAX!
NCODE CALLBACK-RETURN \ w32f intern
\ General return code, restores all but ecx!
: CALLBACK: ( n "name" -- ) 
\ w32f sys
\ Define a callback function that has n arguments.
\ CALLBACK: creates TWO definitions! The first has the name you specify,
\ and the second has the same name, prefixed with a '&' meaning 'address of'
\ This second definition is the one which returns the address of the callback,
\ and must be passed to Windows.
\ Note that a maximum of 19 arguments is supported by Win32Forth.
CALLBACK: FONTFUNC { lplf lptm dwType lpData -- int } 
\ The callback function for EnumFonts() used by .FONTS to dump
\ all installed fonts to the console window.
\ This callback as specified by "EnumFonts" passes four (4) parameters to
\ the callback procedure, so we must say "4 CallBack: FontFunc" to define
\ a callback that accepts four parameters.
: __CDECL ( -- ) 
\ w32f sys
\ Turn on __cdecl type callback for the next callback only.
VARIABLE __CDECLV 
: __STDCALL ( -- ) 
\ w32f sys
\ Turn on stdcall type callback (the default).
:M AUTOSIZE: ( -- ) 
\ Size the window to fit into the client area of the parent window.
:CLASS CHILD-WINDOW 
:CLASS CHILD-WINDOW 
:M CLASSINIT: ( -- ) 
\ Initialise the class.
: CREATE-CHILD-WINDOW ( -- hWnd ) 
\ Create this child window.
:M GETID: ( -- n ) 
\ Get the ID for this child window.
:M GETPARENT: ( -- parent ) 
\ Get the object address of the parent window.
: GETPARENTWINDOW ( -- hWnd ) 
\ Get the parent window handle for this child window.
\ If this window has no parent the window of the console is used as the parent.
\ If no console is pressent the parent handle will be NULL.
INT ID \ id for this child window
\ int Parent    \ object address of the parent window
\ Note: this ivar was moved into the window class some time ago.
\ Altough it's not realy needed in the window class I (dbu) left
\ it there in order not to break too much code  (Sonntag, Juni 04 2006 dbu).
: REGISTER-CHILD-WINDOW ( -- f ) 
\ Register the window class for this child window.
:M SETID: ( n -- ) 
\ Set the ID for this child window.
:M SETPARENT: ( parent -- ) 
\ Set the object address of the parent window.
:M START: ( Parent -- ) 
\ Create this child window. Parent is the object address of the
\ parent window.
:M WINDOWSTYLE: ( -- style ) 
\ User windows should override the WindowStyle: method to
\ set the window style. Default is WS_CHILD and WS_VISIBLE.
:M WINDOWTITLE: ( -- Zstring ) 
\ User windows should override the WindowTitle: method to
\ set the window caption. Default is "".
CONSTANT THROW_BIG_BITS 
CONSTANT THROW_DISPOSE_ERR 
CONSTANT THROW_INDEX_OFR 
CONSTANT THROW_INVALID_IVAR 
CONSTANT THROW_INVALID_OBJ_REF 
CONSTANT THROW_IVAR_EXISTS 
CONSTANT THROW_METH_BUFF_OVERFLOW 
CONSTANT THROW_NEED_SEL 
CONSTANT THROW_NEW> 
CONSTANT THROW_NOT_CLASS 
CONSTANT THROW_NOT_CLASS_OR_OBJ 
CONSTANT THROW_NOT_IN_CLASS 
CONSTANT THROW_NOT_METHOD 
CONSTANT THROW_NOT_OBJ 
CONSTANT THROW_NOT_SEL 
CONSTANT THROW_NOT_SELF 
CONSTANT THROW_NO_BITS 
CONSTANT THROW_NO_CLONE 
CONSTANT THROW_NO_FIND_OBJ 
CONSTANT THROW_NO_FIND_VAR 
CONSTANT THROW_NO_WM 
CONSTANT THROW_OBJ_EXPOSED 
CONSTANT THROW_UNDEF_METH 
CONSTANT THROW_ZERO_BITS 
: #WIDTH ( -- n ) 
\ width of an idx element
VALUE &(IVB@) 
:M &OF: ( -- addr ) 
\ Return the address of the ivar.
: (;CLOBJ) ( -- ) 
: (BUILD) ( #elems ^class OR ^class -- ) 
\ Build an instance of a class
: (BUILDING) ( #elems ^class OR ^class -- ) 
: (CLASS) ( -- ) 
: (DEFER) ( ^obj -- ) 
\ look up SelID at IP and run the method
: (DO_MESSAGE) ( addr -- ) 
: (FINDM) ( SelID ^class -- m0cfa ) 
\ find method in a class
: (HEAPOBJ) { theClass \ dLen obAddr idWid #els -- addr } 
CFA-FUNC (IVB!) ( bits_to_store pfa+2*cells -- ) 
CFA-FUNC (IVB+!) ( bits_to_add pfa+2*cells -- ) 
CFA-FUNC (IVB@) ( pfa -- bitfield_contents ) 
NEWUSER (NEWOBJECT) \ Newest object being created
: (OBJ-BUILD) ( #elems ^class OR ^class -- ) 
\ Build an instance of a class
: (VFIND) ( str hash ^class -- str f | ^iclass t  ) 
: (|BUILD) ( #elems ^class OR ^class -- ) 
\ Build an instance of a class
: ** ( -- ) 
: ++1 ( char index -- ) 
: ++4 ( cell index -- ) 
: +RANGE 
: -RANGE 
: .CLASSES ( -- ) 
\ W32F        Class
\ Display all classes in the system.
\ Should really be in classdbg.
: .EXECUTION-CLASS-CLASS ( ip cfa flag -- ip' cfa flag ) 
:M .RECT: ( -- ) 
: .USEROBJECT: ( cfa -- ) 
: .WORD-TYPE-CLASS ( cfa flag -- cfa false | true ) 
: :CLASS ( -<class-name>- ) 
\ Define a class for creating a group of similar objects.
: :M ( -- ) 
: ;CLASS ( -- ) 
: ;M ( -- ) 
: ;OBJECT ( -- ) 
: ;RECORD ( -- ) 
\ W32F             Class
\ End a group of data fields that need to be contiguous.
: ;RECORDSIZE: ( -"name"- ) 
\ W32F             Class
\ End a group of data fields that need to be contiguous and create a name with the
\ size of the record.
: <BUILDING> ( #elems ^class OR ^class -- ) 
: <INDEXED ( width -- ) 
\ Set a class and its subclasses to indexed.
: <NOCLASSPOINTER ( -- ) 
\ Set a class to suppress the class pointer when used for IVARs.
\ Not inherited by subclasses.
\ XFA is -1 when no class pointer is reserved for IVARs.
: <SUPER ( -- ) 
\ W32F     Class
\ Allow inheriting from a class or an object
\ Specify the superclass of the class or object being created. Used as follows;
\       :Class  <newclassname> <Super <superclassname>
\       ;Class
\ 
\        - or -
\ 
\       :Object <newobjectname> <Super <superclassname>
\       :Object
: <VAR ( #elems ^class OR ^class -- ) 
OFFSET >CLASS ( objCfa -- ^'Class ) 
: >MASK ( n1 -- mask ) 
OFFSET >OBJ ( objCfa -- 'obj    ) 
: >SELECTOR ( str -- SelID ) 
\ get a selector from the input stream
: ?CLASS ( -- ) 
: ?DISPOSE ( addr -- ) 
\ Dispose of a dynamically allocated object if address is non-zero. Allows storing either
\ 0 or an object address in a value.
DEFER ?IDX 
: ?IS** ( cfa -- f ) 
: ?ISLOCAL ( cfa -- f ) 
: ?ISOBJ ( cfa -- f ) 
: ?ISPAREN ( cfa -- f ) 
\ >name nfa-count drop c@ [char] [ = ;
: ?ISSEL ( str -- str f1 ) 
\ f1 = true if it's a selector
: ?ISUSEROBJ ( cfa -- f ) 
: ?ISVALUE ( cfa -- f ) 
: ?ISVECT ( cfa -- f ) 
: ?IS[SELF] ( cfa -- f ) 
: ?RANGE ( index -- index ) 
\ range check
VALUE ?WIN-ERROR-ENABLED \ initially errors are enabled
: @IVARCPTR ( ivar -- flag ) 
: @IVARELEMS ( ivar -- #elems ) 
: @IVAROFFS ( ivar -- offset ) 
: @WIDTH ( ^class -- elWidth ) 
\ return the indexed element width for a class
: @WORD ( -<word>- addr ) 
:M ADD: ( n/d -- ) 
:M ADD: ( a1 n1 -- ) 
:M ADDR: ( -- addr ) 
RECORD: ADDROF 
:M AND: ( n1 -- ) 
\ Perform a bitwise AND on the contents of the ivar and n1 storing the result in the
\ ivar. Note dints perform the AND on the 2 cells of the ivar storing the result as the
\ most significant cell, with n1 as the least.
:M APPEND: ( a1 n1 -- ) 
: AT1 ( index -- char ) 
: AT4 ( index -- cell ) 
VALUE BEGINNINGOFRECORDADDRESS 
VALUE BITCNT 
: BITMAX ( n1 -- ) 
\ set max bits for any following bit fields
VALUE BITMAXVAL 
: BITS { nbits -- -"name"- } 
\ W32F          Class
\ Define an 'nbits' bit field in prev data item.
\ Example:
\         int   BinaryBits        \ a 32bit cell of bit fields
\       1 bits  fBinary           \ define the bit fields
\       1 bits  fParity
\       1 bits  fOutxCtsFlow
\       1 bits  fOutxDsrFlow
\       2 bits  fDtrControl
\       1 bits  fDtrSensitivity
\       1 bits  fTXContinueOnXoff
\       1 bits  fOutX
\       1 bits  fInx
\       1 bits  fErrorChar
\       1 bits  fNull
\       2 bits  fRtsControl
\       1 bits  fAbortOnError
\      17 bits  fDummy
INT BOTTOM 
:M BOTTOM: ( -- n1 ) 
: BUILD:CLASS ( -- ) 
: BUILD|CLASS ( -- ) 
: BYTE ( -"name"- ) 
\ W32F          Class
\ Byte (8bit) size instance variable.
: BYTES ( n -"name"- ) 
\ W32F          Class
\ n-Bytes instance variable (array of bytes)
: CLASS-ALIGN ( -- ) 
: CLASS-ALLOT ( n -- ) 
: CLASS-BITALLOT ( n -- ) 
CONSTANT CLASS-SIZE \ size of class pfa
OFFSET CLASS> ( ^'Class -- objCfa  ) 
OFFSET CLASS>OBJ ( ^'Class -- 'obj    ) 
DEFER CLASSINIT ( -- ) 
\ send ClassInit: to newObject
:M CLASSINIT: 
:M CLASSINIT: ( -- ) 
\ Initialise the object. The coordinates are set to zero.
: CLASSPOINTER? ( class -- f ) 
:CLASS CLASSROOT 
:CLASS CLASSROOT 
: CLASSVFIND ( str ^class -- str f OR ^iclass t ) 
: CLONE ( CfaOfObject  'newobject' -- ) 
\ clone a static object
\ Create an identical copy (clone) of an existing object
\ Use the following syntax:  ' ExistingObject Clone NameOfNewObject
NEWUSER COLDIM 
VALUE CONTIGUOUS-DATA? 
: DBG-NEST-CLASS ( top-of-user-stack cfa flag -- cfa false | true ) 
: DBG-NEXT-CELL-CLASS ( ip cfa -- ip' cfa ) 
FIELD+ DFA \ data area size in bytes
: DIMENSION ( Rows Cols -- Size ) 
\ Set the dimensions for the next 2 dimensional array to be created (either at compile
\ time, or at run-time using NEW>) and return the size (Rows*Cols). 
\ For dynamic object DIMENSION applies to the next 2 dimensional array in the same task.
: DINT ( -"name"- ) 
\ W32F          Class
\ Double (64bit) instance variable.
: DISPOSE ( addr -- ) 
\ Dispose of a dynamically allocated object.
CFA-CODE DOUSEROBJ 
: DO_MESSAGE ( -- ) 
:M ERASERECT: ( -- ) 
\ Set all coordinates to zero.
: FIND-METHOD ( SelID ^obj -- ^obj m0cfa ) 
\ find method in object
VALUE GET-REFERENCE? 
:M GET: ( -- a1 n1 ) 
:M GET: ( -- n1 ) 
: GETIVARREF { selID ^iclass -- ^obj m0cfa } 
: GETMETHOD { \ m0cfa -- -<method: object>- m0cfa } 
\ W32F        Class
\ Return the xt of method. Used in interpretive mode or to create parsing words.
: GETREF ( selPfa $str -- ^obj m0cfa ) 
: GETSELECT ( -- SelID ) 
\ get a selector from the input stream
: HASH> ( -<word>- hash ) 
\ rls
:M HEIGHT: ( -- n1 ) 
OFFSET ICLASS ( ivar -- 'class ) 
: IDX-HDR ( #elems ^class OR ^class -- indlen ) 
: IDXBASE ( -- addr ) 
\ get base of idx data area
FIELD+ IFA \ instance variable dictionary
: INHERIT ( pfa -- ) 
: INITIVAR ( ivar offset -- ) 
: INT ( -"name"- ) 
\ W32F          Class
\ Long integer (32bit) instance variable. When used as an object variable has the same
\ behaviour as VALUEs.
: ITRAV { ivar offset -- } 
DEFER IVAR-NAME 
: IVARREF { selID ^iclass \ Class offset -- } 
\ compile ivar reference
: LATEBOUND ( SelId -- ) 
\ Compile or execute a deferred message send
INT LEFT 
:M LEFT: ( -- n1 ) 
: LIMIT ( -- n ) 
\ get idx limit (#elems)
: M! ( n -- ) 
\ Store the TOS into the first cell of the object. Designed for use with VAR.
: M@ ( -- n ) 
\ Fetch the contents of the first cell of the object. Designed for use with VAR.
: METHOD ( SelID -- ) 
\ Build a methods dictionary entry for selector
: METHODCATCH \ synonym of catch
: METHODEXECUTE \ synonym of execute
VALUE METHOD_HVAL 
CREATE MET_HSTRING 
FIELD+ MFA \ method dictionary
: MSGFIND ( addr -- addr false | cfa true ) 
: NESTEDIVAR { Class offset \ rem$ -- 'Class 'offset } 
( argument is class and class is returned, word is rewritten ) 
: NESTEDOBJECT { Obj \ rem$ -- class 'Obj } 
( returns obj AND class, rewritten ) 
VARIABLE NEW-METHOD 
: NEW> ( -<class>- -- addr ) 
\ W32F                 Class
\ Allocate memory for an object of -<class>- on the heap, initialise the object
\ and return the object address.
: NEWOBJECT 
BUFFER: OBJ-BUF 
VALUE OBJ-CLASS 
VALUE OBJ-LOADLINE 
: OBJ.VAR, { selID ObjCfa \ Obj Class -- } 
OFFSET OBJ> ( 'obj -- objCfa  ) 
: OBJ>CLASS ( 'obj -- 'class  ) 
:CLASS OBJECT 
:CLASS OBJECT 
: OBJLEN ( -- objlen ) 
: OBJREF ( selID $str -- ) 
\ Build a reference to an object or vector
CREATE OBJ_HSTRING 
VALUE OLDCURRENT 
:M OR: ( n1 -- ) 
\ Perform a bitwise OR on the contents of the ivar and n1 storing the result in the
\ ivar. Note dints perform the OR on the 2 cells of the ivar storing the result as the
\ most significant cell, with n1 as the least.
:M PRINT: ( -- ) 
:M PUT: ( a1 n1 -- ) 
:M PUT: ( n/d -- ) 
: RECORD: ( -"name"- ) 
\ W32F             Class
\ Define a word that returns the starting address of a group of data fields that
\ need to be contiguous. Object IVARS have their class pointer suppressed if used
\ in a Record: so only objects that don't use late binding can be used.
:CLASS RECTANGLE 
:CLASS RECTANGLE 
: REFTOKEN ( str -- cfa tokenID ) 
\ Determine type of token referenced
\ by str.
: RESOLVE-METHODS ( -- ) 
INT RIGHT 
:M RIGHT: ( -- n1 ) 
NEWUSER ROWDIM \ =====================================================================
\ Runtime indexed range checking. Use +range and -range to turn range
\ checking on and off.
: RUNIVARREF { selID ^iclass \ Obj Class -- } 
\ run ivar reference (DEBUG ONLY!!)
: RUNOBJ.VAR { selID ObjCfa \ Obj Class -- ^obj m0cfa } 
: RUNREF ( selPfa $str -- ) 
\ Execute using token in stream
: SELF ( -- addr ) 
\ Compile a self reference so we can send ourself late-bound messages, but
\ only if the class is guaranteed to have a class pointer.
\ with the syntax:   Msg: [ self ].
:M SETRECT: ( left top right bottom -- ) 
\ Set coordinates
FIELD+ SFA \ pointer to superclass
: SHORT ( -"name"- ) 
\ W32F          Class
\ Word integer (16bit) instance variable. When -"name"- is executed the value of -"name"-
\ is zero-extended before pushing onto the stack.
:CLASS STRING 
:CLASS STRING 
NAMED-NEW$ TEMPMSG$ 
BYTES THEBUFFER 
: TO1 ( char index -- ) 
: TO4 ( cell index -- ) 
INT TOP 
:M TOP: ( -- n1 ) 
CONSTANT UNRES-LEN 
CREATE UNRES-METHODS 
: USEROBJ.VAR, { selID ObjCfa \ Obj Class -- } 
: USEROBJECT: ( Define: "class" "name" -- Child: -- addr ) 
\ Create a new user variable that is a pointer to either the object following object ( for the main task only )
\ or to a dynamic object on the heap ( for other tasks ). The dynamic object is only created the first time it's
\ referenced. The pointer is set for the main task at compile time or the first usage for a saved program.
VALUE VARCFA 
: VARFIND { Class -- CfaObj } 
( argument is a class ) 
: VFIND ( str -- str f OR ^iclass t ) 
CONSTANT WARN_CLASH 
OFFSET WFA 
:M WIDTH: ( -- n1 ) 
: WM: ( WM_MESSAGE -<object>- ) 
\ WM_CLOSE WM: Super
CREATE X.BUF 
: X.DO_MESSAGE ( -- ) 
\ Not normally used directly
FIELD+ XFA \ width of indexed items
:M XOR: ( n1 -- ) 
\ Perform a bitwise XOR on the contents of the ivar and n1 storing the result in the
\ ivar. Note dints perform the XOR on the 2 cells of the ivar storing the result as the
\ most significant cell, with n1 as the least.
: [GETMETHOD] ( compiling:- -<method: object>- -- ) 
( runtime:-  -- m0cfa ) 
\ W32F Class
\ Compile the xt of the method as a literal into the current definition. Compile only.
: [SELF] ( -- ) 
: [[ ( "code to evaluate< ]]>" -- ) 
\ W32F          Class   In-System Forth
\  Interpretation:  When preceeded by a selector, parses the input stream up to a
\ terminating ]] evaluates the code and then executes the method for the object
\ address on the stack. An error will occur if "code to evaluate" does not produce
\ a valid object address. 
\ An error also occurs if [[ isn't preceeded by a selector.
\  Compilation:  When preceeded by a selector, compiles the input stream up to a
\ terminating ]] and then compiles a late-bound call to the method selector
\ address on the stack. A run-time error will occur if "code to evaluate" does not
\ produce a valid object address. 
\ An compile-time error also occurs if [[ isn't preceeded by a selector.
VALUE ^CLASS \ pointer to class being defined
\ references are from class pfa
: ^ELEM ( index -- addr ) 
\ get addr of idx element
VALUE ^SELF 
VALUE ^SUPER \ nfa of SUPER pseudo-Ivar
: _.USEROBJECT: ( cfa -- cfa|0 ) 
: _CLASH ( hash-val -- ) 
: _CLASSINIT ( -- ) 
: _DO_MESSAGE ( val string -- ) 
\ normal stack format
( val string -- ^obj m0cfa ) 
\ if 'get-reference?' is ON
\ this second stack picture provided for debugger/decompiler
: _MSGFIND { addr \ temp$ -- addr false | cfa true } 
: |CLASS ( -- ) 
\ Defines a class that creates headerless objects.
\ |Class objects should be linked in the ClassInit: method
\ Used primarily for defining menus, where the names of objects are not needed,
\ and where the objects are only accessed through a linked list, built using
\ the ClassInit: method.
:M ~: 
: "MATCHES ( addr len -- ) 
: #MATCHES ( n -- ) 
: .METHOD ( mlink -- mlink ) 
: .OBJ ( nfa -- ) 
: ?.MATCH ( n lfa -- n ) 
: CMETHODS ( 'class' -- ) 
\ W32F      Class debug
\ Print out all the methods of a class.
{ \ superlist -- } 
: IVARS ( object-address -- ) 
\ W32F      Class debug
\ Print out all the object IVARs of an object.
: MATCHES ( -"name"- ) 
\ W32F      Class debug
\ Print out all the method selectors and IVAR names that have the same hash value as
\ -"name"- will be assigned. If -"name"- is already in use as a selector or an IVAR name
\ then it will appear in the list.
: MDBG ( -<method object>- ) 
\ W32F       Class debug
\ Set debugging of the method and then execute it.
\ An Object must be supplied (Classes aren't allowed).
\ NOTE the method will be debugged for all objects that respond to it.
: MDEBUG ( -<method object>- ) 
\ W32F      Class debug
\ Set debugging of the method. An Object must be supplied (Classes aren't allowed).
\ NOTE the method will be debugged for all objects that respond to it.
: METHODS ( object-address -- ) 
\ W32F      Class debug
\ Print out all the methods of an object.
: MSEE ( -<method object>- ) 
\ W32F      Class debug
\ Display the source code of the method. Either a Class or Object can be supplied.
: OBJECTS ( 'class' -- ) 
\ W32F       Class debug
\ Display all of the instances of 'class'.
VALUE THECLASS 
: _METHODS ( class_body -- ) 
RECORD: &LOGBRUSH 
: (?COLORCHECK) ( a1 -- a1 ) 
: .COLORS ( -- ) 
\ Displays the current set of defined colors
DEFER ?COLORCHECK ( a1 -- a1 ) 
\ verify that a1 is a color object address
NEW-COLOR BLACK 
NEW-COLOR BLUE 
NEW-COLOR BROWN \ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ A class for HATCHED colors, HatchColorObject is a superset of ColorObject
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
:M BRUSH: ( -- hbrush ) 
\ get the color brush handle
:M CHOOSE: ( hWnd -- f ) 
\ let the user choose a color
:M CLASSINIT: ( -- ) 
\ compile time initialization for each color object
\ as it is defined
:M CLASSINIT: ( -- ) 
\ compile time initialization for each color object
\ as it is defined
:M COLOR: ( -- colorref ) 
\ get the colorref value
:CLASS COLOROBJECT 
:CLASS COLOROBJECT 
GDICOLORREF COLORREF \ the actual color reference value
VARIABLE COLORS-LINK \ Global private link of all colors in system
:M CUSTOMCOLORS: ( -- addr len ) 
\ return address and length of the user defined
\ custom colors
NEW-COLOR CYAN 
NEW-COLOR DKGRAY 
NEW-COLOR DKMAGENTA \ JaP
:CLASS EXTCOLOROBJECT 
:CLASS EXTCOLOROBJECT 
NEW-COLOR GRAY 
NEW-COLOR GREEN 
:CLASS HATCHCOLOROBJECT 
:CLASS HATCHCOLOROBJECT 
INT HBRUSH \ the brush handle
INT HPEN \ the pen handle
: IMAGESET?COLORSET ( -- ) 
: INIT-COLORS ( -- ) 
\ initialize brushes and pens
:M INITCOLOR: ( -- ) 
\ define color as a hatched color
:M INITCOLOR: ( -- ) 
\ default initialization method, creates a pen
\ and a brush for each color object.
:M INITCOLOR: ( -- ) 
\ default initialization method, creates a pen
\ and a brush for each color object.
INT LBCOLOR 
INT LBHATCH 
INT LBSTYLE 
INT LPSTYLE 
NEW-COLOR LTBLUE 
NEW-COLOR LTCYAN 
NEW-COLOR LTGRAY 
NEW-COLOR LTGREEN 
NEW-COLOR LTMAGENTA 
NEW-COLOR LTRED 
NEW-COLOR LTYELLOW 
NEW-COLOR MAGENTA 
: NEW-COLOR ( colorref -<name>- ) 
\ make a solid color
:M NEWCOLOR: ( colorref -- ) 
\ set a color object to a new color ref value
: PALETTEINDEX ( index -- colorref ) 
\ return ref of system color
: PALETTERGB ( red green blue -- colorref ) 
:M PEN: ( -- hpen ) 
\ get the color pen handle
INT PENSTYLE \ the style of the pen being created
INT PENWIDTH \ width of the pen in pixels
:M PENWIDTH: ( pen_width -- ) 
\ set the pen width
NEW-COLOR RED 
: RGB ( red green blue -- colorref ) 
INT STYLECOUNT 
: TRIM-COLORS ( nfa -- nfa ) 
: UNINIT-COLORS ( -- ) 
\ delete brushes and pens
:M UNINITCOLOR: ( -- ) 
NEW-COLOR WHITE 
NEW-COLOR YELLOW 
: ZERO-IMAGE-COLORS ( -- ) 
:M ZEROCOLOR: ( -- ) 
: "COMMENT ( a1 n1 -- ) 
\ everything is a comment up to the string a1,n1
: ( \ comment till )
: (( \ comment till ))
: // \ comment till end of line - synonym of \
: //{{NO_DEPENDENCIES}} 
: COMMENT \ -<char>-
: COMMENT: \ comment till COMMENT;
VALUE MULTI-LINE? \ we can have multiple line '(' comments
: \S \ comment to end of file
: _COMMENT \ char --
: _COMMEOF \ ( flag -- ) \ end of file abort if true
: +TAB ( --- ) 
: -TAB ( --- ) 
: 0TAB ( -- ) 
\ left margin goes to left edge of screen
DEFER >BOLD 
DEFER >NORM 
: ?CONTROL ( -- f1 ) 
\ return true if control is down
: ?LINE ( n1 -- ) 
: ?SHIFT ( -- f1 ) 
\ return true if shift is down
: AT-XY ( x y -- ) 
\ synonym of GOTOXY (ANS version of GOTOXY)
DEFER BEEP 
: BEEP! ( frequency duration-ms -- ) 
: COLS ( -- n1 ) 
\ current screen columns
: CONDC ( -- dc ) 
\ get the console device context
DEFER CONHNDL 
: CRTAB ( -- ) 
CONSTANT DOUBLE_MASK \ double click mask
CONSTANT DOWN_MASK \ mouse down mask
: EKEY>CHAR ( u -- u false | char true ) 
\ returns TRUE if displayable character
: EKEY>FKEY ( u1 -- u2 flag ) 
SYNONYM EKEY? KEY? ( -- flag ) 
SYNONYM EKEY? KEY? ( -- flag ) 
CONSTANT EMIT? ( -- flag ) 
\ return TRUE if its ok to emit a character
: FIRST-LINE ( -- ) 
\ set first line flag
VALUE FIRST-LINE? \ is this the first line of a paragraph
: FOCUS-CONSOLE ( -- ) 
CONSTANT FUNCTION_MASK \ function key maks
: HIDE-CONSOLE ( -- ) 
\ saveconx ?exit
\ getcolrow to savecony to saveconx
( SW_HIDE ) 
VALUE INDENT \ indent/outdent spaces
CONSTANT K-ALT-MASK \ alt key mask
CONSTANT K-ALT-MASK \ alt key mask
CONSTANT K-CTRL-MASK \ control key mask
CONSTANT K-CTRL-MASK \ control key mask
VALUE LEFT-MARGIN 
CONSTANT MENU_MASK \ menu operations
CONSTANT MOUSE_MASK \ mouse operations
: NORMAL-CONSOLE ( -- ) 
\ un-minimizes a minimized console window
( SW_NORMAL ) 
: PAGE ( -- ) 
\ skip to next page (PRINTER) clear screen (CONSOLE)
CONSTANT PROC_MASK \ procedure base mask
VALUE RIGHT-MARGIN 
: ROWS ( -- n1 ) 
\ current screen rows
: SET-CONPOS ( x y -- ) 
\ set the console position
: SHIFTMASK ( -- mask ) 
SYNONYM SHIFT_MASK K-SHIFT-MASK \ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ sound stuff
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
SYNONYM SHIFT_MASK K-SHIFT-MASK \ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ sound stuff
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
: SHOW-WINDOW ( n -- ) 
CONSTANT SPECIAL_MASK \ special keyboard key mask
: TAB ( -- ) 
VALUE TAB-MARGIN 
VALUE TAB-SIZE 
: TAB-WRAP? ( n1 -- f1 ) 
\ return true if column exceeds the maximum
\ desired tabs, or crosses into the right
\ margin area
SYNONYM TABBING-OFF tabing-off 
SYNONYM TABBING-OFF tabing-off 
SYNONYM TABBING-ON tabing-on 
SYNONYM TABBING-ON tabing-on 
VALUE TABING? \ are we tabing, default to no
VALUE TABS-MAX 
: TONE ( frequency duration-ms -- ) 
VARIABLE TONE_DURA 
VARIABLE TONE_FREQ 
: UNHIDE-CONSOLE ( -- ) 
\ saveconx 0= ?exit
( SW_SHOW ) 
: UNHIDE-CONSOLE ( -- ) 
\ saveconx 0= ?exit
( SW_SHOW ) 
CONSTANT UP_MASK \ mouse up mask
: WRAP? ( n1 -- f1 ) 
\ return true if column n1 crosses into the
\ right margin area
: _BEEP ( -- ) 
: (?WINERROR) ( f) 
\ show an error dialog box if f=FALSE/0
: (FORMATSYSTEMMESSAGE) ( error -- a n) 
: (GETLASTERROR) ( -- n) 
: (SETACTIVEWINDOW) ( hWnd -- ) 
\ Activate the window.
\ See full doc in method SetActiveWindow:
: (SETFOREGROUNDWINDOW) ( hwnd -- ) 
\ Put window as foreground
\ See full doc in method SetForegroundWindow:
: (SETWINDOW) { hWnd proc \ hActiveThreadID hLocalThreadID -- } 
: ?WINERROR ( f) 
DEFER ACTIVATE-CONSOLE ( -- ) 
DEFER AUTO_KEY 
DEFER AUTO_KEY? 
: CURSOR-OFF ( -- ) 
\ synonym for hide-cursor
: CURSOR-ON ( -- ) 
\ synonym for show-cursor
: DEFINEDABORT, \ compiles an ABORT" with the file name and line where defined
DEFER FOREGROUND-CONSOLE ( -- ) 
: FORTH-IO ( -- ) 
: HIDE-CURSOR ( -- ) 
DEFER MENUKEY-MORE 
VALUE MOUSEFLAGS 
VALUE MOUSEX 
VALUE MOUSEY 
: SHOW-CURSOR ( -- ) 
: _ACTIVATE-CONSOLE ( -- ) 
: _FOREGROUND-CONSOLE ( -- ) 
:OBJECT ABOUT-FORTH-DIALOG 
CREATE ABOUT-HEAD 
CREATE ABOUT-MSG1 
CREATE ABOUT-MSG2 
CREATE ABOUT-MSG3 
: ABOUT-WIN32FORTH ( -- ) 
:M CLASSINIT: ( -- ) 
LOAD-DIALOG FORTHDLG \ load the dialogs for Forth
:CLASS NEWEDITDIALOG 
:CLASS NEWEDITDIALOG 
:M ON_COMMAND: ( hCtrl code ID -- f1 ) 
\ returns 0=cancel,
\ returns 1=option-off
\ returns 2=option-on
:M ON_INIT: ( hWnd-focus -- f ) 
\ Setting the title must be handled specially, since the dialog itself isn't
\ considered to be a dialog item
INT OPTIONSTATE 
:OBJECT PAGE-UP-DIALOG 
: PAGE-UP-SETUP ( -- ) 
:M SETOPTIONSTATE: ( n -- ) 
:M START: ( counted_text_buffer parent -- f ) 
INT SZCANCEL 
INT SZDOIT 
INT SZOPTION 
INT SZPROMPT 
INT SZTEXT 
INT SZTITLE 
CONSTANT TEMPLATE 
CONSTANT TEMPLATE 
CONSTANT TEMPLATE 
VALUE &BINFO \ pointer to latest defined button
CREATE &BUTTONRECT 
CODE (OLD-WNDPROC) ( ^control -- old-wndproc ) 
\ address of old window prodedure
:M ADDSTYLE: ( n -- ) 
\ Set any additional style of the control. Must be done before the control
\ is started. Use +Style: to add to a running control.
:M AMFORGROUND?: ( -- f1 ) 
:M AUTOSIZE: ( -- ) 
\ Size the window to fit into the client area of the parent window.
BYTES BINFO 
:M BINFO: ( -- a1 ) 
\ return the counted string of button info
: BUTTONINFO" ( -- ) 
\ set the info for latest button or control
: CALLWINDOWPROC ( hwnd msg wparam lparam wndproc -- result ) 
:M CLASSINIT: ( -- ) 
: CLEAR-INFO ( -- ) 
|CLASS CONTROL 
|CLASS CONTROL 
: CREATE-CONTROL ( z"classname" -- ) 
:M CREATESTRUCT: ( -- CreateStrucPointer ) 
\ This pointer to a structure, depends on what kind of window you are
\ creating, so we just default it to NULL.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M EXWINDOWSTYLE: ( -- exstyle ) 
\ Get the extended window style of this control
:M GETAUTOCLOSE: ( -- flag ) 
:M GETHANDLEOFPARENT: ( -- handleofparent ) 
\ Get the window handle of the parent window of this control.
:M GETID: ( -- id ) 
\ Get the ID of this control
:M GETPARENT: ( -- parent ) 
\ Get the parent window of this control.
INT HANDLEOFPARENT \ the frame window handle
SHORT HORIZONTAL 
INT ID \ the control's ID
: IN-BUTTON? { x y hWnd -- f1 } 
VALUE INFO-FLAG \ are we displaying tool tips
CONSTANT INFO_CLOSE_TIMER \ timer constant
CONSTANT INFO_END_TIMER \ timer constant
CONSTANT INFO_START_TIMER \ timer constant
CONSTANT MAX-BINFO \ longest info message allowed
VALUE MOUSE-IS-DOWN? 
INT OLD-WNDPROC \ address of old window procedure
:M ON_MOUSEMOVE: ( h m w -- ) 
INT PARENT \ address of parent object
:M SETAUTOCLOSE: ( flag -- ) 
\ set the state of the automatic info close feature
:M SETID: ( id -- ) 
\ Set the ID of this control. Normaly you don't need to do this, because
\ every control get's an unique ID when it's created.
:M STARTPOS: ( -- left top ) 
\ Get the start position of this control. 
\ Override this method to change it.
:M STARTSIZE: ( -- width height ) 
\ Get the start size of this control. 
\ Override this method to change it.
INT STYLE 
: SUBCLASS ( -- ) 
CFA-CODE SUBCLASS-ENTRY ( lparam wparam message hwnd -- result ) 
NCODE SUBCLASS-RETURN 
DEFER SUBCLASS-WNDPROC 
INT TITLE \ the counted title string
:M TOOLSTRING: ( addr cnt -- ) 
: UNIQUE-ID ( -- id ) 
\ get a unique initial ID for this control
VALUE UNIQUE-ID# 
SHORT VERTICAL 
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of this control
:M WM_DESTROY 
:M WM_MOUSEMOVE { h m w l -- res } 
:M WM_TIMER ( h m w l -- res ) 
: _SUBCLASS-WNDPROC ( hwnd msg wparam lparam window -- res ) 
: ?PEXECUTE ( hwnd msg wparm lparm pfunction -- result ) 
:CLASS BUTTONCONTROL 
:CLASS BUTTONCONTROL 
INT BUTTONFUNC 
:CLASS CHECKCONTROL 
:CLASS CHECKCONTROL 
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:CLASS COMBOCONTROL 
:CLASS COMBOCONTROL 
EDITCONTROL COMBOEDIT 
:CLASS COMBOLISTCONTROL 
:CLASS COMBOLISTCONTROL 
:CLASS DIALOGWINDOW 
:CLASS DIALOGWINDOW 
:CLASS EDITCONTROL 
:CLASS EDITCONTROL 
:M GETCOUNT: ( -- n1 ) 
\ Use: GetCount: to get the count of items in the combo box string list.
:M GETSTRING: ( adr index -- ) 
\ Use: GetString: to get indexed items out of the combo box string list
\ Use: GetText: to get the current combo box string.
:CLASS GROUPCONTROL 
:CLASS GROUPCONTROL 
:M INSERTSTRING: ( adr len -- ) 
\ Insert a string into the combo box
:CLASS LISTCONTROL 
:CLASS LISTCONTROL 
INT PWMCHAR \ function returns '0' if it handled message, non-zero otherwise
INT PWMKEYDOWN \ function returns '0' if it handled message, non-zero otherwise
INT PWMKILLFOCUS \ function returns '0' if it handled message, non-zero otherwise
:CLASS RADIOCONTROL 
:CLASS RADIOCONTROL 
:M SETFUNC: ( cfa -- ) 
\ Set the button function. This function is executed when the
\ button is pressed with a click with the left mouse button
:M SETWMCHAR: ( pWmChar -- ) 
\ install the WM_CHAR filter function for the EditControl of the combo box.
:M SETWMCHAR: ( pWmChar -- ) 
\ Install the WM_CHAR filter function.
:M SETWMKEYDOWN: ( pWmKeyDown -- ) 
\ Install the WM_KEYDOWN filter function.
:M SETWMKEYDOWN: ( pWmKeyDown -- ) 
\ install the WM_KEYDOWN filter function for the EditControl of the combo box.
:M SETWMKILLFOCUS: ( pWmKillFocus -- ) 
\ install the WM_KILLFOCUS filter function for the EditControl of the combo box.
:M SETWMKILLFOCUS: ( pWmKillFocus -- ) 
\ Install the WM_KILLFOCUS filter function.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:M STARTSIZE: ( -- width height ) 
\ Get the start size of the control. Default size is 100 x 25.
:M STARTSIZE: ( -- width height ) 
\ Get the start size of the control
:CLASS STATICCONTROL 
:CLASS STATICCONTROL 
:M SUBCLASS: ( hWnd Parent -- ) 
\ Subclass this control.
:M WINDOWSTYLE: ( -- Style ) 
\ Get the window style of the control. The default style is: BS_GROUPBOX.
:M WINDOWSTYLE: ( -- Style ) 
\ Get the window style of the control. The default style is: WS_VSCROLL,
\ LBS_NOTIFY, LBS_NOINTEGRALHEIGHT and WS_TABSTOP.
:M WINDOWSTYLE: ( -- Style ) 
\ Get the window style of the control. The default style is: CBS_DROPDOWNLIST.
:M WINDOWSTYLE: ( -- Style ) 
\ Get the window style of the control. The default style is:
\ CBS_DROPDOWN, WS_VSCROLL, WS_TABSTOP, WS_VISIBLE and ES_AUTOHSCROLL.
:M WINDOWSTYLE: ( -- Style ) 
\ Get the window style of the control. Default style is:
\ WS_BORDER, WS_TABSTOP and ES_AUTOHSCROLL.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: BS_AUTORADIOBUTTON,
\ and WS_TABSTOP.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: BS_AUTOCHECKBOX,
\ and WS_TABSTOP.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: BS_PUSHBUTTON,
\ and WS_TABSTOP.
:M WM_CHAR ( h m w l -- res ) 
\ normal & control chars
:M WM_KEYDOWN ( h m w l -- res ) 
\ normal & control chars
:M WM_KILLFOCUS ( h m w l -- res ) 
\ Allow intervention on kill focus
:M WM_LBUTTONUP ( h m w l -- res ) 
:M WM_SETCURSOR { hndl msg wparam lparam -- res } 
:M ~: ( -- ) 
: ((CREATEPROCESS)) ( addr len -- flag ) 
\ create the process given as the first token in the "command line" addr/len . Flag true if failed
: CLOSEPROCESS ( -- ) 
\ close process handle of opened process
: CLOSETHREAD ( -- ) 
\ close thread handle of opened process
CREATE PROCESSCMD 
CREATE PROCINFO 
CREATE STARTUPINFO 
DEFER DOLOADINFO 
: SRCINFO, ( n1 -- ) 
\ compile a number into the info array
VALUE SRCINFOCNT \ count of cells in array
VALUE SRCINFOHERE 
POINTER SRCINFOPTR \ an array of information values
: _?UNSAVE-SRC ( -- ) 
: _RESETSRCINFO { ip@ -- } 
: _SAVE-SOURCE ( -- ) 
: _SAVE-SRC ( -- ) 
: BUF-EMIT ( c1 -- ) 
: BUF-TYPE ( a1 n1 -- ) 
: LOADINFO ( -<name>- ) 
VALUE PREV-RETURN 
: RST-EMIT ( c1 -- ) 
: RST-TYPE ( a1 n1 -- ) 
: SAVEINFO ( -<name>- ) 
\ save the debugger information to disk
CREATE SRCINFONAME 
: _DOLOADINFO { \ temp$ -- } 
\ load the debugger information from disk
: _STACK-WATCH { \ stack-cnt -- } 
\ send data and return stack to remote debugger (IDE) for display
: _WORD-WATCH { ip@ -- } 
\ send line & column position in source of token being debugged
\ sent to the IDE for highlighting the word in source
INT #PAGES 
VALUE #PAGES-UP 
: #PRINT-SCREEN ( start_line lines -- ) 
\ print a range of lines from saved
\ Forth screen buffer
VALUE #XINDENT \ nominal indentation of extended lines - rls
\ rls added constants and values:
: $FPRINT { the-name \ message$ fpr$ locHdl -- } 
: -BLSCAN1 ( a1 n1 -- a2 n2 ) 
\ rls - page
: 2PRINT ( -- ) 
: 4PRINT ( -- ) 
: >TAB ( -- ) 
\ TAB-SIZE is not right, but ok for now
:M ?CR: ( n1 -- ) 
: ?PAGE-STARTED ( -- ) 
VALUE ?TAB 
VALUE AUTO-ON? \ automatic printer initialization, no dialog
:M AUTOOPEN: ( -- f1 ) 
\ open the printer for use
:M BITBLT: ( blitmode sourcex,y sourcedc sizex,y destinationx,y -- ) 
BYTES BORDER-BUF 
VALUE BORDER? \ should a border be printed on each page
INT BORDERX 
INT BORDERY 
:M BRUSHCOLOR: { color_object -- } 
INT C-PAGE \ Put a border around the screen text
DEFER CALC_FONT_HEIGHT 
:M CIRCLE: { x y radius -- } 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLOSE: ( -- ) 
\ close the printer
: CONSOLE-FORTH-IO ( -- ) 
:M CR: ( -- ) 
INT CURRENTFONT 
: D-", ( a1 n1 -- ) 
\ compile a string
: D-, ( c1 -- ) 
\ compile a CELL
: D-C, ( c1 -- ) 
\ compile a BYTE
: D-W, ( w1 -- ) 
\ compile a WORD
:M DELETEOBJECT: ( object -- ) 
VALUE DIRECT-PRINT? 
:M DPI: ( -- horizontal-dots-per-inch  vertical-dots-per-inch ) 
\ LOGPIXELSX GetHandle: super Call GetDeviceCaps
\ LOGPIXELSY GetHandle: super Call GetDeviceCaps
: DRAW-BORDER { \ top left bottom right midwidth midheight foot1 foot2 head1 -- } 
INT DRAWING? 
:M DRAWINGOFF: ( -- ) 
INT DRAWLIST 
:M DRAWLISTCLOSE: ( -- ) 
:M DRAWLISTOPEN: ( -- ) 
: DRAWLIST_OVERFLOW? ( -- ) 
INT DRAWMAX 
INT DRAWOFF 
:M EMIT: ( c1 -- ) 
BYTES EMIT_BUFFER 
:M END: ( -- ) 
\ end current page and document
CONSTANT EXT-BORDER-D 
:M FILLAREA: { left top right bottom color_object -- } 
:M FILLCIRCLE: { x y radius -- } 
:M FILLRECT: { color_object rectangle -- } 
INT FIRST-PRINTED-PAGE 
INT FONT-HEIGHT 
: FOUR-PAGE ( -- ) 
: FPRINT ( -<name>- ) 
:M GETFONT: ( -- font_handle ) 
:M GETPIXEL: ( x y -- colorref ) 
\ returns a "COLORREF", not a color object
:M GETTEXTMETRICS: ( tm -- ) 
SYNONYM HDC hobject 
:M HEIGHT: ( -- vertical-dots-on-page ) 
\ VERTRES GetHandle: super Call GetDeviceCaps
FONT HFONT 
CONSTANT INT-BORDER-D 
INT INT-FONT 
:M LANDSCAPE: ( -- ) 
INT LAST-PRINTED-PAGE 
INT LASTCALL 
FONT LFONT 
:M LINECOLOR: { color_object -- } 
:M LPTPRINTERTEXTOUT: ( addr len -- ) 
INT MIDX 
INT MIDY 
:M MOVETO: ( x y -- ) 
VALUE MULTI-PAGE? \ multiple pages per page flag
:M NULLIFY: ( -- ) 
\ mark the printer hdc as not in use
INT OFFSETY 
:M OPEN2: ( bitmapped flags topage -- f1 ) 
\ open the printer for use
:M OPEN: ( -- f1 ) 
\ open the printer for use
: P-BEGINPATH ( a1 n1 -- a1 n1 ) 
: P-BEZIERTO ( a1 n1 -- a1 n1 ) 
\ only works RAW
: P-ENDPATH ( a1 n1 -- a1 n1 ) 
: P-FILLAREA ( a1 n1 -- a1 n1 ) 
: P-FILLPATH ( a1 n1 -- a1 n1 ) 
: P-LINECOLOR ( a1 n1 -- a1 n1 ) 
: P-LINETO ( a1 n1 -- a1 n1 ) 
: P-MOVETO ( a1 n1 -- a1 n1 ) 
: P-MPAGE ( -- ) 
: P-PAGE ( a1 n1 -- a1 n1 ) 
: P-SETPIXEL ( a1 n1 -- a1 n1 ) 
: P-STROKEANDFILL ( a1 n1 -- a1 n1 ) 
: P-STROKEPATH ( a1 n1 -- a1 n1 ) 
: P-TEXTOT ( a1 n1 -- a1 n1 ) 
\ horizontal text (normal)
: P-TEXTOTF ( a1 n1 -- a1 n1 ) 
\ font-specifed text out
: P-TEXTOTL ( a1 n1 -- a1 n1 ) 
\ line printer text
: P-TEXTOTR ( a1 n1 -- a1 n1 ) 
\ vertical text
INT PAGE# 
INT PAGE-ENDED? 
: PAGE-SCALED ( -- ) 
: PAGE-SETUP ( -- ) 
:M PAGE: ( -- ) 
\ start a new page
:M PENCOLOR: ( color_object -- ) 
INT PENWIDTH 
:M POLYDRAW: ( tptr pptr cnt -- ) 
\ is ROT right?!? I think it should be 3REVERSE (dbu)
:M PORTRAIT: ( -- ) 
: PORTRAIT? ( -- flag ) 
\ True if portrait mode
: PRINT ( -- ) 
: PRINT-CONSOLE ( -- ) 
\ print all lines used in screen save buffer
VALUE PRINT-EXTENDED-LINES 
: PRINT-MULTI-PAGE ( -- ) 
: PRINT-PAGE? ( -- f1 ) 
: PRINT-SCALED ( -- ) 
: PRINT-SCREEN ( -- ) 
\ print the physical screen
COLOROBJECT PRINTCOLOR 
: PRINTER ( -- ) 
VALUE PRINTER-#LINE \ lines output to the printer on this page
VALUE PRINTER-#OUT \ characters output on this line of printer
VALUE PRINTER-COLS \ columns on printer page
VALUE PRINTER-CPI \ characters per inch of the printer
VALUE PRINTER-HRES 
VALUE PRINTER-HSIZE 
VALUE PRINTER-LPI \ line per inch of the printer
VALUE PRINTER-MODE 
VALUE PRINTER-ROWS \ line per page of the printer
VALUE PRINTER-VRES 
VALUE PRINTER-VSIZE 
VALUE PRINTER? \ are we outputing to a line printer
:M PRINTERBEGINPATH: ( -- ) 
:M PRINTERBEZIERTO: ( addr cnt -- ) 
\ cnt is number of points
\ in the array at addr
:M PRINTEREND: ( -- ) 
:M PRINTERENDPATH: ( -- ) 
:M PRINTERFILLAREA: { left top right bottom color_object -- } 
:M PRINTERFILLPATH: ( -- ) 
:M PRINTERLINECOLOR: { color_object -- } 
:M PRINTERLINETO: ( x y -- ) 
:M PRINTERMOVETO: ( x y -- ) 
:M PRINTERMULTIPAGE: ( -- ) 
:M PRINTERPAGE: ( -- ) 
:M PRINTERROTATEDTEXTOUT: ( x y addr len -- ) 
:M PRINTERSETPIXEL: { xpos ypos color_object -- } 
:M PRINTERSTART: ( -- ) 
:M PRINTERSTROKEANDFILL: ( -- ) 
:M PRINTERSTROKEPATH: ( -- ) 
:M PRINTERTEXTOUT: ( x y addr len -- ) 
:M PRINTERTEXTOUTFONT: ( x y addr len font_object -- ) 
COLOROBJECT PRINTFILLCOLOR 
VALUE PRINTING? \ are we currently printing?
CONSTANT PR_RAW 
CONSTANT PR_SCALED 
:M PUTHANDLE: ( hdc -- ) 
\ dup to hDC
CONSTANT P_BEGINPATH 
CONSTANT P_BEZIERTO 
CONSTANT P_ENDPATH 
CONSTANT P_FILLAREA 
CONSTANT P_FILLPATH 
CONSTANT P_LINECOLOR 
CONSTANT P_LINETO 
CONSTANT P_MOVETO 
CONSTANT P_MPAGE 
CONSTANT P_PAGE 
CONSTANT P_SETPIXEL 
CONSTANT P_STROKEANDFILL 
CONSTANT P_STROKEPATH 
CONSTANT P_TEXTOT 
CONSTANT P_TEXTOTF 
CONSTANT P_TEXTOTL 
CONSTANT P_TEXTOTR 
:M REFFILLAREA: { left top right bottom colorref -- } 
:M REFLINECOLOR: ( colorref -- ) 
\ version for the printer, pen width two
:M RESTOREDC: ( -- ) 
\ restore current DC context including font
: ROWSTRING ( row -- a n ) 
\ address and length of row (without CR)
:M SAVEDC: ( -- ) 
\ Save current DC context and objects
INT SCALEX 
INT SCALEY 
VALUE SCREEN-HEIGHT \ Height of screen in bits
VALUE SCREEN-WIDTH \ Width of screen in bits
INT SEQUENTIAL-PAGES? 
:M SEQUENTIALSTATE: ( flag -- ) 
: SET-PRINT-PARAMS ( -- ) 
\ rls - many changes
: SET-PRINT-QUALITY 
: SET-ROWS-COLS ( -- ) 
\ rls - pages
:M SETBKCOLOR: { color_object -- } 
:M SETBKMODE: ( mode  -- ) 
:M SETFONT: ( font_handle -- ) 
:M SETPAGE: ( n1 -- ) 
\ set the page number of next page printed
:M SETPAGELIMITS: ( -- ) 
:M SETPIXEL: { x y color_object -- } 
:M SETPRINTERFONT: ( a1 n1 -- ) 
:M SETROP2: ( mode -- oldmode ) 
:M SETSTRETCHBLTMODE: ( mode_value -- ) 
:M SETTEXTCOLOR: { color_object -- } 
:M SETUP: ( window_handle -- ) 
: SINGLE-PAGE ( -- ) 
: SPLITLINE { a1 n1 \ a2 n2 n3 n4 -- a2 n2 indent a1 n1' } 
\ rls - page
: START-PRINTER ( -- f1 ) 
: START-PRINTER2 ( bitmapped flags topage -- f1 ) 
: START-RAW ( -- f1 ) 
: START-RAW2 ( bitmapped flags topage -- f1 ) 
\ rls February 5th, 2002 - 8:48
: START-SCALED ( -- f1 ) 
: START-SCALED2 ( bitmapped flags topage -- f1 ) 
:M START: ( -- ) 
\ start a new page and document
:M STRETCHBLT: ( blitmode srcsizex,y srcx,y srcdc dstsizex,y dstx,y -- ) 
CONSTANT STRING-MAX \ later 6 is added to this, and the sum
\ must be less than MAXCOUNTED
:M TABBEDTEXTOUT: ( x y addr len -- text_dimensions ) 
INT TALL? 
FONT TFONT 
WINPRINTER THEPRINTER 
: TWO-PAGE ( -- ) 
: TYPE1LINE { a1 n1 \ a2 n2 n3 -- a2 n2 n3 } 
\ rls - page
:M TYPE: { a1 n1 \ n2 -- } 
\ rls - page
BYTES USER-MESSAGE-BUF 
BYTES USER-TITLE-BUF 
:M USERMESSAGE: ( a1 n1 -- ) 
:M USERTITLE: ( a1 n1 -- ) 
FONT VFONT 
:M WIDTH: ( -- horizontal-dots-on-page ) 
\ HORZRES GetHandle: super Call GetDeviceCaps
:CLASS WINDC 
:CLASS WINDC 
:CLASS WINPRINTER 
:CLASS WINPRINTER 
: X-POSITION ( logicalx -- physicalx ) 
: XLCNT ( charcnt -- n ) 
\ Extended Line Count used for printing - rls - page
VALUE XLINECOUNT 
: Y-POSITION ( logicaly -- physicaly ) 
: _CALC_FONT_HEIGHT ( --- points_high ) 
: _NULLIFY-PRINTER ( -- ) 
\ mark printer as not used yet
: _P?CR ( n1 -- ) 
: _PCR ( -- ) 
: _PEMIT ( c1 -- ) 
: _PGETCOLROW ( -- cols rows ) 
: _PGETXY ( -- x y ) 
: _PGOTOXY ( x y -- ) 
: _PPAGE ( -- ) 
: _PRINTER-RELEASE ( -- ) 
\ release the printer DC if allocated
: _PTYPE ( a1 n1 -- ) 
: #DBG-RSTACK ( a1 a2 -- ) 
: #PATCHINTO ( a1 n1 -<name1 name2>- ) 
\ patch a1 into name1 at name2
DEFER $WATCH ( line filename -- ) 
: %. ( n -- ) 
: %.S ( ... -- ... ) 
: & ( n1 -- char n2 ) 
: &> 
: &S ( n1 -- c1 c2 ... 0 ) 
: &TYPE ( 0 c1 c2 ... -- ) 
VALUE 'TRACE \ address of the trace function
: (EXIT) ( ip 'ret -- ip' ) 
CODE +OV? ( n1 n2 -- f ) 
\ add two numbers and return true
: .DEBUG-TRACE ( ip cfa flag -- ip' cfa flag ) 
: .S-BASE ( -- ) 
NEW-CHAIN .WORD-TYPE-CHAIN ( cfa flag -- cfa false | true ) 
: .WORDTYPE ( -- ) 
: 0%.R ( n -- ) 
\ display signed right justified except in HEX,
\ then display unsigned
: <& ( n -- 0 n ) 
: <EXIT> ( ip -- ip' ) 
: <EXITM> ( ip -- ip' ) 
: <EXITP> ( ip -- ip' ) 
: <STRING> ( ip -- ip' ) 
VALUE ?CR-SAVE 
VALUE ?DBG-CONT \ are we stepping contiuously
: ?JUMP ( ip f -- ip' ) 
: ?UNBUG ( nfa -- nfa ) 
\ If word being debugged is being forgotten unbug
: ADEBUG ( cfa -- ) 
\ set a breakpoint at cfa from Forth interpreter
: BASE-TOGGLE ( -- ) 
: BP ( -<name>- ) 
\ synonym of DEBUG
#VOCABULARY BUG 
: CFA-WATCH ( cfa -- ) 
\ try to display the source for CFA
: CHR>ASC ( n -- char ) 
VALUE CLS-SAVE 
: CODE? ( cfa -- f ) 
: COLON? ( cfa -- f ) 
: CONSTANT? ( cfa -- f ) 
VALUE CR-SAVE 
: DBG ( -<name>- ) 
\ debug a word now
DEFER DBG-FSTACK 
: DBG-HELP ( -- ) 
: DBG-JUMP ( -- ) 
\ set breakpoint beyond following branch word
: DBG-NEST ( a1 -- ) 
NEW-CHAIN DBG-NEST-CHAIN ( i*x cfa flag --  i*x cfa false | true ) 
: DBG-NEXT ( -- ) 
NEW-CHAIN DBG-NEXT-CELL ( ip cfa -- ip' cfa ) 
\ this word is defered to later hook floating point stack - actually is defined before
: DBG-RSTACK ( -- ) 
: DBG-UNNEST ( -- ) 
\ not valid inside a loop or if >R has been used !
: DBG-WATCH ( -- ) 
: DEBUG ( -<name>- ) 
\ start the debugger to debug the word <name>
\ put any parameters needed by <name> before
DEFER DEBUG-.S 
VALUE DEBUG-BASE 
DEFER DEBUG-ENTRY 
DEFER DEBUG-EXIT 
: DEBUG-IO 
: DEBUG-IO ( -- ) 
: DEFER? ( cfa -- f ) 
: DO-WATCH ( -- ) 
VALUE EMIT-SAVE 
: EXECUTE? ( cfa -- f ) 
: F.S-DEBUG ( -- ) 
\ display the floating point stack while debugging
: FDBG ( - ) 
\ while debugging, use "F" command (do Forth command)
\ and execute this word to display floating stack
: FDEBUG ( -<name>- ) 
\ same as DEBUG but displays floating data stack
VALUE GETCOLROW-SAVE 
VALUE GETXY-SAVE 
VALUE GOTOXY-SAVE 
: H%. ( n -- ) 
CREATE HERE-SAVE 
VALUE IN-BREAKPOINT? 
VALUE INDENT-SAVE 
2VARIABLE IP \ ip & contents of current breakpoint
VARIABLE IP0 \ ip at start of word
VALUE KEY-SAVE 
VALUE KEY?-SAVE 
VALUE LEFT-MARGIN-SAVE 
: M0CFA? ( cfa -- f ) 
: M1CFA? ( cfa -- f ) 
VALUE MAX.RSTACK 
: NDBG ( - ) 
\ while debugging, use "F" command (do Forth command)
\ and execute this word to display data stack
VARIABLE NESTING \ nesting level
VALUE NEXTBREAK 
: OFFSET? ( cfa -- f ) 
: PATCH ( cfa -- ) 
: PATCHINTO ( a1 -<name1 name2>- ) 
\ Patch a1 into the definition name1
: PERFORM-WATCH ( -- ) 
CREATE POCKET-SAVE 
: REMOTE-DEBUG ( cfa -- flag ) 
\ set a breakpoint at cfa from remote editor
\ return flag : TRUE=success, FALSE=fail
VALUE REMOTE-DEBUG? 
: RESTORE-IO ( -- ) 
: RESTORE-IO 
VALUE RETURN-TOP 
VARIABLE RTOP \ top of return stack
: RUN-FORTH 
VALUE STACK-TOP 
DEFER STACK-WATCH ( -- ) 
VALUE START-WATCH? 
VALUE TABING?-SAVE 
CREATE TIB-SAVE 
: TRACE ( ? -- ) 
: TRACING ( cfa -- ) 
VALUE TYPE-SAVE 
: U%. ( u -- ) 
: UNBP ( -- ) 
\ synonym of UNBUG
: UNBUG ( -- ) 
\ terminates debugging
: UNNEST? ( cfa -- f ) 
: VARIABLE? ( cfa -- f ) 
: WATCH ( -<watch_command_line>- ) 
\ install a watch commandline
CREATE WATCH-BUF 
VALUE WATCHED-CFA 
: WITH-SOURCE ( -- ) 
: WITHOUT-SOURCE ( -- ) 
DEFER WORD-WATCH ( address -- ) 
VALUE X-SAVE 
VALUE Y-SAVE 
: _.RSTACK ( -- ) 
: _DBG-NEST ( cfa -- ) 
: (DIALOGPROC) ( hwnd msg wparam lparam -- res ) 
: ?DLGERR ( ior -- ) 
:M CLASSINIT: ( -- ) 
:CLASS DIALOG 
:CLASS DIALOG 
: DIALOGID? ( hdr ID -- f ) 
\ Given the address of a header in a resource file, return true if this
\ is the header for a dialog resource.  I'm only guessing here.
CALLBACK DIALOGPROC 
: END-DIALOG ( value -- flag ) 
:M ENDDIALOG: ( n1 -- ) 
\ Close the dialog
:M ENDDIALOG: ( return-value -- ) 
\ Close the dialog
:M EXWINDOWSTYLE: ( -- n1 ) 
\ Get the extended window style of the dialog.
: FIND-DIALOG-ID ( id addr -- address-of-template-header ) 
\ Find dialog template given address and length of resource file in memory.
INT HTEMPLATE 
: LOAD-DIALOG ( -<filename-without-an-extension>- ) 
\ Load template from dialog resource (*.res) to here and allot memory. 
\ Usage:  load-dialog dialog
{ \ ld-buf -- } 
:CLASS MODELESSDIALOG 
:CLASS MODELESSDIALOG 
:M ON_COMMAND: ( hCtrl code ID -- f ) 
\ Process Commands from Controls
:M ON_INIT: ( hwndfocus -- f ) 
\ Init the dialog
:M ORIGIN: ( -- x y ) 
\ Get the origin (upper left corner) of the dialog.
: READ-DIALOG ( name namelen -- ) 
: RUN-DIALOG { parent template \ tmplhndl -- f } 
: RUN-MODELESS-DIALOG { parent template \ tmplhndl -- hwnd tmplhndl } 
:M START: ( parent -- ) 
\ Open the dialog
:M START: ( parent -- flag ) 
\ Open the dialog
:M WINDOWSTYLE: ( -- n1 ) 
\ Get the window style of the dialog.
:M WM_CLOSE ( -- ) 
:M WM_COMMAND ( hwnd msg wparam lparam -- res ) 
:M WM_DESTROY ( -- result ) 
:M WM_INITDIALOG 
:M ~: ( -- ) 
: .# 
: ., ( -- ) 
\ delete the space before the comma
: .ALU ( n -- ) 
: .BTX(XXXN-NXXX) ( n -- ) 
: .CMP-SSE ( adr -- adr' ) 
: .CND-CODE(OP) ( code -- ) 
\ was tttn
: .CREG(XX-NNN-XXX) ( eee --  ) 
: .DISP16/32[PC++] ( adr -- adr' ) 
: .DISP16[PC++] ( adr -- adr' ) 
: .DISP32[PC++] ( adr -- adr' ) 
: .DISP8[PC++] ( adr -- adr' ) 
: .DREG(XX-NNN-XXX) ( eee --  ) 
: .IMM16/32[PC++] ( adr -- adr' ) 
: .IMM8[PC++] ( adr -- adr' ) 
: .JXX ( addr op -- addr' ) 
: .MREG(XX-XXX-NNN) ( n -- ) 
: .NAME>S ( xt -- ) 
: .PSX(XXNN-XXXX) ( op -- ) 
: .R>S ( n w -- ) 
: .REG(XX-XXX-NNN) ( a n -- a ) 
: .REG16(XX-XXX-NNN) ( n -- ) 
: .REG16/32(XX-XXX-NNN) ( n -- ) 
: .REG32(XX-XXX-NNN) ( n -- ) 
: .REG8(XX-XXX-NNN) ( n -- ) 
: .REL16/32 ( addr -- addr' ) 
: .REL8 ( addr -- addr' ) 
: .S" 
: .SHIFT ( n -- ) 
: .SIB=NN ( adr mod -- adr ) 
: .SOP" 
: .SREG(XX-NNN-XXX) ( sreg -- ) 
: .TREG(XX-NNN-XXX) ( eee --  ) 
: .XMMREG ( n -- ) 
: .[BASE16](XX-XXX-1NN) ( r/m -- ) 
: .[IND16](XX-XXX-0NN) ( r/m -- ) 
: .[INDEX]=SS-III-BBB ( sib -- ) 
: .[REG*2](XX-XXX-NNN) ( i -- ) 
: .[REG*4](XX-XXX-NNN) ( i -- ) 
: .[REG*8](XX-XXX-NNN) ( i -- ) 
: .[REG16](XX-XXX-NNN) ( r/m -- ) 
: .[REG32](XX-XXX-NNN) ( n -- ) 
: 0>S ( -- ) 
\ reset s-buf
: 0F-PREFIX? ( adr -- adr' flag ) 
: 0F. ( adr code -- ) 
: 8F. ( addr op -- addr' ) 
: ::IMM8 ( addr -- addr' ) 
: >S ( a1 n1 -- ) 
: >S8 
: ?.NAME>S { op-addr \ cfa -- } 
\ rbs - changed display format to addr and comment "( <NAME> @ <offset> )"
: ??? ( n1 -- ) 
: ?DIS-0F ( adr flag -- adr' flag ) 
: ?DIS-3AEXT ( adr -- adr' ) 
: ?DIS-660F ( adr flag -- adr' flag ) 
: ?DIS-F20F ( adr flag -- adr' flag ) 
: ?DIS-F30F ( adr flag -- adr' flag ) 
: ?SWAP-REGS 
: A16 ( adr code -- adr' ) 
INH AAA 
: AAD ( adr code -- adr' ) 
: AAM ( adr code -- adr' ) 
INH AAS 
: ADD ( adr op -- adr' ) 
: ADS ( adr op -- adr' ) 
: ALA ( adr op -- adr' ) 
: ALI ( adr op -- adr' ) 
: ALU ( adr op -- adr' ) 
: ARP ( addr op -- addr' ) 
: AUS ( adr op -- adr' ) 
: BND ( addr op -- addr' ) 
: BRA ( addr op -- addr' ) 
: BSF ( addr op -- addr' ) 
: BSP ( addr op -- addr' ) 
: BSR ( addr op -- addr' ) 
: BTX ( addr op -- addr' ) 
INH CDQ 
: CEQ ( adr op -- adr' ) 
: CGT ( adr op -- adr' ) 
: CIS ( addr op -- addr' ) 
INH CLC 
INH CLD 
INH CLI 
INH CLT 
INH CMC 
: CMV ( adr op -- ) 
CONSTANT COMMENT-COL \ Var/Values are all dis.<name> so it's easier to see that they aren't
\ functions.  Most display functions are preceded by DOT (for print).
\ Demultiplixing functions have a parameterlist as part of their name,
\ often signifying which bits are being used.
\ pseudo Object DIS for all the vars used by the disassembler
STR CPS 
INH CPU 
: CS: ( adr code -- adr' ) 
INH CWDE 
: CX8 ( addr op -- addr' ) 
: CXC ( addr op -- addr' ) 
: D.R>S ( d w -- ) 
: D16 ( adr code -- adr' ) 
INH DAA 
INH DAS 
: DEC ( addr op -- addr' ) 
: DEFAULT-16BIT ( -- ) 
: DEFAULT-32BIT ( -- ) 
: DIS ( adr -- ) 
: DIS-CMPPD ( adr -- adr' ) 
: DIS-CMPPS ( adr -- adr' ) 
: DIS-CMPSD ( adr -- adr' ) 
: DIS-CMPSS ( adr -- adr' ) 
: DIS-DB 
: DIS-DD 
: DIS-DS 
: DIS-DW 
: DIS-OP ( adr -- adr' ) 
VALUE DIS.16-BIT-ADDR 
VALUE DIS.16-BIT-DATA 
VALUE DIS.BASE-ADDR 
VALUE DIS.DEFAULT-16BIT? 
VALUE DIS.MEM? \ for suppressing comma after memory address
\ -----------------------------------------------------------------------
\ Disassembler utilities
\ -----------------------------------------------------------------------
VALUE DIS.MMX-REG? 
VALUE DIS.PREFIX-OP 
VALUE DIS.SIZE 
VOCABULARY DISASSEMBLER 
: DS: ( adr code -- adr' ) 
: EMIT>S ( c1 -- ) 
INH EMS 
: ENT ( addr op -- addr' ) 
: ES: ( adr code -- adr' ) 
: F6. ( addr op -- addr' ) 
\ ??
: FALU1 ( xopcode -- ) 
: FALU3 ( op -- ) 
: FALU5 ( xopcode -- ) 
: FALU6 ( op -- ) 
: FALU7 ( op -- ) 
: FCMOVA ( op -- ) 
: FCMOVB ( op -- ) 
: FD8 ( addr opcode -- addr' ) 
: FD9 ( addr op -- addr' ) 
: FDA ( addr op -- ) 
: FDB ( addr op -- addr' ) 
: FDC ( addr opcode -- addr' ) 
: FDD ( addr op -- addr' ) 
: FDE ( addr op -- addr' ) 
: FDF ( addr op -- addr' ) 
: FE. ( addr op -- addr' ) 
: FF. ( addr op -- addr' ) 
: FNULLARY ( op -- ) 
: FNULLARY-E ( op -- ) 
: FNULLARY-F ( op -- ) 
: FS: ( adr code -- adr' ) 
: FWAITOPS ( addr op -- addr' ) 
: GET-ADRFL ( flag adr adr'  -- adrfl flag ) 
: GP6 ( addr op -- addr' ) 
: GP7 ( addr op -- addr' ) 
: GP8 ( addr op -- addr' ) 
: GPA ( adr op -- adr' ) 
\ xx00-xxxx -> ???
: GS: ( adr code -- adr' ) 
: H.>S ( u -- ) 
: H.R>S ( n1 n2 -- ) 
INH HLT 
: IML ( addr op -- addr' ) 
INH INB 
: INC ( addr op -- addr' ) 
: IND ( addr code -- addr' ) 
: INH ( -<name>- ) 
: INP ( addr code -- addr' ) 
: INST ( adr -- adr' ) 
: INT ( addr op -- addr' ) 
INH INV 
INH IRT 
: ISD ( adr code -- adr' ) 
: JMP ( addr op -- addr' ) 
: JSR ( addr op -- addr' ) 
INH LAH 
: LAR ( addr op -- addr' ) 
: LBR ( addr op -- addr' ) 
STR LDS 
: LEA ( addr op -- addr' ) 
INH LEV 
: LFS ( addr op -- addr' ) 
: LGS ( addr op -- addr' ) 
: LOK ( adr code -- adr' ) 
\ This should have error checking added
: LSL ( addr op -- addr' ) 
: LSS ( addr op -- addr' ) 
: LUP ( addr op -- addr' ) 
: LXS ( addr op -- addr' ) 
: MAD ( adr op -- adr' ) 
: MCR ( addr op -- addr' ) 
: MDP ( adr op -- adr' ) 
: MDR ( addr op -- addr' ) 
: MLH ( adr op -- adr' ) 
: MLI ( addr op -- addr' ) 
: MLL ( adr op -- adr' ) 
VALUE MMX-REG 
: MMX-SIZE ( op -- ) 
: MOD-R/M ( addr modr/m -- addr' ) 
: MOD-R/M(MODR/M) ( adr modr/m -- adr' ) 
: MOD-R/M16(R/M,MOD) ( adr r/m mod -- adr' ) 
: MOD-R/M32(R/M,MOD) ( adr r/m mod -- adr' ) 
: MODBYTE ( mod-r-r/m -- r/m r mod ) 
( r including general, special, segment, MMX ) 
( mod-op-r/m -- r/m op mod ) 
: MOV ( addr op -- addr' ) 
: MPD ( adr op -- adr' ) 
: MPQ ( adr op -- adr' ) 
: MQP ( adr op -- adr' ) 
: MRC ( addr op -- addr' ) 
: MRD ( addr op -- addr' ) 
: MRI ( addr op -- addr' ) 
( mov register, imm ) 
: MRS ( addr op -- addr' ) 
\ ? remove redundant >r , r>
: MRT ( addr op -- addr' ) 
\ obsolete
: MSR ( addr op -- addr' ) 
: MTR ( addr op -- addr' ) 
\ obsolete
: MV1 ( addr op -- addr' ) 
: MV2 ( addr op -- addr' ) 
: MVI ( adr op -- adr' ) 
( mov mem, imm ) 
STR MVS 
: MVX { addr op \ op2 -- addr' } 
VALUE NEXT-INST 
: NEXT? ( a1 -- f1 ) 
: NT3 ( addr op -- addr' ) 
INH NTO 
CREATE OP1-TABLE \ 0   1   2   3    4   5   6   7    8   9   A   B    C   D   E   F
CREATE OP2-TABLE2 \ 0   1   2   3    4   5   6   7    8   9   A   B    C   D   E   F
CONSTANT OPCFIELD \ --------------------- MMX Operations -----------------
: OPS 
INH OSB 
: OSD ( adr code -- adr' ) 
: OTD ( addr code -- addr' ) 
: OTP ( addr code -- addr' ) 
: PAD ( adr op -- adr' ) 
: PAN ( adr op -- adr' ) 
: PARSE/MODR/M ( mod-r-r/m -- 3bits=r/m 3bits=r/op 2bits=mod ) 
\ r/op includes general, special, segment, MMX registers or extended opcode
: PARSE/SIB ( ss-iii-bbb -- bbb iii ss ) 
\ r including general, special, segment, MMX
: PF-CODED? ( adr -- adr' flag ) 
: POP ( addr op -- addr' ) 
: POR ( adr op -- adr' ) 
: PPA ( addr op -- addr' ) 
: PPF ( addr op -- addr' ) 
: PPS ( addr op -- addr' ) 
: PREFIX-CODED? ( adr -- adr' flag ) 
: PSA ( addr op -- addr' ) 
: PSB ( adr op -- adr' ) 
: PSF ( addr op -- addr' ) 
: PSH ( addr op -- addr' ) 
: PSI ( addr op -- addr' ) 
: PSS ( addr op -- addr' ) 
: PSW ( adr op -- adr' ) 
: PUW ( adr op -- adr' ) 
: PXR ( adr op -- adr' ) 
: R,R/M ( adr -- adr' ) 
: R,R/M() ( adr -- adr' ) 
: R,XMM ( addr -- addr' ) 
\ 1st=r32 2nd=XMM
: R/M() ( adr op -- adr' ) 
: R/M,R() ( adr -- adr' ) 
: R/M16(MODR/M) ( adr modr/m -- adr' ) 
: R/M16/32(MODR/M) ( adr modr/m -- adr' ) 
: R/M8(MODR/M) ( adr modr/m -- adr' ) 
: R32/M,XMMR ( addr -- addr' ) 
\ the register is always XMM
: R:REG ( a n -- a ) 
: R:SSE2 ( -- ) 
: REP ( adr code -- adr' ) 
: REST 
: REST { adr \ sv1 sv2 -- } 
: RESTORE-ADR ( true adr adr1 --  false adr adr adr ) 
INH RMR 
INH RPC 
: RPZ ( adr code -- adr' ) 
INH RSM 
: RSTAB ( -- ) 
INH RTC 
: RTF ( addr op -- addr' ) 
: RTN ( addr op -- addr' ) 
CREATE S-BUF 
: S> ( -- a1 n1 ) 
INH SAH 
: SAVE-ADR ( adr flag -- flag adr adr  ) 
: SBS ( adr op -- adr' ) 
STR SCS 
: SEEMORE ( -- ) 
: SET ( adr op -- ) 
: SEXT ( byte -- n ) 
: SHF ( addr op -- addr' ) 
DEFER SHOW-NAME ( cfa -- ) 
\ display nearest symbol
: SHOW-NEXT-OFF ( -- ) 
: SHOW-NEXT-ON ( -- ) 
VALUE SHOW-NEXT? \ default to not showing next instructions
: SHX ( adr op -- adr' ) 
\ xx00-xxxx -> ???
: SLC ( addr op -- addr' ) 
: SLI ( addr op -- addr' ) 
: SRC ( addr op -- addr' ) 
: SRI ( addr op -- addr' ) 
: SS. ( n adr len w ) 
: SS: ( adr code -- adr' ) 
: SSPACE ( -- ) 
: SSPACES ( n1 -- ) 
: STAB ( pos - ) 
INH STC 
INH STD 
INH STI 
: STI. ( op -- ) 
: STR 
STR STS 
: SUB ( adr op -- adr' ) 
: SUS ( adr op -- adr' ) 
: SWAP-REGS ( u1 -- u2 ) 
: TST ( addr op -- addr' ) 
: TXB ( addr op -- addr' ) 
: U.R>S ( u w -- ) 
INH UD1 
INH UD2 
: UPH ( adr op -- adr' ) 
: UPL ( adr op -- adr' ) 
: W8F ( addr op -- addr' ) 
: WF1 ( addr -- addr' ) 
: WF2 ( addr -- addr' ) 
: WF3 ( addr -- addr' ) 
: WF4 ( addr -- addr' ) 
INH WIV 
INH WMR 
: XAD ( addr op -- addr' ) 
: XGA ( addr op -- addr' ) 
\ .s" xchg     eax, " .reg16/32(XX-XXX-NNN)
\ -rbs July 7th, 2002
INH XLT 
: XM-R,R/M ( addr -- addr' ) 
: XM-R/M,R ( addr -- addr' ) 
VALUE XMM-REG \ For a 32-bit environment
: XMMR,R32/M ( addr -- addr' ) 
\ dest register is XMM
: .1THREAD { voc-thread \ thread-depth -- } 
: .COUNTS { \ #thread-over -- } 
: .THREAD ( n1 -- ) 
\ display a thread of context vocabulary
: .THREADS ( -- ) 
: 1TCOUNT { voc-thread \ thread-depth -- n1 } 
\ get thread depth of voc thread
VALUE APP-CNT \ count of application dictionary words
: COUNT-VOC ( voc -- ) 
: COUNT-WORDS ( -- n1 ) 
VALUE HEADER-CNT 
VALUE WORDS-CNT 
: $BROWSE ( line filename | dummy -1 -- ) 
\ W32F
\ Open the file, filename in the editor at line, in browse mode.
: $EDIT ( line filename | dummy -1 -- ) 
\ W32F
\ Open the file, filename in the editor at line, in edit mode.
: $LOCATE ( line# filename | dummy -1 -- ) 
{ line# file$ \ loc$ locHdl lcnt -- } 
ANEW -EDITOR_IO.F \ ----------------------------------------------------------------------------------------
\ Communication beetween the Editor (e.g. the Win32ForthIDE) and the Console window.
\ ----------------------------------------------------------------------------------------
: .V \ synonym of WHERE
: AUTOEDITOFF ( -- ) 
\ disable automatic edit on error
: AUTOEDITON ( -- ) 
\ link into deferred auto edit on error word
: BROWSE ( -<filename>- ) 
\ BROWSE a particular file
: DB-PUSHKEY ( c1 -- ) 
\ Push a key to the console window during debugging.
: DO-BROWSE ( -- ) 
: DO-EDIT ( -- ) 
: DO-INQUIRE { addr -- } 
\ Respond to an inquiry from the editor : addr contain vars to EVALUATE
\ and a WM_RESPONSE message (vars contents) is sent back
: DO-LINE-FILE ( -- addr len ) 
: DO-SET-BREAKPOINT { addr \ bp$ ed-name -- result } 
\ Set breakpoint to a word from editor (eg: win32ForthIDE)
\ Result : 0=failure  -1=ok
: DO-WATCH ( -- ) 
: ED ( -<name>- ) 
\ EDIT the source for a word
: EDIT ( -<filename>- ) 
\ EDIT a particular file
: EDITOR-PRESENT? ( -- flag ) 
\ true flag if editor is present (running)
: L \ synonym of locate
: LINELIST ( n1 -- ) 
: LL \ synonym of locate
: LOCATE ( -<name>- ) 
\ show some source lines of word
: LOCATE-HEADER ( -- n1 ) 
: LOCATE-HEIGHT ( -- n1 ) 
CREATE MSGPAD 
: N ( -- ) 
\ show the next bunch of lines
DEFER PASTE-LOAD 
: V \ synonym of VIEW
: VIEW ( -<name>- ) 
\ VIEW the source for a word
: VV \ synonym of VIEW
: WHERE ( -<name>- ) 
\ tell me WHERE the source for a word is
: Z \ synonym of EDIT
: [$EDIT] { line_number file_name edit_cfa -- } 
\ works with blanks in filename
: _$WATCH ( line filename -- ) 
: _EDIT-ERROR ( -- ) 
CONSTANT #LOCALS 
CONSTANT /COUNTED-STRING 
CONSTANT /HOLD 
CONSTANT /PAD 
CONSTANT ADDRESS-UNIT-BITS 
CONSTANT CORE 
CONSTANT CORE-EXT 
CONSTANT DOUBLE 
CONSTANT DOUBLE-EXT 
#VOCABULARY ENVIRONMENT 
: ENVIRONMENT? ( a1 n1 -- false | ?? true ) 
CONSTANT EXCEPTION 
CONSTANT EXCEPTION-EXT 
CONSTANT FACILITY 
CONSTANT FACILITY-EXT 
CONSTANT FILE 
CONSTANT FILE-EXT 
CONSTANT FLOATING 
CONSTANT FLOATING-EXT 
CONSTANT FLOATING-STACK 
CONSTANT FLOORED 
CONSTANT LOCALS 
CONSTANT LOCALS-EXT 
CONSTANT MAX-CHAR 
2CONSTANT MAX-D 
FCONSTANT MAX-FLOAT 
CONSTANT MAX-N 
CONSTANT MAX-U 
2CONSTANT MAX-UD 
CONSTANT MEMORY-ALLOC 
CONSTANT MEMORY-ALLOC-EXT 
CONSTANT RETURN-STACK-CELLS 
CONSTANT SEARCH-ORDER 
CONSTANT SEARCH-ORDER-EXT 
CONSTANT STACK-CELLS 
CONSTANT STRING 
CONSTANT STRING-EXT 
CONSTANT TOOLS 
CONSTANT TOOLS-EXT 
CONSTANT WIN32FORTH \ Added Wednesday, September 27 2006 to support Forth 200x extensions. gah
CONSTANT WORDLISTS 
: X:DEFERRED 
: X:DEFINED 
: X:EXTENSION-QUERY 
: X:NUMBER-PREFIX 
: X:PARSE-NAME 
: X:REQUIRED 
CALLBACK &IN-EXCEPT 
NEWUSER (?EXCEPTIONING) 
: (EXCEPT-IO) 
: .EXCEPTION ( -- ) 
\ print exception info
: .EXCEPTION-CODE ( -- ) 
\ get the last exception
: .EXNAME ( addr -- ) 
\ only available in non-turnkeyed apps
: .EXREGS ( n -- ) 
: ?EXCEPTIONING ( -- f ) 
: ALLOCATE-EXCEPT-BUFFER ( -- ) 
: CLEAR-EXCEPTION ( -- ) 
\ clear any previous exception
: CONTEXT-BUFFER ( -- a1 ) 
\ return the address of the
CONSTANT CONTEXTRECLEN 
FIELD+ CONTEXTRECOFFSET 
FIELD+ EAX 
FIELD+ EBP 
: EBP@SAVE-BUFFER ( -- a1 ) 
\ return the address of the
FIELD+ EBP@SAVEOFFSET 
FIELD+ EBX 
FIELD+ ECX 
FIELD+ EDI 
FIELD+ EDX 
FIELD+ EIP 
FIELD+ ESI 
FIELD+ ESP 
: EXCEPT-BUFFER ( -- a1 ) 
\ return the address of the
DEFER EXCEPT-IO \ where print exception goes
: EXCEPT-PRESSKEY ( -- ) 
: EXCEPT-RSTACK ( a1 -- ) 
: EXCEPT-SSTACK ( a1 -- ) 
\ print off the return stack
CONSTANT EXCEPTBUFFLEN 
FIELD+ EXCEPTHANDLER 
FIELD+ EXCEPTIONADDRESS 
FIELD+ EXCEPTIONCODE 
FIELD+ EXCEPTIONFLAGS 
FIELD+ EXCEPTIONNUMPARMS 
FIELD+ EXCEPTIONPARMS 
CONSTANT EXCEPTIONRECLEN 
FIELD+ EXCEPTIONRECORD 
CONSTANT EXCEPTION_CONTINUE_EXECUTION 
CONSTANT EXCEPTION_CONTINUE_SEARCH \ windows
CONSTANT EXCEPTION_EXECUTE_HANDLER \ no longer in wincon.dll, now macros in
FIELD+ EXCEPTRECOFFSET 
: HANDLE-EXCEPT ( ex-ptr -- ropt ) 
\ Error routine called by OS, save & setup
: INIT-EXCEPT-USERS ( -- ) 
: RECOVER-EXCEPT ( con-ptr -- n ) 
\ recovery handler, modify registers for retry
NEWUSER RECOVER-EXCEPTION \ recover from exception?
: RELEASE-EXCEPT-BUFFER ( -- ) 
FIELD+ RP@STACKSAVEOFFSET 
: SET-EXCEPT ( -- ) 
\ set exception routine handler
NEWUSER SHOW-EXCEPTION \ show exception?
FIELD+ SP@STACKSAVEOFFSET 
CONSTANT THROW_WINEXCEPT \ " Windows exception trapped"
: UNSET-EXCEPT ( prev-except-addr -- ) 
\ unset exception routine
: UPSAVE-BUFFER ( -- a1 ) 
\ return the address of the
FIELD+ UPSAVEOFFSET 
CFA-FUNC #FLOAT! 
CFA-FUNC #FLOAT+! 
: #FLOAT-ARRAY ( n1 "name" -- ) 
\ compile time          64-bits
( n1 -- ; fs: -- r ) 
\ runtime
: #FLOAT? ( a1 -- a1 f1 ) 
\ is a1 the CFA of a #float? or #^float?
CFA-FUNC #FLOAT@ 
: #^FLOAT-ARRAY ( n1 "name" -- ) 
\ compile time          64-bits
( n1 -- ; fs: -- r ) 
\ runtime
NEWUSER $FSIGNIF 
NEWUSER $FTEMP 
VALUE &FLIT 
MACRO: (>FPU) 
: (E.) \ synonym of (FS.)
\ See above.
: (F.) ( addr -- ; fs: r -- ) 
\ W32F         Floating extra
\ Format the top number on the floating-point stack using fixed-point notation:
\        [-] <digits>.<digits0>
{ $buf -- } 
MACRO: (FCOMP) 
CODE (FCOS) ( fs: r1 -- r2 ) 
: (FE.) ( addr -- ; fs: r -- ) 
\ W32F        Floating extra
\ Format r as a string in engineering notation.
{ $buf \ -- } 
: (FP.) ( xt  -- ; fs: r -- ) 
\ display fp #
{ \ $buf -- } 
MACRO: (FPU>) 
MACRO: (FROUND) 
: (FS.) ( addr -- ; fs: r -- ) 
\ W32F        Floating extra
\ Format r as a string in scientific notation:
\        <significand><exponent>
\ where:
\        <significand>  :=  [-]<digit>.<digits0>
\        <exponent>     :=  E[-]<digits>
{ $buf \ -- } 
CODE (FSIN) ( fs: r1 -- r2 ) 
CODE (FSINCOS) ( fs: r1 -- r2 r3 ) 
: (FSINH) ( fs: r1 -- r2 ) 
\ hyperbolic sine, more accurate for positive.
: (F~) ( -- f ; fs: r1 r2 r3 -- ) 
: (G.) ( addr -- ; fs: r -- ) 
\ W32F           Floating extra
\ Format r as a string using scientific notation or ordinary representation according
\ to the size of r.
: (S.) ( n addr len w -- addr w ) 
: (TAG) ( n1 addr -- n2 ) 
\ Returns the 2 bit tag for ST(n1)
MACRO: +FSP-ADJUST 
MACRO: +FSTACK_MEMORY ( n -- ) 
: +REPRESENT { $buf -- true | exp sign false ; fs: r -- } 
: +SIGN ( $buf -- ) 
MACRO: -FSP-ADJUST 
: .FDEPTH ( -- ) 
\ W32F          Floating debug
\ Display depth of floating point stack.
DEFER .FLOAT 
: .FMASK ( n -- ) 
: .FSTATUS ( n -- ) 
: .FTAG1 ( n -- ) 
: .FTAG2 ( i -- ) 
: .FTEMPX ( -- ) 
: .ONEFLOAT ( -- r1 ) 
: .TENBYTE ( addr -- ) 
\ Needs lots of work yet.
: 1/F ( fs: r1 -- r2 ) 
\ W32F        Floating extra
\ r2 is the reciprocal of r1.
: 10**N ( fs: -- r ) 
( n -- ) 
\ 10 raised to n
: 10**N*F ( n -- ; fs: f1 -- f2 ) 
\ (10 raised to n) * f1
: 10**N-0.5 ( fs: -- r ) 
( n -- ) 
\ (10 raised to n) - 0.5
: 10DIGIT ( char -- n flag ) 
MACRO: 2>FPU 
: >A2**63_FREM2PI ( fs: r1 -- r2 ) 
: >FLOAT ( addr len -- f ; fs: -- r | <nothing> ) 
\ ANSI           Floating
\ An attempt is made to convert the string specified by c-addr and u to internal
\ floating-point representation. If the string represents a valid floating-point
\ number in the syntax below, its value r and true are returned. If the string does not
\ represent a valid floating-point number only false is returned. 
\ 
\ A string of blanks is treated as a special case representing zero.
\ The syntax of a convertible string := <significand>[<exponent>]
\ 
\ <significand> := [<sign>]{<digits>[.<digits0>] |
\ .<digits> }
\ <exponent>    := <marker><digits0>
\ <marker>      := {<e-form> | <sign-form>}
\ <e-form>      := <e-char>[<sign-form>]
\ <sign-form>   := { + | - }
\ <e-char>      := { D | d | E | e }
: >FLOAT-INT ( fs: -- r ) 
: >FLOAT-INT.FRAC ( fs: -- r ) 
CODE >FPCW ( n -- ) 
\ W32F        Floating extra
\ Set x87 FPU Control Word.
MACRO: >FPU 
CODE >FREGS ( addr -- ) 
\ W32F         Floating extra
\ Restore x87 FPU State.
CODE >FREGS> ( addr -- ) 
\ W32F        Floating extra
\ Save and Restore x87 FPU State.
: ?#FLOAT ( cfa -- cfa ) 
\ abort if not a #FLOAT-ARRAY
: ?FLOAT ( cfa -- cfa ) 
\ abort if not a FLOAT
FVARIABLE A2**63 ( -- addr ) 
\ W32F             Floating extra
\ Return the address of a float containing 2**63.
CREATE ALLREGS 
: BCD-CHAR! ( char n -- ) 
: BCD-CHAR@ ( n -- char ) 
CONSTANT BIG-POWER 
VALUE CELLS/FLOAT \ Number of cells in a floating-point number. If the number of bytes is not a multiple
\ of 4 this is rounded up.
NEWUSER CHARCNT 
CODE D>F ( d -- ; Fs: -- r ) 
\ ANSI           Floating
\ Convert double number to floating-point number.
MACRO: DATASTACK_MEMORY ( -- ) 
CODE DF! ( addr -- ; fs: r -- ) 
\ ANSI        Floating ext
\ Store a 64 bit (double) float.
CODE DF@ ( addr -- ; fs: -- r ) 
\ ANSI       Floating ext
\ Fetch a 64 bit (double) float.
: DFALIGN ( -- ) 
: DFALIGNED ( addr -- addr ) 
: DFIELD: ( n1 "name" -- n2 ) 
( addr -- 'addr ) 
\ Skip leading space delimiters. Parse name delimited by a space. Offset is the first
\ double-float aligned value greater than or equal to n1. n2 = offset + 1 double-float.
\ Create a definition for name with the execution semantics given below.
\ name Execution: ( addr1 -- addr2 )
\ Add the offset calculated during the compile time action to addr1 giving the
\ double-float aligned address addr2.
OFFSET DFLOAT+ ( addr1 -- addr2 ) 
: DFLOATS ( n1 -- n2 ) 
: DIGIT0 ( char -- flag ) 
CFA-CODE DOFVALUE ( fs: -- r ) 
CFA-CODE DOFVALUE! ( fs: r -- ) 
CFA-CODE DOFVALUE+! ( fs: r -- ) 
: E-CHAR ( char -- true | char false ) 
: E. \ Synonym of FS.
\ See above.
CODE F! ( addr -- ; fs: r -- ) 
\ ANSI        Floating
\ Store a float.
: F# ( Interpretation: "fp no." -- ; fs: -- r ) 
\ W32F             Floating extra
\  ( Compilation: "fp no." -- ; run-time: fs: -- r ) 
\ An attempt is made to convert the space delimited string following F# to internal
\ floating-point representation. If the string represents a valid floating-point
\ number in the syntax below, its value r is returned. If the string does not
\ represent a valid floating-point number an error is thrown. 
\ F# used at the end of a line is treated as a special case representing zero. 
\ If interpreting the FP number is placed on the FP stack, while it is compiled as
\ an Fliteral if compiling. 
\ The syntax of a convertible string is the same as  >FLOAT .
: F#+> ( n1 "name" -- ) 
\ increment the value of a float
: F#-> ( n1 "name" -- ) 
\ store a value into a float
CODE F* ( fs: r1 r2 -- r3 ) 
\ ANSI          Floating
\ Multiply r1 by r2.
: F** ( fs: r1 r2 -- r3 ) 
\ ANSI            Floating ext
\ Raise r1 to the power r2, giving the product r3.
CODE F**+N ( n -- ; fs: r1 -- r2 ) 
\ r2 is r1 to the power n, where n is positve.
: F**N ( n -- ; fs: r1 -- r2 ) 
\ r2 is r1 to the power n.
: F*10**N ( n -- ; fs: f1 -- f2 ) 
CODE F+ ( fs: r1 r2 -- r3 ) 
\ ANSI          Floating
\ Add r1 to r2.
CODE F+! ( addr -- ; fs: r -- ) 
\ W32F       Floating extra
\ Add the value to a float.
: F+> ( n1 "name" -- ) 
\ increment the value of a float
: F, ( fs: r -- ) 
\ W32F        Floating extra
\ Compile a float into the dictionary.
CODE F- ( fs: r1 r2 -- r3 ) 
\ ANSI          Floating
\ Subtract r2 from r1.
: F-> ( n1 "name" -- ) 
\ store a value into a float
: F. ( fs: r -- ) 
\ ANSI            Floating ext
\ Display, with a trailing space, the top number on the floating-point stack using
\ fixed-point notation:
\        [-] <digits>.<digits0>
: F.S ( -- ) 
\ W32F          Floating debug
\ Display floating point stack.
: F.X ( fs: r1 r2 ... rn -- r1 r2 ... rn ) 
\ Hex dump of fstack
CODE F/ ( fs: r1 r2 -- r3 ) 
\ ANSI         Floating
\ Divide r1 by r2.
CODE F0.0 ( fs: -- r ) 
\ W32F          Floating extra
\ Push plus zero on to the FP stack.
FCONSTANT F0.5 ( fs: -- r ) 
: F0< ( -- f ; fs: r -- ) 
\ ANSI           Floating
\ Return true if r is less than 0e0. Returns false for NAN.
: F0<> 
: F0= ( -- f ; fs: r -- ) 
\ ANSI           Floating
\ Return true if r equals 0e0. Returns false for NAN.
: F0> ( -- f ; fs: r -- ) 
\ W32F           Floating extra
\ Return true if r is greater than 0e0. Returns false for NAN.
CODE F1.0 ( fs: -- r ) 
\ W32F          Floating extra
\ Push the value 1.0 on to the FP stack.
FCONSTANT F10.0 ( fs: -- r ) 
CODE F2* ( fs: r1 -- r2 ) 
\ W32F        Floating extra
\ Multiply by 2.
FCONSTANT F2.0 ( fs: -- r ) 
CODE F2/ ( fs: r1 -- r2 ) 
\ W32F        Floating extra
\ Divide by 2.
CODE F2DROP ( fs: r1 r2 -- ) 
\ W32F          Floating extra
\ Remove the top 2 FP stack entries.
: F2DUP ( fs: r1 r2 -- r1 r2 r1 r2 ) 
\ W32F          Floating extra
\ Duplicate the top 2 FP stack entries.
: F2NIP ( fs: r1 r2 r3 r4 -- r3 r4 ) 
\ W32F          Floating extra
\ Remove the 2nd pair of FP stack entries.
FCONSTANT F2PI 
: F2SWAP ( fs: r1 r2 r3 r4 -- r3 r4 r1 r2 ) 
\ W32F     Floating extra
\ Swap the top pair of floating-point numbers with the second pair.
{ \ ftemp -- } 
: F< ( -- f ; fs: r1 r2 -- ) 
\ ANSI           Floating
\ Return true if r1 is less than r2. Returns false if either number is a NAN.
: F<= ( -- f ; fs: r1 r2 -- ) 
\ W32F           Floating extra
\ Return true if r1 is less than or equal to r2. Returns true if either number
\ is a NAN.
: F= ( -- f ; fs: r1 r2 -- ) 
\ W32F           Floating extra
\ Return true if r1 equals r2. Returns false if either number is a NAN.
: F> ( -- f ; fs: r1 r2 -- ) 
\ W32F           Floating extra
\ Return true if r1 is greater than r2. Returns false if either number is a NAN.
: F>= ( -- f ; fs: r1 r2 -- ) 
\ W32F           Floating extra
\ Return true if r1 is greater than or equal to r2. Returns true if either number
\ is a NAN.
CODE F>BCD ( addr -- ; fs: r -- ) 
CODE F>D ( -- d ; fs: r -- ) 
\ ANSI           Floating
\ Convert floating-point number to double number, by rounding towards zero. If the
\  result would be too large to fit in a double number then  -9223372036854775808
\ is returned.
: F>S ( -- n ; fs: r -- ) 
\ W32F           Floating extra
\ Convert the floating point number r to single number n.
CODE F@ ( addr -- ; fs: -- r ) 
\ ANSI      Floating
\ Fetch a float.
CODE FABS ( fs: r1 -- r2 ) 
\ ANSI        Floating ext
\ r2 is the absolute value of r1.
CODE FACOS ( fs: r1 -- r2 ) 
\ ANSI         Floating ext
\ r2 is the radian angle whose cosine is r1. The result for |x| =< 1 is between 0 and pi.
\ The result for |x| > 1 is NAN
CODE FACOSH ( fs: r1 -- r2 ) 
\ ANSI            Floating ext
\ r2 is the number whose hyperbolic cosine is r1. If r1 < 1.0 then r2 is a NAN.
: FALIGN ( -- ) 
: FALIGNED ( addr -- addr ) 
: FALOG ( fs: r1 -- r2 ) 
\ ANSI           Floating ext
\ Raise ten to the power r1, giving r2.
CODE FASIN ( fs: r1 -- r2 ) 
\ ANSI         Floating ext
\ r2 is the radian angle whose sine is r1. The result for |x| =< 1 is between pi/2.
\ The result for |x| > 1 is NAN.
CODE FASINH ( fs: r1 -- r2 ) 
\ ANSI             Floating ext
\ r2 is the number whose hyperbolic sine is r1.
CODE FATAN ( fs: r1 -- r2 ) 
\ ANSI          Floating ext
\ r2 is the radian angle whose tangent is r1. The result is between pi/2.
CODE FATAN2 ( fs: r1 r2 -- r3 ) 
\ ANSI         Floating ext
\ r3 is the radian angle whose tangent is r1/r2. The result is between pi
\ with the same sign as r2. If r1 and r2 are both zero then r3 is zero.
\ This function can be used to convert cartesian coordinates into the angle of the
\ polar coordinates.
: FATANH ( fs: r1 -- r2 ) 
\ ANSI             Floating ext
\ r2 is the number whose hyperbolic tangent is r1. IF |r1| > 1.0 then r2 is a NAN.
NEWUSER FBCD-BUF 
FCONSTANT FBIG ( fs: -- r ) 
\ W32F             Floating extra
\ Push the largest non-infinite floating-point number.
CODE FCEIL ( fs: r1 -- r2 ) 
\ W32F         Floating extra
\ Round r1 to an integral value using the round toward positive infinity rule,
\ giving r2.
CODE FCOMPPX ( -- flags ; fs: r1 r2 -- ) 
\ for comparing 2 FP values
CONSTANT FCOMP_EQUAL 
CONSTANT FCOMP_LESS 
CONSTANT FCOMP_MASK 
: FCONSTANT ( "name" -- ; fs: r -- ) 
\ ANSI               Floating
\       Interpretation: ( "name" ; fs: r -- )  
\ Define an FP constant. 
\       Compilation:  
\ Append the run-time semantics given below to the current definition. 
\       Run-time:  ( fs: -- r )  
\ Place r on the floating-point stack.
: FCOS ( fs: r1 -- r2 ) 
\ ANSI         Floating ext
\ r2 is the cosine of r1 in radians.
: FCOSH ( fs: r1 -- r2 ) 
\ ANSI             Floating ext
\ r2 is the hyperbolic cosine of r1.
: FDEPTH ( -- n ) 
\ return floating point stack depth
: FDISCARD-NUMBER ( ?? -- ?? ) 
\ discard a floating point number if present
CODE FDROP ( fs: r -- ) 
\ ANSI           Floating
\ Remove r from the floating-point stack.
: FDUMP ( -- ) 
\ W32F        Floating debug
\ Dump of the real Floating Point Unit.
CODE FDUP ( fs: r -- r r ) 
\ ANSI           Floating
\ Duplicate the top entry on the floating-point stack.
: FE. ( fs: r -- ) 
\ ANSI            Floating ext
\ Display, with a trailing space, the top number on the floating-point stack using
\ engineering notation, where the significand is greater than or equal to 1.0 and less
\ than 1000.0 and the decimal exponent is a multiple of three.
FCONSTANT FEPS ( fs: -- r ) 
\ W32F             Floating extra
\ Push the smallest non-zero floating-point number.
CODE FEXAM ( fs: r -- r ; -- n ) 
\ Examines r and return the condition code flags C0, C2, and C3
CODE FEXP ( fs: r1 -- r2 ) 
\ ANSI       Floating ext
\ Raise e to the power r1, giving r2.
CODE FEXPM1 ( fs: r1 -- r2 ) 
\ ANSI      Floating ext
\ Raise e to the power r1 and subtract one, giving r2.
\ This function allows accurate computation when its arguments are close to zero, and
\  provides a useful base for the standard exponential functions. Hyperbolic functions
\  such as cosh(x) can be efficiently and accurately implemented by using FEXPM1;
\  accuracy is lost in this function for small values of x if the word FEXP is used.
: FFIELD: ( n1 "name" -- n2 ) 
( addr -- 'addr ) 
\ Skip leading space delimiters. Parse name delimited by a space. Offset is the first
\ float aligned value greater than or equal to n1. n2 = offset + 1 float.
\ Create a definition for name with the execution semantics given below.
\ name Execution: ( addr1 -- addr2 )
\ Add the offset calculated during the compile time action to addr1 giving the float
\ aligned address addr2.
FCONSTANT FINF ( fs: -- r ) 
CODE FINIT ( -- ) 
\ W32F    Floating extra
\ Clears the floating-point stack & sets the appropriate byte mode.
\ It is executed by the system on start-up and by the default exception handler.
\ Users generally don't need to call this word in a single-task program.
\ Tasks in a multi-task program should execute this word before executing any
\ other floating-point words.
CODE FL2E ( fs: -- r ) 
\ W32F          Floating extra
\ Push the value of log base 2 of e.
CODE FL2T ( fs: -- r ) 
\ W32F          Floating extra
\ Push the value of log base 2 of 10.
CODE FLIT ( fs: -- r ) 
: FLITERAL ( Compilation fs: r -- ; Runtime fs: -- r ) 
\ ANSI         Floating
\          Interpretation:  
\ Interpretation semantics for this word are undefined. 
\          Compilation: ( fs: r -- )  
\ Append the run-time semantics given below to the current definition. 
\          Run-time: ( fs: -- r )  
\ Place r on the floating-point stack.
CODE FLN ( fs: r1 -- r2 ) 
\ ANSI            Floating ext
\ r2 is the natural logarithm of r1. If r1 is 0 then r2 is -infinity. If r1
\ is infinity then r2 is infinity. If r1 is less than zero then r2 is a NAN.
CODE FLN2 ( fs: -- r ) 
\ W32F          Floating extra
\ Push the value of ln 2 (the natural logarithm).
CODE FLNP1 ( fs: r1 -- r2 ) 
\ ANSI           Floating ext
\ r2 is the natural logarithm of the quantity r1 plus one. If r1 is -1.0 then
\ r2 is -infinity. If r1 is infinity then r2 is infinity. If r1 is less than
\ -1.0 then r2 is a NAN.
: FLOAT ( "name" -- ) 
\ compile time          64-bits
( -- ; fs: -- r ) 
\ runtime
CFA-FUNC FLOAT! 
OFFSET FLOAT+ ( addr1 -- addr2 ) 
CFA-FUNC FLOAT+! 
: FLOAT-ARRAY ( n1 "name" -- ) 
\ compile time
( -- a1 ) 
\ runtime
: FLOAT-NUMBER? ( a1 n1 -- d ) 
\ input parameters
\ floating point number should only be accepted if we are in DECIMAL
\ they can still be entered manually using F# <number>
: FLOAT-RESET-STACKS ( -- ) 
\ reset compile time values
MACRO: FLOAT; 
VALUE FLOAT? 
CFA-FUNC FLOAT@ 
: FLOATER? ( a1 -- a1 f1 ) 
\ is a1 the CFA of a float? or ^float?
: FLOATS ( n1 -- n2 ) 
NEWUSER FLOATSP ( -- addr ) 
\ W32F             Floating extra
\ Address of floating point stack pointer in the user area.
NEWUSER FLOATSTACK 
CODE FLOG ( fs: r1 -- r2 ) 
\ ANSI       Floating ext
\ r2 is the logarithm to base 10 of r1. If r1 is 0 then r2 is -infinity. If r1
\ is infinity then r2 is infinity. If r1 is less than zero then r2 is a NAN.
CODE FLOG2 ( fs: -- r ) 
\ W32F          Floating extra
\ Push the value of log base 10 of 2.
CODE FLOOR ( fs: r1 --  r2 ) 
\ ANSI         Floating
\ Round r1 to an integral value using the round toward negative infinity rule,
\ giving r2.
: FMAX ( fs: r1 r2 -- r3 ) 
\ ANSI           Floating
\ Return r3 the maximum of r1 and r2. If r1 is a NAN then so is r3. If r2 is a NAN
\ then r3=r1.
: FMIN ( fs: r1 r2 -- r3 ) 
\ ANSI           Floating
\ Return r3 the minimum of r1 and r2. If r1 is a NAN then so is r3. If r2 is a NAN
\ then r3=r1.
CODE FNEGATE ( fs: r1 -- r2 ) 
\ ANSI          Floating
\ Reverse the sign of r1.
: FNIP ( fs: r1 r2 -- r2 ) 
\ W32F          Floating extra
\ Remove the 2nd FP stack entry.
CODE FOVER ( fs: r1 r2 -- r1 r2 r1 ) 
\ ANSI           Floating
\ Copy the 2nd FP stack number to the top of the FP stack.
CODE FPCW> ( -- n ) 
\ W32F        Floating extra
\ Get x87 FPU Control Word.
CONSTANT FPDISPSIZE 
CODE FPI ( fs: -- r ) 
\ W32F           Floating extra
\ Push the value 3.141596... on to the FP stack.
FCONSTANT FPI/2 
CODE FPICK ( n -- ; fs: -- r ) 
\ W32F         Floating extra
\ Copy the n'th number from the FP stack.
CODE FPSW> ( -- n ) 
\ W32F        Floating extra
\ Get x87 FPU Status Word.
MACRO: FPU> 
CONSTANT FPU_STATUS_CCF_DENORMAL 
CONSTANT FPU_STATUS_CCF_EMPTY 
CONSTANT FPU_STATUS_CCF_INFINITY 
CONSTANT FPU_STATUS_CCF_MASK \ mask for C0, C1, C2 and C3
CONSTANT FPU_STATUS_CCF_MASK_023 \ mask for C0, C2 and C3
CONSTANT FPU_STATUS_CCF_MASK_1 \ mask for C1
CONSTANT FPU_STATUS_CCF_NAN 
CONSTANT FPU_STATUS_CCF_NORMAL 
CONSTANT FPU_STATUS_CCF_UNSUPPORTED 
CONSTANT FPU_STATUS_CCF_ZERO 
NEWUSER FRACNT 
: FRACNT@.NEGATE ( -- n1 ) 
: FRACTION ( fs: r1 -- r2 ) 
CODE FREM2PI ( fs: r1 -- r2 ) 
CODE FROT ( fs: r1 r2 r3 -- r2 r3 r1 ) 
\ ANSI          Floating
\ Rotate the top 3 FP stack numbers.
CODE FROUND ( fs: r1 -- r2 ) 
\ ANSI         Floating
\ Round r1 to an integral value using the round to nearest rule, giving r2.
: FS. ( fs: r -- ) 
\ ANSI            Floating ext
\ Display, with a trailing space, the top number on the floating-point stack in
\ scientific notation:
\        <significand><exponent>
\ where:
\        <significand>  :=  [-]<digit>.<digits0>
\        <exponent>     :=  E[-]<digits>
CODE FS>DS ( -- dfloat fs: r -- ) 
\ W32F           Floating extra
\ Move floating point number bits to the data stack as a 64-bit float.
\ This function is for passing floats to DLLs.
: FSIN ( fs: r1 -- r2 ) 
\ ANSI         Floating ext
\ r2 is the sine of r1 in radians.
: FSINCOS ( fs: r1 -- r2 r3 ) 
\ ANSI         Floating ext
\ r2 is the sine and r3 the cosine of r1 in radians. This function is more efficient
\ than calling FSIN and FCOS separately.
: FSINH ( fs: r1 -- r2 ) 
\ ANSI             Floating ext
\ r2 is the hyperbolic sine of r1.
: FSIZE 
FCONSTANT FSMALL ( fs: -- r ) 
\ W32F             Floating extra
\ Push the smallest non-denormalised floating-point number.
VALUE FSP-ADJUST 
VALUE FSP-CACHED? 
MACRO: FSP_MEMORY ( -- ) 
CODE FSQRT ( fs: r1 -- r2 ) 
\ ANSI        Floating ext
\ r2 is the positive square root of r1. r2 is NAN for negative r1.
SUBR: FSTACK-CHECK 
MACRO: FSTACK-CHECK_1 
MACRO: FSTACK-CHECK_2 
MACRO: FSTACK-CHECK_3 
CONSTANT FSTACK-ELEMENTS \ 256 floating point elements in stack
MACRO: FSTACK_MEMORY ( -- ) 
: FSTKUFLO ( -- ) 
\ handle floating point stack underflow
CODE FSWAP ( fs: r1 r2 -- r2 r1 ) 
\ ANSI          Floating
\ Exchange the top 2 FP numbers.
: FTAN ( fs: r1 -- r2 ) 
\ ANSI         Floating ext
\ r2 is the tangent of r1 in radians.
: FTANH ( fs: r1 -- r2 ) 
\ ANSI             Floating ext
\ r2 is the hyperbolic tangent of r1, |r2| <= 1.
FVARIABLE FTEMP 
CODE FTRUNC ( fs: r1 -- r2 ) 
\ W32F         Floating extra
\ Round r1 to an integral value using the round toward zero rule, giving r2.
CODE FTSTP ( -- flags ; fs: r1 -- ) 
\ for comparison with 0.0e0
: FVALUE ( compiling "name" -- ; fs: r -- ; run-time FS: -- r  ) 
\ W32F    Floating ext
\ Define a floating point value initialised from the FP stack.
: FVARIABLE ( compiling "name"  -- ; run-time -- addr) 
\ ANSI        Floating
\ Define a floating-point variable in the dictionary. The contents are undefined.
: F^2 
: F~ ( -- flag ; fs: r1 r2 r3 -- ) 
\ ANSI        Floating ext
\ If r3 is positive, flag is true if the absolute value of (r1 minus r2) is less than
\ r3. If r3 is zero, flag is true if the implementation-dependent encoding of r1 and
\ r2 are exactly identical (positive and negative zero are unequal).
\ If r3 is negative, flag is true if the absolute value of (r1 minus r2) is less than the
\ absolute value of r3 times the sum of the absolute values of r1 and r2.
\ This provides the three types of floating point equality in common use -- close in
\ absolute terms, exact equality as represented, and relatively close.
: G. ( fs: r -- ) 
\ W32F            Floating extra
\ Display the top number on the floating-point stack using scientific notation or
\ ordinary representation according to the size of r.
: H.NPUSTACK ( -- ) 
NEWUSER HAVEDIGITS 
: INIT->FLOAT ( -- ) 
NEWUSER INTCNT 
NEWUSER MANTSIGN 
CONSTANT MAXSIG 
: MIN-PRECISION ( u -- ) 
\ W32F         Floating extra
\ Set the number of significant digits currently used by (F.), (FE.), (FS.), F.,
\ FE., or FS. to u if it is greater than the present setting.
: NEXT-CHAR ( addr1 -- addr2 char flag ) 
\ flag = 0 means valid char
: NEXT-FRACTION ( fs: r1 -- r2 ) 
CONSTANT NPSTK 
: NPU-DEPTH ( -- n ) 
\ FR1 >FREGS>
: PRECISION ( -- u ) 
\ ANSI         Floating ext
\ Return the number of significant digits currently used by (F.), (FE.), (FS.), F.,
\ FE., or FS. as u.
: REP-DENORMAL ( addr u -- n true ; fs: r -- ) 
\ handle denormal floats in REPRESENT
\ (which is the same action as for normal floats).
: REP-NORMAL ( addr u -- n true ; fs: r -- ) 
\ handle normal floats in REPRESENT.
: REP-SPEC ( addr u cstr -- n false ; fs: r -- ) 
: REP-ZERO ( addr u -- 1 true ; fs: r -- ) 
: REPRESENT ( addr u -- n flag1 flag2 ; fs: r -- ) 
\ ANSI          Floating
\ At c-addr, place the character-string external representation of the significand of
\ the floating-point number r. Return the decimal-base exponent as n, the sign as flag1
\ and valid result as flag2. The character string shall consist of the u most significant
\ digits of the significand represented as a decimal fraction with the implied decimal
\ point to the left of the first digit, and the first digit zero only if all digits
\ are zero. The significand is rounded to u digits following the round to nearest
\ rule; n is adjusted, if necessary, to correspond to the rounded magnitude of the
\ significand. If flag2 is true then r was in the implementation-defined range of
\ floating-point numbers. If flag1 is true then r is negative. 
\ An ambiguous condition exists if the value of BASE is not decimal ten. 
\ When flag2 is false, n  is 7FFFFFFF and flag1 is the sign. The contents of c-addr are
\ the first u characters of either NAN or Infinity, padded with spaces if necessary.
MACRO: RESTORE-ROUNDING-MODE 
: S. ( n addr len w -- ) 
: S>F ( n -- ; fs: -- r ) 
\ W32F            Floating extra
\ Convert the single number n to floating point number r.
: SEE.FLOAT ( a1 -- a2 ) 
: SET-PRECISION ( u -- ) 
\ ANSI         Floating ext
\ Set the number of significant digits currently used by (F.), (FE.), (FS.), F.,
\ FE., or FS. to u.
MACRO: SET-ROUNDING-MODE 
CODE SF! ( addr -- ; fs: r -- ) 
\ ANSI        Floating ext
\ Store a 32 bit (short) float.
CODE SF@ ( addr -- ; fs: -- r ) 
\ ANSI       Floating ext
\ Fetch a 32 bit (short) float.
: SFALIGN ( -- ) 
: SFALIGNED ( addr -- addr ) 
: SFIELD: ( n1 "name" -- n2 ) 
( addr -- 'addr ) 
\ Skip leading space delimiters. Parse name delimited by a space. Offset is the first
\ singe-float aligned value greater than or equal to n1. n2 = offset + 1 single-float.
\ Create a definition for name with the execution semantics given below.
\ name Execution: ( addr1 -- addr2 )
\ Add the offset calculated during the compile time action to addr1 giving the
\ single-float aligned address addr2.
OFFSET SFLOAT+ ( addr1 -- addr2 ) 
: SFLOATS ( n1 -- n2 ) 
CODE SFS>DS ( -- float ; fs: r -- ) 
\ W32F           Floating extra
\ Push the top of the float stack onto the data stack as a 32-bit float.
\ This function is for passing floats to DLLs.
VALUE SHOW-FP-DEPTH 
CODE SIG>F ( fs: -- r ) 
\ Push contents of 80-bit BCD number in fbcd-buf onto FP stack
VARIABLE SIGDIGITS 
FVARIABLE SQ2/2M1 ( -- addr ) 
\ W32F             Floating extra
\ Return the address of a float containing sqrt(2)/2 - 1.
FVARIABLE SQ2M1 ( -- addr ) 
\ W32F             Floating extra
\ Return the address of a float containing sqrt(2) - 1.
CONSTANT THROW_FLOATSTACKUNDER 
: XSIGN ( char -- char false | nflag true ) 
: ZERO-RESULT ( fs: r1 -- r2 ) 
NEWUSER ZEROCHAR 
CODE ZF>D ( -- d ; fs: r -- ) 
\ W32F           Floating extra
\ Convert floating-point number to double number, using the current rounding mode
\ (rounding towards nearest unless changed by the user). If the result would be too
\ large to fit in a double number then  -9223372036854775808 is returned.
CFA-FUNC ^#FLOAT! 
CFA-FUNC ^#FLOAT+! 
CFA-FUNC ^#FLOAT@ 
: ^FLOAT ( a1 "name" -- ) 
\ compile time          64-bits
( fs: -- r ) 
\ runtime
CFA-FUNC ^FLOAT! 
CFA-FUNC ^FLOAT+! 
CFA-FUNC ^FLOAT@ 
: _FLOAT-NUMBER, ( d1 -- d1 ) 
\ interpreting a double
( d1 -- ) 
\ compiling a double
( fs: r1 -- r1 ) 
\ interpreting a float
( fs: r1 -- ) 
\ compiling a float
:M CHARSET: ( n1 -- ) 
:M CLIPPRECISION: ( n1 -- ) 
:M CREATE: ( -- ) 
:M DELETE: ( -- ) 
:M ESCAPEMENT: ( n1 -- ) 
:CLASS FONT 
:CLASS FONT 
:M HANDLE: ( -- hFont ) 
:M HEIGHT: ( n1 -- ) 
:M ITALIC: ( f1 -- ) 
:M ORIENTATION: ( n1 -- ) 
:M OUTPRECISION: ( n1 -- ) 
:M PITCHANDFAMILY: ( n1 -- ) 
:M QUALITY: ( n1 -- ) 
:M STRIKEOUT: ( f1 -- ) 
:M UNDERLINE: ( f1 -- ) 
:M WEIGHT: ( n1 -- ) 
:M WIDTH: ( n1 -- ) 
:M ZHANDLE: ( -- ) 
: (?GDICHECK) ( a1 -- a1 ) 
\ w32f sys internal
\ Verify if a1 is the address of a GdiObject.
\ If a1 isn't the address of a GdiObject the application will be aborted.
: .GDI-OBJECTS ( -- ) 
\ w32f sys
\ Display GDI objects which are currently defined.
: ?GDICHECK ( a1 -- a1 ) 
\ w32f
\ Verify if a1 is the address of a GdiObject.
\ If a1 isn't the address of a GdiObject and the error checking is enabled
\ the application will be aborted.
\ NOTE:  ?GdiCheck  does nothing in turnkey applications, it's for debugging only.
: ?ISGDIOBJECT ( a1 -- f ) 
\ w32f
\ Check if a1 is the address of a GdiObject.
:M CLASSINIT: ( -- ) 
\ Init the class
: DESTROY-GDI-OBJECTS ( -- ) 
\ destroy all GDI objects
:M DESTROY-GDI-OBJECTS: ( -- ) 
\ destroy this object
:M DESTROY: ( -- ) 
\ Destroy the object.
: DESTROY? ( -- f ) 
: DO-OBJECTS { method -- } 
VARIABLE GDI-OBJECT-LINK 
:CLASS GDIOBJECT 
:CLASS GDIOBJECT 
: GETGDIOBJECTHANDLE { GdiObject -- handle } 
\ w32f
\ Check if GdiObject is the address of a valid GdiObject.
\ If so return the handle of the object.
:M GETHANDLE: ( -- hObject ) 
\ Get the handle of the object.
:M GETOBJECT: ( cbBuffer lpvObject -- n ) 
\ Get information for the object.      
\ If the function succeeds, and lpvObject is a valid pointer, the return value is
\ the number of bytes stored into the buffer. 
\ If the function succeeds, and lpvObject is NULL, the return value is the number
\ of bytes required to hold the information the function would store into the buffer.
\ If the function fails, the return value is zero.
:M GETTYPE: ( -- n ) 
\ Get the type of the object.  
\ Possible return values are:
\ 
\ OBJ_BITMAP         | Bitmap |
\ OBJ_BRUSH          | Brush |
\ OBJ_COLORSPACE     | Color space |
\ OBJ_DC             | Device context |
\ OBJ_ENHMETADC      | Enhanced metafile DC |
\ OBJ_ENHMETAFILE    | Enhanced metafile |
\ OBJ_EXTPEN         | Extended pen |
\ OBJ_FONT           | Font |
\ OBJ_MEMDC          | Memory DC |
\ OBJ_METAFILE       | Metafile |
\ OBJ_METADC         | Metafile DC |
\ OBJ_PAL            | Palette |
\ OBJ_PEN            | Pen |
\ OBJ_REGION         | Region |
: INIT-GDI-OBJECTS ( -- ) 
\ clear all handles
INT MYLINK 
:M SETHANDLE: ( hObject -- ) 
\ Set the handle of the object.      
\ If the current handle of the object is valid it will be destroyed.
: TRIM-GDI-OBJECTS ( nfa -- nfa ) 
: UNCHAIN-GDI-DYNAMIC-OBJECT ( addr -- ) 
: UNCHAIN-GDI-DYNAMIC-OBJECTS ( -- ) 
: UNCHAIN-GDI-OBJECT ( -- ) 
: UNLINKGDIOBJECT ( -- ) 
\ remove the GdiObject at the head of the gdi-object-link list
:M VALID?: ( -- f ) 
\ Check if this object is valid.
:M ZEROHANDLE: ( -- ) 
\ Clear the handle of the object. 
\ If the current handle of the object is valid it will not be destroyed.
:M ~: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CREATEBITMAP: ( Width Height Planes BitsPerPel pBits -- f ) 
\ The CreateBitmap function creates a bitmap with the specified width, height,
\ and color format (color planes and bits-per-pixel). 
\ 
\ Width  Specifies the bitmap width, in pixels.      
\ Height Specifies the bitmap height, in pixels.     
\ Planes Specifies the number of color planes used by the device.    
\ BitsPerPel Specifies the number of bits required to identify the color of a
\ single pixel. 
\ pBits Pointer to an array of color data used to set the colors in a rectangle
\ of pixels. Each scan line in the rectangle must be word aligned (scan
\ lines that are not word aligned must be padded with zeros). If this
\ parameter is NULL, the contents of the new bitmap is undefined. 
\ 
\ After a bitmap is created, it can be selected into a device context by calling
\ the SelectObject function. The CreateBitmap function can be used to create color
\ bitmaps. However, for performance reasons applications should use CreateBitmap
\ to create monochrome bitmaps and CreateCompatibleBitmap to create color bitmaps.
\ When a color bitmap returned from CreateBitmap is selected into a device context,
\ the system must ensure that the bitmap matches the format of the device context
\ it is being selected into. Since CreateCompatibleBitmap takes a device context,
\ it returns a bitmap that has the same format as the specified device context.
\ Because of this, subsequent calls to SelectObject are faster than with a color
\ bitmap returned from CreateBitmap. 
\ 
\ If the bitmap is monochrome, zeros represent the foreground color and ones represent
\ the background color for the destination device context. 
\ 
\ If an application sets the nWidth or nHeight parameters to zero, CreateBitmap
\ returns the handle to a 1-by-1 pixel, monochrome bitmap. 
\ 
\ When you no longer need the bitmap, call the Destroy: method to delete it. 
\ 
\ Windows 95/98: The created bitmap cannot exceed 16MB in size
:M CREATEBITMAPINDIRECT: ( pBitmap -- f ) 
\ The CreateBitmapIndirect function creates a bitmap with the specified width,
\ height, and color format (color planes and bits-per-pixel).
\ pBitmap Pointer to a BITMAP structure that contains information about the
\ bitmap. If an application sets the bmWidth or bmHeight members to zero,
\ CreateBitmapIndirect returns the handle to a 1-by-1 pixel, monochrome bitmap.
:M CREATECOMPATIBLEBITMAP: ( Width Height hDC -- f ) 
\ The CreateCompatibleBitmap function creates a bitmap compatible with the device
\ that is associated with the specified device context. 
\ 
\ The color format of the bitmap created by the CreateCompatibleBitmap function
\ matches the color format of the device identified by the hdc parameter. This
\ bitmap can be selected into any memory device context that is compatible with
\ the original device. 
\ 
\ Because memory device contexts allow both color and monochrome bitmaps, the format
\ of the bitmap returned by the CreateCompatibleBitmap function differs when the
\ specified device context is a memory device context. However, a compatible bitmap
\ that was created for a nonmemory device context always possesses the same color
\ format and uses the same color palette as the specified device context. 
\ 
\ Note: When a memory device context is created, it initially has a 1-by-1 monochrome
\ bitmap selected into it. If this memory device context is used in CreateCompatibleBitmap,
\ the bitmap that is created is a monochrome bitmap. To create a color bitmap, use the
\ hDC that was used to create the memory device context, as shown in the following code: 
\ 
\     HDC memDC = CreateCompatibleDC ( hDC ); 
\     HBITMAP memBM = CreateCompatibleBitmap ( hDC ); 
\     SelectObject ( memDC, memBM ); 
\ 
\ If an application sets the nWidth or nHeight parameters to zero, CreateCompatibleBitmap
\ returns the handle to a 1-by-1 pixel, monochrome bitmap. 
\ 
\ If a DIB section, which is a bitmap created by the CreateDIBSection function, is selected
\ into the device context identified by the hdc parameter, CreateCompatibleBitmap creates a
\ DIB section. 
\ 
\ When you no longer need the bitmap, call the DeleteObject function to delete it. 
\ 
\ Windows 95/98: The created bitmap cannot exceed 16MB in size.
:M CREATEDIBITMAP: ( pbmih fdwInit pbInit pbmi fuUsage hdc -- f ) 
\ The CreateDIBitmap function creates a device-dependent bitmap (DDB) from a DIB and,
\ optionally, sets the bitmap bits. 
\ lpbmih Pointer to a bitmap information header structure, which may be one of those
\ shown in the following table.
\ 
\ Operating system              | Bitmap information header
\ Windows NT 3.51 and earlier   | BITMAPINFOHEADER |
\ Windows NT 4.0 and Windows 95 | BITMAPV4HEADER (NOT SUPPORTED !!!) |
\ Windows 2000 and Windows 98   | BITMAPV5HEADER (NOT SUPPORTED !!!) |
\ If fdwInit is CBM_INIT, the function uses the bitmap information header structure to
\ obtain the desired width and height of the bitmap as well as other information. Note
\ that a positive value for the height indicates a bottom-up DIB while a negative value
\ for the height indicates a top-down DIB. Calling CreateDIBitmap with fdwInit as CBM_INIT
\ is equivalent to calling the CreateCompatibleBitmap function to create a DDB in the format
\ of the device and then calling the SetDIBits function to translate the DIB bits to the DDB. 
\ fdwInit Specifies how the system initializes the bitmap bits. The following values is defined.
\ Value Meaning CBM_INIT If this flag is set, the system uses the data pointed to by the lpbInit
\ and lpbmi parameters to initialize the bitmap's bits. If this flag is clear, the data pointed
\ to by those parameters is not used. 
\ If fdwInit is zero, the system does not initialize the bitmap's bits. 
\ lpbInit Pointer to an array of bytes containing the initial bitmap data. The format of the data
\ depends on the biBitCount member of the BITMAPINFO structure to which the lpbmi parameter points. 
\ lpbmi Pointer to a BITMAPINFO structure that describes the dimensions and color format of the
\ array pointed to by the lpbInit parameter. 
\ fuUsage Specifies whether the bmiColors member of the BITMAPINFO structure was initialized and,
\ if so, whether bmiColors contains explicit red, green, blue (RGB) values or palette indexes.
\ The fuUsage parameter must be one of the following values.
\ 
\ DIB_PAL_COLORS | A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the bitmap is to be selected. |
\ DIB_RGB_COLORS | A color table is provided and contains literal RGB values. |
:M CREATEDIBSECTION: ( pbmi iUsage ppvBits hSection dwOffset hdc -- f ) 
\ The CreateDIBSection function creates a DIB that applications can write to directly. The function
\ gives you a pointer to the location of the bitmap's bit values. You can supply a handle to a
\ file-mapping object that the function will use to create the bitmap, or you can let the system
\ allocate the memory for the bitmap. 
\ hdc Handle to a device context. If the value of iUsage is DIB_PAL_COLORS, the function uses
\ this device context's logical palette to initialize the DIB's colors. 
\ pbmi Pointer to a BITMAPINFO structure that specifies various attributes of the DIB, including
\ the bitmap's dimensions and colors. 
\ iUsage Specifies the type of data contained in the bmiColors array member of the BITMAPINFO
\ structure pointed to by pbmi (either logical palette indexes or literal RGB values). The
\ following values are defined.
\ 
\ DIB_PAL_COLORS | The bmiColors member is an array of 16-bit indexes into the logical palette of the device context specified by hdc. |
\ DIB_RGB_COLORS | The BITMAPINFO structure contains an array of literal RGB values. |
\ ppvBits Pointer to a variable that receives a pointer to the location of the DIB's bit values. 
\ hSection Handle to a file-mapping object that the function will use to create the DIB. This
\ parameter can be NULL. If hSection is not NULL, it must be a handle to a file-mapping object
\ created by calling the CreateFileMapping function with the PAGE_READWRITE or PAGE_WRITECOPY flag.
\ Read-only DIB sections are not supported. Handles created by other means will cause CreateDIBSection
\ to fail. If hSection is not NULL, the CreateDIBSection function locates the bitmap's bit values at
\ offset dwOffset in the file-mapping object referred to by hSection. An application can later retrieve
\ the hSection handle by calling the GetObject function with the HBITMAP returned by CreateDIBSection.
\ If hSection is NULL, the system allocates memory for the DIB. In this case, the CreateDIBSection
\ function ignores the dwOffset parameter. An application cannot later obtain a handle to this memory.
\ The dshSection member of the DIBSECTION structure filled in by calling the GetObject function will
\ be NULL. 
\ dwOffset Specifies the offset from the beginning of the file-mapping object referenced by hSection
\ where storage for the bitmap's bit values is to begin. This value is ignored if hSection is NULL.
\ The bitmap's bit values are aligned on doubleword boundaries, so dwOffset must be a multiple of the
\ size of a DWORD.
:CLASS GDIBITMAP 
:CLASS GDIBITMAP 
:M GETBITMAPDIMENSION: ( -- width height ) 
\ The GetBitmapDimension function retrieves the dimensions of a bitmap. The retrieved dimensions must
\ have been set by the SetBitmapDimension function.
\ The function returns the height and width of the bitmap, in .01-mm units.
:M GETDIBITS: 
:M LOADBITMAP: 
:M MASKBLT: 
:M PLGBLT: 
:M SETBITMAPDIMENSION: ( width height -- oldwidth oldheight ) 
\ The SetBitmapDimension function assigns preferred dimensions to a bitmap. These dimensions can be
\ used by applications; however, they are not used by the system. 
\ Width Specifies the width, in 0.1-millimeter units, of the bitmap. 
\ Height Specifies the height, in 0.1-millimeter units, of the bitmap. 
\ An application can retrieve the dimensions assigned to a bitmap with the SetBitmapDimensionEx function
\ by calling the GetBitmapDimension function. 
\ The bitmap identified by hBitmap cannot be a DIB section, which is a bitmap created by the
\ CreateDIBSection function. If the bitmap is a DIB section, the SetBitmapDimension function fails.
:M SETDIBITS: 
GDISIZE SIZE 
INT BITMAP 
:M CHOOSECOLOR: ( hWnd -- f ) 
\ Open a dialog to choose the color of the brush.
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
GDICOLORREF COLOR 
:M CREATE: ( -- f ) 
\ Create the brush with the current style and color.
:M CREATE: ( -- f ) 
\ Creates a logical brush with the specified bitmap pattern.
:M CREATE: ( -- f ) 
\ Create the brush with the current color.
:M CREATE: ( lpPackedDIB iUsage -- f ) 
\ The Create function creates a logical brush that has the pattern specified
\ by the device-independent bitmap (DIB).    
\ lpPackedDIB Pointer to a packed DIB consisting of a BITMAPINFO structure immediately
\ followed by an array of bytes defining the pixels of the bitmap.   
\ Windows 95: Creating brushes from bitmaps or DIBs larger than 8 by 8 pixels
\ is not supported. If a larger bitmap is specified, only a portion of the bitmap
\ is used.   
\ Windows NT/ 2000 and Windows 98: Brushes can be created from bitmaps or DIBs
\ larger than 8 by 8 pixels. 
\ iUsage Specifies whether the bmiColors member of the BITMAPINFO structure contains
\ a valid color table and, if so, whether the entries in this color table contain
\ explicit red, green, blue (RGB) values or palette indexes. The iUsage parameter
\ must be one of the following values.
\ 
\ DIB_PAL_COLORS | A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the brush is to be selected. |
\ DIB_RGB_COLORS | A color table is provided and contains literal RGB values. |
:M CREATE: ( lplb -- f ) 
\ The Create function creates a logical brush that has the specified style, color, and pattern.
\ lplb Pointer to a LOGBRUSH structure that contains information about the brush.
:CLASS GDIBRUSH 
:CLASS GDIBRUSH 
:CLASS GDIDIBPATTERNBRUSH 
:CLASS GDIDIBPATTERNBRUSH 
:CLASS GDIHATCHBRUSH 
:CLASS GDIHATCHBRUSH 
:CLASS GDIPATTERNBRUSH 
:CLASS GDIPATTERNBRUSH 
:CLASS GDISOLIDBRUSH 
:CLASS GDISOLIDBRUSH 
:M GETBITMAP: ( -- Bitmap ) 
\ Get the Bitmap for the PatternBrush.
:M GETBVALUE: ( -- b ) 
\ Get the blue component of the brush color.
:M GETCOLOR: ( -- colorref ) 
\ Get the color of the brush as a windows COLORREF value.
:M GETGVALUE: ( -- g ) 
\ Get the green component of the brush color.
:M GETORIGIN: ( hdc -- xOrg yOrg ) 
\ Get the current brush origin for the specified device context.
:M GETRVALUE: ( -- r ) 
\ Get the red component of the brush color.
:M GETSTYLE: ( -- style ) 
\ Get the style of the brush. Possible return values are:
\ 
\ HS_BDIAGONAL  | 45-degree downward left-to-right hatch     |
\ HS_CROSS      | Horizontal and vertical crosshatch         |
\ HS_DIAGCROSS  | 45-degree crosshatch                       |
\ HS_FDIAGONAL  | 45-degree upward left-to-right hatch       |
\ HS_HORIZONTAL | Horizontal hatch                           |
\ HS_VERTICAL   | Vertical hatch                             |
GDIPOINT ORIGIN 
:M SETBITMAP: ( Bitmap -- ) 
\ Set the Bitmap for the PatternBrush. The Bitmap can be a DIB section bitmap,
\ which is created by the CreateDIBSection function.
:M SETBVALUE: ( b -- ) 
\ Set the blue component of the brush color.
:M SETCOLOR: ( colorref -- ) 
\ Set color of the brush.
:M SETGVALUE: ( g -- ) 
\ Set the green component of the brush color.
:M SETORIGIN: { xOrg yOrg hdc -- } 
\ Set the brush origin that GDI assigns to the next brush an application selects
\ into the specified device context. 
\ Note: hdc can be the address of a gdiDC class instance or a DC handle. 
\ A brush is a bitmap that the system uses to paint the interiors of filled shapes. 
\ The brush origin is a pair of coordinates specifying the location of one pixel in
\ the bitmap. The default brush origin coordinates are (0,0). For horizontal coordinates,
\ the value 0 corresponds to the leftmost column of pixels; the width corresponds to the
\ rightmost column. For vertical coordinates, the value 0 corresponds to the uppermost
\ row of pixels; the height corresponds to the lowermost row. 
\ The system automatically tracks the origin of all window-managed device contexts and
\ adjusts their brushes as necessary to maintain an alignment of patterns on the surface.
\ The brush origin that is set with this call is relative to the upper-left corner of the
\ client area. 
\ An application should call SetOrigin: after setting the bitmap stretching mode to
\ HALFTONE by using SetStretchBltMode. This must be done to avoid brush misalignment. 
\ Windows NT/ 2000: The system automatically tracks the origin of all window-managed device
\ contexts and adjusts their brushes as necessary to maintain an alignment of patterns on
\ the surface. 
\ Windows 95/98: Automatic tracking of the brush origin is not supported. Applications must
\ use the UnrealizeObject, SetBrushOrgEx, and SelectObject functions to align the brush before
\ using it. 
:M SETRGB: ( r g b -- ) 
\ Set the red, green and blue component of the brush color.
:M SETRVALUE: ( r -- ) 
\ Set the red component of the brush color.
:M SETSTYLE: ( style -- ) 
\ Set the style of the brush. Possible values are:
\ 
\ HS_BDIAGONAL  | 45-degree downward left-to-right hatch     |
\ HS_CROSS      | Horizontal and vertical crosshatch         |
\ HS_DIAGCROSS  | 45-degree crosshatch                       |
\ HS_FDIAGONAL  | 45-degree upward left-to-right hatch       |
\ HS_HORIZONTAL | Horizontal hatch                           |
\ HS_VERTICAL   | Vertical hatch                             |
:M SETSYSCOLOR: ( n -- ) 
\ Set the color of the brush to a system color.
INT STYLE 
:M ABORTPATH: ( -- ) 
\ The AbortPath method closes and discards any paths in the specified device context.
\ If there is an open path bracket in the given device context, the path bracket
\ is closed and the path is discarded. If there is a closed path in the device context,
\ the path is discarded.
:M ARC: ( nLeftRect nTopRect nRightRect nBottomRect nXStartArc nYStartArc nXEndArc nYEndArc -- ) 
\ The Arc method draws an elliptical arc.
\ The arc is drawn using the current pen; it is not filled.
\ The current position is neither used nor updated by Arc.
\ Windows 95/98: The drawing direction is always counterclockwise.
\ Windows NT/2000: Use the GetArcDirection: and SetArcDirection: methods
\ to get and set the current drawing direction for a device
\ context. The default drawing direction is counterclockwise.
\  nLeftRect  x-coord of rectangle's upper-left corner
\  nTopRect  y-coord of rectangle's upper-left corner
\  nRightRect  x-coord of rectangle's lower-right corner
\  nBottomRect  y-coord of rectangle's lower-right corner
\  nXStartArc  x-coord of first radial ending point
\  nYStartArc  y-coord of first radial ending point
\  nXEndArc  x-coord of second radial ending point
\  nYEndArc  y-coord of second radial ending point
:M ARCTO: ( nLeftRect nTopRect nRightRect nBottomRect nXRadial1 nYRadial1 nXRadial2 nYRadial2 -- ) 
\ The ArcTo method draws an elliptical arc.
\ ArcTo is similar to the Arc method, except that the current position is
\ updated.
\ The points ( nLeftRect ,  nTopRect ) and ( nRightRect ,  nBottomRect )
\ specify the bounding rectangle. An ellipse formed by the specified bounding
\ rectangle defines the curve of the arc. The arc extends counterclockwise from
\ the point where it intersects the radial line from the center of the bounding
\ rectangle to the ( nXRadial1 ,  nYRadial1 ) point. The arc ends where it
\ intersects the radial line from the center of the bounding rectangle to the
\ ( nXRadial2,   nYRadial2 ) point. If the starting point and ending point are the
\ same, a complete ellipse is drawn.
\ A line is drawn from the current position to the starting point of the arc.
\ If no error occurs, the current position is set to the ending point of the arc.
\ The arc is drawn using the current pen; it is not filled.
\  nLeftRect  x-coord of rectangle's upper-left corner
\  nTopRect  y-coord of rectangle's upper-left corner
\  nRightRect  x-coord of rectangle's lower-right corner
\  nBottomRect  y-coord of rectangle's lower-right corner
\  nXRadial1  x-coord of first radial ending point
\  nYRadial1  y-coord of first radial ending point
\  nXRadial2  x-coord of second radial ending point
\  nYRadial2  y-coord of second radial ending point
:M BEGINPATH: ( -- ) 
\ The BeginPath method opens a path bracket in the specified device context
\ After a path bracket is open, an application can begin calling GDI drawing
\ functions to define the points that lie in the path. An application can close
\ an open path bracket by calling the EndPath method.
:M BITBLT: ( nXDest nYDest nWidth nHeight hdcSrc nXSrc nYSrc dwRop -- ) 
\ The BitBlt method performs a bit-block transfer of the color data corresponding
\ to a rectangle of pixels from the specified source device context into a
\ destination device context.
\  nXDest  x-coord of destination upper-left corner
\  nYDest  y-coord of destination upper-left corner
\  nWidth  width of destination rectangle
\  nHeight  height of destination rectangle
\  hdcSrc  source DC
\  nXSrc  x-coordinate of source upper-left corner
\  nYSrc  y-coordinate of source upper-left corner
\  dwRop 
:M CANCEL: ( -- ) 
\ The Cancel method cancels any pending operation on the specified device
\ context. 
\ The Cancel method is used by multithreaded applications to cancel lengthy
\ drawing operations. If thread A initiates a lengthy drawing operation,
\ thread B may cancel that operation by calling this method.
VALUE CHAR-HEIGHT \ Height of each character in pixels
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
VALUE CHAR-WIDTH \ Width of each character in pixels
:M CHORD: ( nLeftRect nTopRect nRightRect nBottomRect nXRadial1 nXRadial1 nYRadial1 nXRadial2 nYRadial2 -- ) 
\ The Chord method draws a chord (a region bounded by the intersection of
\ an ellipse and a line segment, called a secant).
\  nLeftRect  x-coord of upper-left corner of rectangle
\  nTopRect  y-coord of upper-left corner of rectangle
\  nRightRect  x-coord of lower-right corner of rectangle
\  nBottomRect  y-coord of lower-right corner of rectangle
\  nXRadial1  x-coord of first radial's endpoint
\  nYRadial1  y-coord of first radial's endpoint
\  nXRadial2  x-coord of second radial's endpoint
\  nYRadial2  y-coord of second radial's endpoint
:M CLASSINIT: ( -- ) 
:M CLOSEFIGURE: ( -- ) 
\ The CloseFigure method closes an open figure in a path.
\ The CloseFigure method closes the figure by drawing a line from the current position
\ to the first point of the figure (usually, the point specified by the most recent call
\ to the MoveToEx function) and then connects the lines by using the line join style.
\ If a figure is closed by using the LineTo function instead of CloseFigure, end caps are
\ used to create the corner instead of a join.
\ The CloseFigure function should only be called if there is an open path bracket in the
\ specified device context.
\ A figure in a path is open unless it is explicitly closed by using this function. (A
\ figure can be open even if the current point and the starting point of the figure are the
\ same.)
\ After a call to CloseFigure, adding a line or curve to the path starts a new figure.
:M CREATECOMPATIBLEBITMAP: ( width height -- hBitmap ) 
\ The CreateCompatibleBitmap method creates a bitmap compatible with the
\ device that is associated with the device context.
:M CREATECOMPATIBLEDC: ( -- hDC ) 
\ The CreateCompatibleDC method creates a memory device context compatible
\ with the device.
:M DEFAULTTABS: ( -- ) 
CONSTANT DEFTABS 
:M DPTOLP: ( lpPoints nCount -- ) 
\ The DPtoLP method converts device coordinates into logical coordinates.
\ The conversion depends on the mapping mode of the device context, the settings
\ of the origins and extents for the window and viewport, and the world transformation.
\  lpPoints  [in/out] Pointer to an array of POINT structures. The x- and y-coordinates
\ contained in each POINT structure will be transformed.
\  nCount  [in] Specifies the number of points in the array.
\ The DPtoLP method fails if the device coordinates exceed 27 bits, or if the
\ converted logical coordinates exceed 32 bits. In the case of such an overflow,
\ the results for all the points are undefined.
:M DRAWTEXT: ( addr len rect format -- ) 
\ The DrawText method draws formatted text in the specified rectangle.
\ It formats the text according to the specified method (expanding tabs,
\ justifying characters, breaking lines, and so forth).
\ Possible values for  Format  are:
\  DT_BOTTOM  Justifies the text to the bottom of the rectangle. This
\ value is used only with the DT_SINGLELINE value.
\  DT_CALCRECT  Determines the width and height of the rectangle. If there
\ are multiple lines of text, DrawText uses the width of the
\ rectangle pointed to by the lpRect parameter and extends the
\ base of the rectangle to bound the last line of text. If there
\ is only one line of text, DrawText modifies the right side of
\ the rectangle so that it bounds the last character in the line.
\ In either case, DrawText returns the height of the formatted
\ text but does not draw the text.
\  DT_CENTER  Centers text horizontally in the rectangle.
\  DT_EDITCONTROL  Duplicates the text-displaying characteristics of a multiline
\ edit control. Specifically, the average character width is
\ calculated in the same manner as for an edit control, and the
\ method does not display a partially visible last line.
\  DT_END_ELLIPSIS  For displayed text, if the end of a string does not fit in the
\ rectangle, it is truncated and ellipses are added. If a word that
\ is not at the end of the string goes beyond the limits of the
\ rectangle, it is truncated without ellipses.
\ The string is not modified unless the DT_MODIFYSTRING flag is
\ specified. Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.
\  DT_EXPANDTABS  Expands tab characters. The default number of characters per
\ tab is eight. The DT_WORD_ELLIPSIS, DT_PATH_ELLIPSIS, and
\ DT_END_ELLIPSIS values cannot be used with the DT_EXPANDTABS value.
\  DT_EXTERNALLEADING  Includes the font external leading in line height. Normally,
\ external leading is not included in the height of a line of text.
\  DT_HIDEPREFIX  Windows 2000: Ignores the ampersand (&) prefix character in the
\ text. The letter that follows will not be underlined, but other
\ mnemonic-prefix characters are still processed. For example: 
\ input string:    "A&bc&&d" 
\ normal:          "Abc&d"   
\ DT_HIDEPREFIX:   "Abc&d"
\ Compare with DT_NOPREFIX and DT_PREFIXONLY.
\  DT_INTERNAL  Uses the system font to calculate text metrics.
\  DT_LEFT  Aligns text to the left.
\  DT_MODIFYSTRING  Modifies the specified string to match the displayed text.
\ This value has no effect unless DT_END_ELLIPSIS or DT_PATH_ELLIPSIS
\ is specified.
\  DT_NOCLIP  Draws without clipping. DrawText is somewhat faster when DT_NOCLIP
\ is used.
\  DT_NOFULLWIDTHCHARBREAK  Windows 98, Windows 2000: Prevents a line break at a DBCS
\ (double-wide character string), so that the line breaking rule is
\ equivalent to SBCS strings. For example, this can be used in Korean
\ windows, for more readability of icon labels. This value has no effect
\ unless DT_WORDBREAK is specified.
\  DT_NOPREFIX  Turns off processing of prefix characters. Normally, DrawText interprets
\ the mnemonic-prefix character & as a directive to underscore the character
\ that follows, and the mnemonic-prefix characters && as a directive to
\ print a single &. By specifying DT_NOPREFIX, this processing is turned
\ off. For example, 
\ input string:   "A&bc&&d"  
\ normal:         "Abc&d"    
\ DT_NOPREFIX:    "A&bc&&d"
\ Compare with DT_HIDEPREFIX and DT_PREFIXONLY.
\  DT_PATH_ELLIPSIS  For displayed text, replaces characters in the middle of the string with
\ ellipses so that the result fits in the specified rectangle. If the string
\ contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as
\ possible of the text after the last backslash. The string is not modified
\ unless the DT_MODIFYSTRING flag is specified.
\ Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.
\  DT_PREFIXONLY    Windows 2000: Draws only an underline at the position of the character
\ following the ampersand (&) prefix character. Does not draw any other
\ characters in the string. For example, 
\ input string:    "A&bc&&d" 
\ normal:          "Abc&d"   
\ DT_PREFIXONLY:   " _   "
\ Compare with DT_HIDEPREFIX and DT_NOPREFIX.
\  DT_RIGHT  Aligns text to the right.
\  DT_RTLREADING  Layout in right-to-left reading order for bi-directional text when the font
\ selected into the hdc is a Hebrew or Arabic font. The default reading order
\ for all text is left-to-right.
\  DT_SINGLELINE  Displays text on a single line only. Carriage returns and line feeds do not
\ break the line.
\  DT_TABSTOP  Sets tab stops. Bits 158 (high-order byte of the low-order word) of the
\ uFormat parameter specify the number of characters for each tab. The default
\ number of characters per tab is eight.The DT_CALCRECT, DT_EXTERNALLEADING,
\ DT_INTERNAL, DT_NOCLIP, and DT_NOPREFIX values cannot be used with the
\ DT_TABSTOP value.
\  DT_TOP  Justifies the text to the top of the rectangle.
\  DT_VCENTER  Centers text vertically. This value is used only with the DT_SINGLELINE value.
\  DT_WORDBREAK  Breaks words. Lines are automatically broken between words if a word would
\ extend past the edge of the rectangle specified by the lpRect parameter. A
\ carriage return-line feed sequence also breaks the line.
\  DT_WORD_ELLIPSIS  Truncates any word that does not fit in the rectangle and adds ellipses.
\ Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS.
:M ELLIPSE: ( nLeftRect nTopRect nRightRect nBottomRect -- ) 
\ The Ellipse method draws an ellipse. The center of the ellipse is the
\ center of the specified bounding rectangle.
\  nLeftRect  x-coord of upper-left corner of rectangle
\  nTopRect  y-coord of upper-left corner of rectangle
\  nRightRect  x-coord of lower-right corner of rectangle
\  nBottomRect  y-coord of lower-right corner of rectangle
:M ENDPATH: ( -- ) 
\ The EndPath method closes a path bracket and selects the path defined by the
\ bracket into the specified device context.
:M EXTFLOODFILL: ( nXStart nYStart crColor fuFillType -- ) 
\ The ExtFloodFill method fills an area of the display surface with the current brush.
\  nXStart  Specifies the logical x-coordinate of the point where filling is to start.
\  nYStart  Specifies the logical y-coordinate of the point where filling is to start.
\  crColor  Specifies the color of the boundary or of the area to be filled. The
\ interpretation of crColor depends on the value of the fuFillType parameter.
\  fuFillType  Specifies the type of fill operation to be performed. This parameter must
\ be one of the following values.
\  FLOODFILLBORDER  The fill area is bounded by the color specified by the crColor parameter.
\ This style is identical to the filling performed by the FloodFill method.
\  FLOODFILLSURFACE  The fill area is defined by the color that is specified by
\ crColor. Filling continues outward in all directions as long as the color is
\ encountered. This style is useful for filling areas with multicolored boundaries.
:M FILLPATH: ( -- ) 
\ The FillPath method closes any open figures in the current path and fills the path's
\ interior by using the current brush and polygon-filling mode.
\ After its interior is filled, the path is discarded from the DC
:M FILLRECT: ( left top right bottom hBrush -- ) 
\ The FillRect method fills a rectangle by using the specified brush.
\ This method includes the left and top borders, but excludes the right
\ and bottom borders of the rectangle.
\ Note:  hBrush  can be a valid brush handle or the address of a GdiBrush class !
:M FLATTENPATH: ( -- ) 
\ The FlattenPath method transforms any curves in the path that is selected into the
\ current device context (DC), turning each curve into a sequence of lines.
:M FRAMERECT: ( left top right bottom hBrush -- ) 
\ The FrameRect method draws a border around the specified rectangle
\ by using the specified brush. The width and height of the border are
\ always one logical unit.
\ Note:  hBrush  can be a valid brush handle or the address of a GdiBrush class !
:CLASS GDIDC 
:CLASS GDIDC 
:M GETARCDIRECTION: ( -- Direction ) 
\ The GetArcDirection method retrieves the current arc direction for the
\ specified device context. Arc and rectangle methods use the arc direction.
\ Only for Windows 98 and better.
:M GETBACKGROUNDCOLOR: ( -- colorref ) 
\ The GetBackgroundColor method returns the current background color for the
\ specified device context.
:M GETBACKGROUNDMODE: ( -- fMode ) 
\ The GetBackgroundMode method returns the current background mix mode for a
\ specified device context. The background mix mode of a device context affects
\ text, hatched brushes, and pen styles that are not solid lines.
:M GETBRUSHCOLOR: ( -- colorref ) 
\ The GetBrushColor method retrieves the current brush color for the specified
\ device context.
\ Only for Windows 2000 and later
:M GETCURRENTOBJECT: ( ObjectType -- hObject ) 
\ The GetCurrentObject method retrieves a handle to an object of the
\ specified type that has been selected into the specified device context.
\  ObjectType  Specifies the object type to be queried. This parameter can be
\ one of the following values.
\ 
\ OBJ_BITMAP     | Returns the current selected bitmap. |
\ OBJ_BRUSH      | Returns the current selected brush. |
\ OBJ_COLORSPACE | Returns the current color space. |
\ OBJ_FONT       | Returns the current selected font. |
\ OBJ_PAL        | Returns the current selected palette. |
\ OBJ_PEN        | Returns the current selected pen. |
:M GETCURRENTPOSITION: ( -- x y ) 
\ The GetCurrentPosition method retrieves the current position in logical
\ coordinates.
:M GETDEVICECAPS: ( Index -- n ) 
\ The GetDeviceCaps method retrieves device-specific information for the
\ specified device.
\  Index  Specifies the item to return. This parameter can be one of the
\ following values:
\  DRIVERVERSION  The device driver version.
\  TECHNOLOGY  Device technology. It can be any one of the following values.
\ 
\ DT_PLOTTER    | Vector plotter |
\ DT_RASDISPLAY | Raster display |
\ DT_RASPRINTER | Raster printer |
\ DT_RASCAMERA  | Raster camera |
\ DT_CHARSTREAM | Character stream |
\ DT_METAFILE   | Metafile |
\ DT_DISPFILE   | Display file |
\ If the DC is the DC of an enhanced metafile,
\ the device technology is that of the referenced device as specified
\ to the CreateEnhMetaFile method. To determine whether it is an
\ enhanced metafile DC, use the GetObjectType method.
\  HORZSIZE  Width, in millimeters, of the physical screen.
\  VERTSIZE  Height, in millimeters, of the physical screen.
\  HORZRES  Width, in pixels, of the screen.
\  VERTRES  Height, in raster lines, of the screen.
\  LOGPIXELSX  Number of pixels per logical inch along the screen width. In a system
\ with multiple display monitors, this value is the same for all monitors.
\  LOGPIXELSY  Number of pixels per logical inch along the screen height. In a system
\ with multiple display monitors, this value is the same for all monitors.
\  BITSPIXEL  Number of adjacent color bits for each pixel.
\  PLANES  Number of color planes.
\  NUMBRUSHES  Number of device-specific brushes.
\  NUMPENS  Number of device-specific pens.
\  NUMFONTS  Number of device-specific fonts.
\  NUMCOLORS  Number of entries in the device's color table, if the device has a color
\ depth of no more than 8 bits per pixel. For devices with greater color depths,
\ 1 is returned.
\  ASPECTX  Relative width of a device pixel used for line drawing.
\  ASPECTY  Relative height of a device pixel used for line drawing.
\  ASPECTXY  Diagonal width of the device pixel used for line drawing.
\  PDEVICESIZE  Reserved.
\  CLIPCAPS  Flag that indicates the clipping capabilities of the device. If the device
\ can clip to a rectangle, it is 1. Otherwise, it is 0.
\  SIZEPALETTE  Number of entries in the system palette. This index is valid only if the
\ device driver sets the RC_PALETTE bit in the RASTERCAPS index and is available
\ only if the driver is compatible with 16-bit Windows.
\  NUMRESERVED  Number of reserved entries in the system palette. This index is valid only if
\ the device driver sets the RC_PALETTE bit in the RASTERCAPS index and is
\ available only if the driver is compatible with 16-bit Windows.
\  COLORRES  Actual color resolution of the device, in bits per pixel. This index is valid
\ only if the device driver sets the RC_PALETTE bit in the RASTERCAPS index and
\ is available only if the driver is compatible with 16-bit Windows.
\  PHYSICALWIDTH  For printing devices: the width of the physical page, in device units. For
\ example, a printer set to print at 600 dpi on 8.5-x11-inch paper has a physical
\ width value of 5100 device units. Note that the physical page is almost always
\ greater than the printable area of the page, and never smaller.
\  PHYSICALHEIGHT  For printing devices: the height of the physical page, in device units. For
\ example, a printer set to print at 600 dpi on 8.5-by-11-inch paper has a physical
\ height value of 6600 device units. Note that the physical page is almost always
\ greater than the printable area of the page, and never smaller.
\  PHYSICALOFFSETX  For printing devices: the distance from the left edge of the physical page to the
\ left edge of the printable area, in device units. For example, a printer set to
\ print at 600 dpi on 8.5-by-11-inch paper, that cannot print on the leftmost
\ 0.25-inch of paper, has a horizontal physical offset of 150 device units.
\  PHYSICALOFFSETY  For printing devices: the distance from the top edge of the physical page to the
\ top edge of the printable area, in device units. For example, a printer set to
\ print at 600 dpi on 8.5-by-11-inch paper, that cannot print on the topmost 0.5-inch
\ of paper, has a vertical physical offset of 300 device units.
\  VREFRESH  Windows NT/2000: For display devices: the current vertical refresh rate of the device,
\ in cycles per second (Hz).
\ A vertical refresh rate value of 0 or 1 represents the display hardware's default
\ refresh rate. This default rate is typically set by switches on a display card or
\ computer motherboard, or by a configuration program that does not use Win32 display
\ methods such as ChangeDisplaySettings.
\  SCALINGFACTORX  Scaling factor for the x-axis of the printer.
\  SCALINGFACTORY  Scaling factor for the y-axis of the printer.
\  BLTALIGNMENT  Windows NT/2000: Preferred horizontal drawing alignment, expressed as a multiple of
\ pixels. For best drawing performance, windows should be horizontally aligned to a
\ multiple of this value. A value of zero indicates that the device is accelerated,
\ and any alignment may be used.
\  SHADEBLENDCAPS  Windows 98, Windows 2000: Value that indicates the shading and blending capabilities
\ of the device.
\  SB_CONST_ALPHA  Handles the SourceConstantAlpha member of the BLENDFUNCTION structure,
\ which is referenced by the blendFunction parameter of the AlphaBlend method.
\ 
\ SB_GRAD_RECT     | Capable of doing GradientFill rectangles. |
\ SB_GRAD_TRI      | Capable of doing GradientFill triangles. |
\ SB_NONE          | Device does not support any of these capabilities. |
\ SB_PIXEL_ALPHA   | Capable of handling per-pixel alpha in AlphaBlend. |
\ SB_PREMULT_ALPHA | Capable of handling premultiplied alpha in AlphaBlend. |
\  RASTERCAPS  Value that indicates the raster capabilities of the device,
\ as shown in the following table.
\ 
\ RC_BANDING      | Requires banding support. |
\ RC_BITBLT       | Capable of transferring bitmaps. |
\ RC_BITMAP64     | Capable of supporting bitmaps larger than 64 KB. |
\ RC_DI_BITMAP    | Capable of supporting the SetDIBits and GetDIBits methods. |
\ RC_DIBTODEV     | Capable of supporting the SetDIBitsToDevice method. |
\ RC_FLOODFILL    | Capable of performing flood fills. |
\ RC_GDI20_OUTPUT | Capable of supporting features of 16-bit Windows 2.0. |
\ RC_PALETTE      | Specifies a palette-based device. |
\ RC_SCALING      | Capable of scaling. |
\ RC_STRETCHBLT   | Capable of performing the StretchBlt method. |
\ RC_STRETCHDIB   | Capable of performing the StretchDIBits method. |
\  CURVECAPS  Value that indicates the curve capabilities of the device, as shown
\ in the following table:
\ 
\ CC_NONE       | Device does not support curves. |
\ CC_CHORD      | Device can draw chord arcs. |
\ CC_CIRCLES    | Device can draw circles. |
\ CC_ELLIPSES   | Device can draw ellipses. |
\ CC_INTERIORS  | Device can draw interiors. |
\ CC_PIE        | Device can draw pie wedges. |
\ CC_ROUNDRECT  | Device can draw rounded rectangles. |
\ CC_STYLED     | Device can draw styled borders. |
\ CC_WIDE       | Device can draw wide borders. |
\ CC_WIDESTYLED | Device can draw borders that are wide and styled. |
\  LINECAPS  Value that indicates the line capabilities of the device, as
\ shown in the following table:
\ 
\ LC_NONE       | Device does not support lines. |
\ LC_INTERIORS  | Device can draw interiors. |
\ LC_MARKER     | Device can draw a marker. |
\ LC_POLYLINE   | Device can draw a polyline. |
\ LC_POLYMARKER | Device can draw multiple markers. |
\ LC_STYLED     | Device can draw styled lines. |
\ LC_WIDE       | Device can draw wide lines. |
\ LC_WIDESTYLED | Device can draw lines that are wide and styled. |
\  POLYGONALCAPS  Value that indicates the polygon capabilities of the device, as
\ shown in the following table.
\ 
\ PC_NONE        | Device does not support polygons. |
\ PC_INTERIORS   | Device can draw interiors. |
\ PC_POLYGON     | Device can draw alternate-fill polygons. |
\ PC_RECTANGLE   | Device can draw rectangles. |
\ PC_SCANLINE    | Device can draw a single scanline. |
\ PC_STYLED      | Device can draw styled borders. |
\ PC_WIDE        | Device can draw wide borders. |
\ PC_WIDESTYLED  | Device can draw borders that are wide and styled. |
\ PC_WINDPOLYGON | Device can draw winding-fill polygons. |
\  TEXTCAPS  Value that indicates the text capabilities of the device, as shown
\ in the following table.
\ 
\ TC_OP_CHARACTER | Device is capable of character output precision. |
\ TC_OP_STROKE    | Device is capable of stroke output precision. |
\ TC_CP_STROKE    | Device is capable of stroke clip precision. |
\ TC_CR_90        | Device is capable of 90-degree character rotation. |
\ TC_CR_ANY       | Device is capable of any character rotation. |
\ TC_SF_X_YINDEP  | Device can scale independently in the x- and y-directions. |
\ TC_SA_DOUBLE    | Device is capable of doubled character for scaling. |
\ TC_SA_INTEGER   | Device uses integer multiples only for character scaling. |
\ TC_SA_CONTIN    | Device uses any multiples for exact character scaling. |
\ TC_EA_DOUBLE    | Device can draw double-weight characters. |
\ TC_IA_ABLE      | Device can italicize. |
\ TC_UA_ABLE      | Device can underline. |
\ TC_SO_ABLE      | Device can draw strikeouts. |
\ TC_RA_ABLE      | Device can draw raster fonts. |
\ TC_VA_ABLE      | Device can draw vector fonts. |
\ TC_RESERVED     | Reserved; must be zero. |
\ TC_SCROLLBLT    | Device cannot scroll using a bit-block transfer. Note that this meaning may be the opposite of what you expect. |
\  COLORMGMTCAPS  Windows 2000: Value that indicates the color management capabilities of the device.
\ 
\ CM_CMYK_COLOR | Device can accept CMYK color space ICC color profile. |
\ CM_DEVICE_ICM | Device can perform ICM on either the device driver or the device itself. |
\ CM_GAMMA_RAMP | Device supports GetDeviceGammaRamp and SetDeviceGammaRamp |
\ CM_NONE       | Device does not support ICM. |
:M GETDIBCOLORTABLE: ( uStartIndex cEntries pColors -- ) 
\ The GetDIBColorTable method retrieves RGB (red, green, blue) color values from
\ a range of entries in the color table of the DIB section bitmap that is currently
\ selected into a specified device context.
\  uStartIndex  A zero-based color table index that specifies the first color table
\ entry to retrieve.
\  cEntries  Specifies the number of color table entries to retrieve.
\  pColors  Pointer to a buffer that receives an array of RGBQUAD data structures
\ containing color information from the DIB's color table. The buffer must be large
\ enough to contain as many RGBQUAD data structures as the value of cEntries.
\ The GetDIBColorTable method should be called to retrieve the color table for DIB
\ section bitmaps that use 1, 4, or 8 bpp. The biBitCount member of a bitmap's associated
\ BITMAPINFOHEADER structure specifies the number of bits-per-pixel. DIB section bitmaps
\ with a biBitCount value greater than eight do not have a color table, but they do have
\ associated color masks. Use the GetObject method to retrieve those color masks.
:M GETGRAPHICSMODE: ( -- mode ) 
\ The GetGraphicsMode method retrieves the current graphics mode for the
\ specified device context.
:M GETMAPMODE: ( -- MapMode ) 
\ The GetMapMode method retrieves the current mapping mode.
: GETOBJECTCOLOR { colorref -- colorref } 
:M GETPATH: ( lpPoints lpTypes nSize -- n ) 
\ The GetPath method retrieves the coordinates defining the endpoints of lines and the
\ control points of curves found in the path that is selected into the device context.
\  lpPoints  Pointer to an array of POINT structures that receives the line endpoints and
\ curve control points.
\  lpTypes  Pointer to an array of bytes that receives the vertex types.
\ This parameter can be one of the following values.
\  PT_MOVETO  Specifies that the corresponding point in the lpPoints parameter
\ starts a disjoint figure.
\  PT_LINETO  Specifies that the previous point and the corresponding point in
\ lpPoints are the endpoints of a line.
\  PT_BEZIERTO  Specifies that the corresponding point in lpPoints is a control
\ point or ending point for a Bzier curve.
\ PT_BEZIERTO values always occur in sets of three. The point in the path
\ immediately preceding them defines the starting point for the Bzier curve.
\ The first two PT_BEZIERTO points are the control points, and the third PT_BEZIERTO
\ point is the ending (if hard-coded) point.
\ A PT_LINETO or PT_BEZIERTO value may be combined with the following value (by
\ using the bitwise operator OR) to indicate that the corresponding point is the
\ last point in a figure and the figure should be closed. Flag Description
\ PT_CLOSEFIGURE Specifies that the figure is automatically closed after the
\ corresponding line or curve is drawn. The figure is closed by drawing a line
\ from the line or curve endpoint to the point corresponding to the last PT_MOVETO.
\  nSize  Specifies the total number of POINT structures that can be stored in the array pointed to
\ by lpPoints. This value must be the same as the number of bytes that can be placed in the
\ array pointed to by lpTypes.
\ If the nSize parameter is nonzero, the return value is the number of points enumerated. If nSize
\ is 0, the return value is the total number of points in the path (and GetPath writes nothing to
\ the buffers). If nSize is nonzero and is less than the number of points in the path, the return
\ value is -1.
:M GETPENCOLOR: ( -- colorref ) 
\ The GetPenColor method retrieves the current pen color for the specified
\ device context.
\ Only for Windows 2000 and later
:M GETPOLYFILLMODE: ( -- iPolyFillMode ) 
\ The GetPolyFillMode method retrieves the current polygon fill mode.
\ If the method succeeds, the return value specifies the polygon fill mode,
\ which can be one of the following values.
\ 
\ ALTERNATE | Selects alternate mode (fills the area between odd-numbered and even-numbered polygon sides on each scan line). |
\ WINDING   | Selects winding mode (fills any region with a nonzero winding value). |
\ If an error occurs, the return value is zero.
:M GETROP: ( -- nDrawMode ) 
\ The GetROP method retrieves the foreground mix mode of the specified device context.
\ The mix mode specifies how the pen or interior color and the color already on the screen
\ are combined to yield a new color.
:M GETSTOCKOBJECT: ( nObject -- hObject ) 
\ The GetStockObject method retrieves a handle to one of the stock pens, brushes,
\ fonts, or palettes.
\  nObject  Specifies the type of stock object. This parameter can be one of the following
\ values:
\ 
\ BLACK_BRUSH      | Black brush. |
\ DKGRAY_BRUSH     | Dark gray brush. |
\ DC_BRUSH         | Windows 98, Windows 2000: Solid color brush. The default color is white. The color can be changed by using the SetDCBrushColor method. |
\ GRAY_BRUSH       | Gray brush. |
\ HOLLOW_BRUSH     | Hollow brush (equivalent to NULL_BRUSH). |
\ LTGRAY_BRUSH     | Light gray brush. |
\ NULL_BRUSH       | Null brush (equivalent to HOLLOW_BRUSH). |
\ WHITE_BRUSH      | White brush. |
\ BLACK_PEN        | Black pen. |
\ DC_PEN           | Windows 98, Windows 2000: Solid pen color. The default color is white. The color can be changed by using the SetDCPenColor method. |
\ WHITE_PEN        | White pen. |
\ ANSI_FIXED_FONT  | Windows fixed-pitch (monospace) system font. |
\ ANSI_VAR_FONT    | Windows variable-pitch (proportional space) system font. |
\ DEVICE_DEFAULT_FONT | Windows NT/2000: Device-dependent font. |
\ DEFAULT_GUI_FONT | Default font for user interface objects such as menus and dialog boxes. This is MS Sans Serif. Compare this with SYSTEM_FONT. |
\ OEM_FIXED_FONT   | Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font. |
\ SYSTEM_FONT      | System font. By default, the system uses the system font to draw menus, dialog box controls, and text. Windows 95/98 and NT: The system font is MS Sans Serif. Windows 2000: The system font is Tahoma |
\ SYSTEM_FIXED_FONT | Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0. |
\ DEFAULT_PALETTE  | Default palette. This palette consists of the static colors in the system palette. |
:M GETTABSIZE: ( -- n1 ) 
\ Get the width of a tab.
:M GETTEXTALIGN: ( -- fMode ) 
\ The GetTextAlign method retrieves the text-alignment setting for the specified
\ device context. If the method fails, the return value is GDI_ERROR.
:M GETTEXTCHARACTEREXTRA: ( -- CharExtra ) 
\ The GetTextCharacterExtra method retrieves the current intercharacter spacing
\ for the specified device context.
:M GETTEXTCOLOR: ( -- colorref ) 
\ The GetTextColor method retrieves the current text color for the specified
\ device context.
:M GETTEXTEXTENT: ( addr len -- width height ) 
\ The GetTextExtent method computes the width and height of the specified
\ string of text.
:M GETTEXTMETRICS: ( -- addr len ) 
\ The GetTextMetrics method fills the specified buffer with the metrics for the
\ currently selected font.
\ Returns the address and length of the textmetric struct.
:M GETVIEWPORTEXT: ( -- x y ) 
\ The GetViewportExt method retrieves the x-extent and y-extent of the current viewport
\ for the specified device context.
:M GETVIEWPORTORG: ( -- x y ) 
\ The GetViewportOrg method retrieves the x-coordinates and y-coordinates of the viewport
\ origin for the specified device context.
:M GETWINDOWEXT: ( -- x y ) 
\ This method retrieves the x-extent and y-extent of the window for the specified
\ device context.
:M GETWINDOWORG: ( -- x y ) 
\ The GetWindowOrg method retrieves the x-coordinates and y-coordinates of the window
\ origin for the specified device context.
: INITRECT ( left top right bottom hBrush -- hBrush &rect ) 
:M INVERTRECT: ( left top right bottom  -- ) 
\ The InvertRect method inverts a rectangle in a window by performing a
\ logical NOT operation on the color values for each pixel in the rectangle's
\ interior.
:M LINETO: ( nXEnd nYEnd -- ) 
\ The LineTo method draws a line from the current position up to, but not
\ including, the specified point.
\ The coordinates of the line's ending point are specified in logical units.
\ The line is drawn by using the current pen and, if the pen is a geometric pen,
\ the current brush.
\ If LineTo succeeds, the current position is set to the specified ending point.
:M LPTODP: ( lpPoints nCount -- ) 
\ The LPtoDP method converts logical coordinates into device coordinates. The
\ conversion depends on the mapping mode of the device context, the settings of the
\ origins and extents for the window and viewport, and the world transformation.
\  lpPoints  [in/out] Pointer to an array of POINT structures. The x- and y-coordinates
\ contained in each POINT structure will be transformed.
\  nCount  [in] Specifies the number of points in the array.
\ This method fails if the logical coordinates exceed 32 bits, or if the converted
\ device coordinates exceed 27 bits. In the case of such an overflow, the results for
\ all the points are undefined.
:M MOVETO: ( x y -- x1 x2 ) 
\ The MoveTo method updates the current position to the specified point and
\ returns the previous position.
:M OFFSETVIEWPORTORG: ( xOffest yOffset - xOffset1 yOffset1 ) 
\ The OffsetViewportOrg method modifies the viewport origin for a device context using
\ the specified horizontal and vertical offsets.
\ The new origin is the sum of the current origin and the horizontal and vertical offsets.
\  xOffset  Specifies the horizontal offset, in device units.
\  YOffset  Specifies the vertical offset, in device units.
:M OFFSETWINDOWORG: ( xOffest yOffset - xOffset1 yOffset1 ) 
\ The OffsetWindowOrg method modifies the window origin for a device context using the
\ specified horizontal and vertical offsets.
\  XOffset  Specifies the horizontal offset, in logical units.
\  YOffset  Specifies the vertical offset, in logical units.
:M PATHTOREGION: ( -- ) 
\ The PathToRegion method creates a region from the path that is selected into the specified
\ device context. The resulting region uses device coordinates.
\ After PathToRegion converts a path into a region, the system discards the closed path from the
\ device context.
:M PIE: ( nLeftRect nTopRect nRightRect nBottomRect nXRadial1 nYRadial1 nXRadial2 nYRadial2 -- ) 
\ The Pie method draws a pie-shaped wedge bounded by the intersection of
\ an ellipse and two radials.
\  nLeftRect  x-coord of upper-left corner of rectangle
\  nTopRect  y-coord of upper-left corner of rectangle
\  nRightRect  x-coord of lower-right corner of rectangle
\  nBottomRect  y-coord of lower-right corner of rectangle
\  nXRadial1  x-coord of first radial's endpoint
\  nYRadial1  y-coord of first radial's endpoint
\  nXRadial2  x-coord of second radial's endpoint
\  nYRadial2  y-coord of second radial's endpoint
GDIPOINT POINT 
:M POLYBEZIER: ( pPoints cPoints -- ) 
\ The PolyBezier method draws one or more Bzier curves.
\  pPoints  Pointer to an array of POINT structures that contain the endpoints
\ and control points of the curve(s).
\  cPoints  Specifies the number of points in the pPoints array. This value must
\ be one more than three times the number of curves to be drawn, because each
\ Bzier curve requires two control points and an endpoint, and the initial
\ curve requires an additional starting point.
\ The Polybezier method draws cubic Bzier curves by using the endpoints and
\ control points specified by the pPoints parameter. The first curve is drawn from
\ the first point to the fourth point by using the second and third points as
\ control points. Each subsequent curve in the sequence needs exactly three more
\ points: the ending point of the previous curve is used as the starting point,
\ the next two points in the sequence are control points, and the third is the
\ ending point.
\ The current position is neither used nor updated by the PolyBezier method.
\ The figure is not filled. This method draws lines by using the current pen.
:M POLYBEZIERTO: ( pPoints cPoints -- ) 
\ The PolyBezierTo method draws one or more Bzier curves.
\  pPoints  Pointer to an array of POINT structures that contains the endpoints
\ and control points.
\  cPoints  Specifies the number of points in the pPoints array. This value must be
\ three times the number of curves to be drawn, because each Bzier curve requires
\ two control points and an ending point.
\ This method draws cubic Bzier curves by using the control points specified by
\ the pPoints parameter. The first curve is drawn from the current position to the
\ third point by using the first two points as control points. For each subsequent
\ curve, the method needs exactly three more points, and uses the ending point
\ of the previous curve as the starting point for the next.
\ PolyBezierTo moves the current position to the ending point of the last Bzier curve.
\ The figure is not filled. This method draws lines by using the current pen.
:M POLYGON: ( lpPoints nCount -- ) 
\ The Polygon method draws a polygon consisting of two or more vertices
\ connected by straight lines. The polygon is outlined by using the current
\ pen and filled by using the current brush and polygon fill mode.
\  lpPoints  polygon vertices
\  nCount  count of polygon vertices
:M POLYLINE: ( pPoints cPoints -- ) 
\ The Polyline method draws a series of line segments by connecting the points
\ in the specified array.
\  pPoints  Pointer to an array of POINT structures. Each structure in the array
\ identifies a point in logical space.
\  cPoints  Specifies the number of points in the array. This number must be greater
\ than or equal to two.
\ The lines are drawn from the first point through subsequent points by using the
\ current pen. Unlike the LineTo method, the Polyline method neither uses nor
\ updates the current position.
:M POLYLINETO: ( pPoints cPoints -- ) 
\ The PolylineTo method draws one or more straight lines.
\  pPoints  Pointer to an array of POINT structures that contains the vertices of
\ the line.
\  cCount  Specifies the number of points in the array.
\ A line is drawn from the current position to the first point specified by the
\ pPoints parameter by using the current pen. For each additional line, the method
\ draws from the ending point of the previous line to the next point specified by
\ pPoints.
\ PolylineTo moves the current position to the ending point of the last line.
\ If the line segments drawn by this method form a closed figure, the figure is
\ not filled.
:M POLYPOLYGON: ( lpPoints lpPolyCounts nCount -- ) 
\ The PolyPolygon method draws a series of closed polygons. Each polygon
\ is outlined by using the current pen and filled by using the current brush
\ and polygon fill mode. The polygons drawn by this method can overlap.
\  lpPoints  array of vertices
\  lpPolyCounts  array of count of vertices
\  nCount  count of polygons
RECTANGLE RECT 
:M RECTANGLE: ( nLeftRect nTopRect nRightRect nBottomRect -- ) 
\ The Rectangle method draws a rectangle.
\  nLeftRect  x-coord of upper-left corner of rectangle
\  nTopRect  y-coord of upper-left corner of rectangle
\  nRightRect  x-coord of lower-right corner of rectangle
\  nBottomRect  y-coord of lower-right corner of rectangle
:M RESTORE: ( SavedState -- ) 
\ The Restore method restores the device context to the specified state.
\ The DC is restored by popping state information off a stack created by
\ earlier calls to the Save method.
:M ROUNDRECT: ( nLeftRect nTopRect nRightRect nBottomRect nWidth nHeight -- ) 
\ The RoundRect method draws a rectangle with rounded corners.
\  nLeftRect  x-coord of upper-left corner of rectangle
\  nTopRect  y-coord of upper-left corner of rectangle
\  nRightRect  x-coord of lower-right corner of rectangle
\  nBottomRect  y-coord of lower-right corner of rectangle
\  nWidth  width of ellipse
\  nHeight  height of ellipse
:M SAVE: ( -- SavedState ) 
\ The Save method saves the current state of the device context by copying
\ data describing selected objects and graphic modes (such as the bitmap,
\ brush, palette, font, pen, region, drawing mode, and mapping mode) to a
\ context stack.
:M SCALEVIEWPORTEXT: ( Xnum Xdenom Ynum Ydenom -- x y ) 
\ The ScaleViewportExt method modifies the viewport for a device context using the
\ ratios formed by the specified multiplicands and divisors.
\ It returns the the previous viewport extents, in device units.
\ The viewport extents are modified as follows:
\       xNewVE = (xOldVE * Xnum) / Xdenom
\       yNewVE = (yOldVE * Ynum) / Ydenom
:M SCALEWINDOWEXTEX: ( Xnum Xdenom Ynum Ydenom -- x y ) 
\ The ScaleWindowExt method modifies the window for a device context using the ratios
\ formed by the specified multiplicands and divisors.
\ It returns the the previous window extents, in logical units.
\ The window extents are modified as follows:
\       xNewWE = (xOldWE * Xnum) / Xdenom
\       yNewWE = (yOldWE * Ynum) / Ydenom
:M SELECTOBJECT: ( hGdiObject -- hOldObject ) 
\ The SelectObject method selects an object into the device context.
\ The new object replaces the previous object of the same type.
\ If the selected object is not a region and the method succeeds, the
\ return value is a handle to the object being replaced. If the selected
\ object is a region and the method succeeds, the return value is one
\ of the following values:
\ 
\ SIMPLEREGION  | Region consists of a single rectangle. |
\ COMPLEXREGION | Region consists of more than one rectangle. |
\ NULLREGION    | Region is empty. |
\ If an error occurs and the selected object is not a region, the return
\ value is NULL. Otherwise, it is GDI_ERROR.
\ Note:  hGdiObject  can be a valid GDI object handle or the address of a
\ GdiObject class !
:M SELECTSTOCKOBJECT: ( nObject -- hOldObject ) 
\ The SelectStockObject method selects one of the stock pens, brushes, fonts, or
\ palettes into the the device context.
\  nObject  Specifies the type of stock object. This parameter can be one of the following
\ values. (see GetStockObject:)
:M SETARCDIRECTION: ( Direction -- OldDirection ) 
\ SetArcDirection sets the drawing direction to be used for arc and
\ rectangle methods. Possible value for  Direction  are:
\ 
\ AD_COUNTERCLOCKWISE | Figures drawn counterclockwise. |
\ AD_CLOCKWISE        | Figures drawn clockwise. |
\ Only for Windows 98 and better.
:M SETBACKGROUNDCOLOR: ( colorref -- PreviousColorref ) 
\ The SetBackgroundColor method sets the current background color to the
\ specified color value, or to the nearest physical color if the device cannot
\ represent the specified color value.
\ Note:  colorref  can be a 'simple' colorref or the address of a pPen Object class !
:M SETBACKGROUNDMODE: ( fMode -- fPreviousMode ) 
\ The SetBackgroundMode method sets the background mix mode of the specified
\ device context. The background mix mode is used with text, hatched brushes,
\ and pen styles that are not solid lines. Possible values for  fMode  are:
\ 
\ OPAQUE      | Background is filled with the current background color before the text, hatched brush, or pen is drawn. |
\ TRANSPARENT | Background remains untouched. |
:M SETBRUSHCOLOR: ( colorref -- previous-colorref ) 
\ SetBrushColor method sets the current device context brush color to the
\ specified color value. If the device cannot represent the specified color value,
\ the color is set to the nearest physical color.
\ If the method succeeds, the return value specifies the previous DC brush color
\ as a COLORREF value. If the method fails, the return value is CLR_INVALID.
\ Only for Windows 2000 and later
:M SETDIBCOLORTABLE: ( uStartIndex cEntries pColors -- ) 
\ The SetDIBColorTable method sets RGB (red, green, blue) color values in a range
\ of entries in the color table of the DIB that is currently selected into a specified
\ device context.
\  uStartIndex  A zero-based color table index that specifies the first color table
\ entry to set.
\  cEntries  Specifies the number of color table entries to set.
\  pColors  Pointer to an array of RGBQUAD structures containing new color information
\ for the DIB's color table.
:M SETGRAPHICSMODE: ( Mode -- PreviousMode ) 
\ The SetGraphicsMode method sets the graphics mode for the specified device context.
\ Possible Values for Mode:
\  GM_COMPATIBLE  Sets the graphics mode that is compatible with 16-bit Windows. This is
\ the default mode. If this value is specified, the application can only
\ modify the world-to-device transform by calling methods that set window
\ and viewport extents and origins, but not by using SetWorldTransform or
\ ModifyWorldTransform; calls to those methods will fail. Examples of
\ methods that set window and viewport extents and origins are SetViewportExtEx
\ and SetWindowExt.
\  GM_ADVANCED  Windows NT/ 2000: Sets the advanced graphics mode that allows world
\ transformations. This value must be specified if the application will set
\ or modify the world transformation for the specified device context. In
\ this mode all graphics, including text output, fully conform to the
\ world-to-device transformation specified in the device context.
\ Windows 95/98: The GM_ADVANCED value is not supported. When playing enhanced
\ metafiles, Windows 95/98 attempts to make enhanced metafiles on Windows 95/98
\ look the same as they do on Windows NT/Windows 2000. To accomplish this, Windows
\ 95/98 may simulate GM_ADVANCED mode when playing specific enhanced metafile records.
\ NOTE: Currently this class libary doesn't support wold transformation for the DC !
\ That means: CombineTransform(), GetWorldTransform(), ModifyWorldTransform() and
\ SetWorldTransform() are not supported at the moment.
:M SETMAPMODE: ( MapMode -- PerviousMapMode ) 
\ The SetMapMode method sets the mapping mode of the specified device context.
\ The mapping mode defines the unit of measure used to transform page-space units
\ into device-space units, and also defines the orientation of the device's x and y
\ axes. Possible Values for MapMode are:
\  MM_ANISOTROPIC  Logical units are mapped to arbitrary units with arbitrarily scaled
\ axes. Use the SetWindowExt and SetViewportExt methods to specify
\ the units, orientation, and scaling.
\  MM_HIENGLISH  Each logical unit is mapped to 0.001 inch. Positive x is to the right;
\ positive y is up.
\  MM_HIMETRIC  Each logical unit is mapped to 0.01 millimeter. Positive x is to the
\ right; positive y is up.
\  MM_ISOTROPIC  Logical units are mapped to arbitrary units with equally scaled axes;
\ that is, one unit along the x-axis is equal to one unit along the y-axis.
\ Use the SetWindowExt and SetViewportExt methods to specify the units
\ and the orientation of the axes. Graphics device interface (GDI) makes
\ adjustments as necessary to ensure the x and y units remain the same size
\ (When the window extent is set, the viewport will be adjusted to keep the
\ units isotropic).
\  MM_LOENGLISH  Each logical unit is mapped to 0.01 inch. Positive x is to the right;
\ positive y is up.
\  MM_LOMETRIC  Each logical unit is mapped to 0.1 millimeter. Positive x is to the right;
\ positive y is up.
\  MM_TEXT  Each logical unit is mapped to one device pixel. Positive x is to the right;
\ positive y is down.
\  MM_TWIPS  Each logical unit is mapped to one twentieth of a printer's point (1/1440 inch,
\ also called a twip). Positive x is to the right; positive y is up.
:M SETPENCOLOR: ( colorref -- previous-colorref ) 
\ SetPenColor method sets the current device context pen color to the
\ specified color value. If the device cannot represent the specified color value,
\ the color is set to the nearest physical color.
\ If the method succeeds, the return value specifies the previous DC pen color
\ as a COLORREF value. If the method fails, the return value is CLR_INVALID.
\ Only for Windows 2000 and later
:M SETPOLYFILLMODE: ( iPolyFillMode -- ) 
\ The SetPolyFillMode method sets the polygon fill mode for methods
\ that fill polygons.
\  iPolyFillMode  Specifies the new fill mode. This parameter can be one
\ of the following values.
\ 
\ ALTERNATE | Selects alternate mode (fills the area between odd-numbered and even-numbered polygon sides on each scan line). |
\ WINDING   | Selects winding mode (fills any region with a nonzero winding value). |
:M SETROP: ( nDrawMode -- nPreviousDrawMode ) 
\ The SetROP method sets the current foreground mix mode. GDI uses the foreground
\ mix mode to combine pens and interiors of filled objects with the colors already
\ on the screen. The foreground mix mode defines how colors from the brush or pen
\ and the colors in the existing image are to be combined.
\  nDrawMode  Specifies the mix mode. This parameter can be one of the following values. Mix mode Description
\ 
\ R2_BLACK       | Pixel is always 0. |
\ R2_COPYPEN     | Pixel is the pen color. |
\ R2_MASKNOTPEN  | Pixel is a combination of the colors common to both the screen and the inverse of the pen. |
\ R2_MASKPEN     | Pixel is a combination of the colors common to both the pen and the screen. |
\ R2_MASKPENNOT  | Pixel is a combination of the colors common to both the pen and the inverse of the screen. |
\ R2_MERGENOTPEN | Pixel is a combination of the screen color and the inverse of the pen color. |
\ R2_MERGEPEN    | Pixel is a combination of the pen color and the screen color. |
\ R2_MERGEPENNOT | Pixel is a combination of the pen color and the inverse of the screen color. |
\ R2_NOP         | Pixel remains unchanged. |
\ R2_NOT         | Pixel is the inverse of the screen color. |
\ R2_NOTCOPYPEN  | Pixel is the inverse of the pen color. |
\ R2_NOTMASKPEN  | Pixel is the inverse of the R2_MASKPEN color. |
\ R2_NOTMERGEPEN | Pixel is the inverse of the R2_MERGEPEN color. |
\ R2_NOTXORPEN   | Pixel is the inverse of the R2_XORPEN color. |
\ R2_WHITE       | Pixel is always 1. |
\ R2_XORPEN      | Pixel is a combination of the colors in the pen and in the screen, but not in both. |
:M SETTABS: ( a1 n1 -- ) 
\ Set tab positions. a1 is array of cells with offsets
:M SETTABSIZE: ( n1 -- n2 ) 
\ Set the width of a tab. Returns the old width.
:M SETTEXTALIGN: ( fMode -- fPreviousMode ) 
\ The SetTextAlign method sets the text-alignment flags for the
\ device context.
\  fMode  Specifies the text alignment by using a mask of the values in the
\ following list. Only one flag can be chosen from those that affect horizontal
\ and vertical alignment. In addition, only one of the two flags that alter
\ the current position can be chosen.
\ 
\ TA_BASELINE   | The reference point will be on the base line of the text. |
\ TA_BOTTOM     | The reference point will be on the bottom edge of the bounding rectangle. |
\ TA_TOP        | The reference point will be on the top edge of the bounding rectangle. |
\ TA_CENTER     | The reference point will be aligned horizontally with the center of the bounding rectangle. |
\ TA_LEFT       | The reference point will be on the left edge of the bounding rectangle. |
\ TA_RIGHT      | The reference point will be on the right edge of the bounding rectangle. |
\ TA_NOUPDATECP | The current position is not updated after each text output call. The reference point is passed to the text output method. |
\ TA_RTLREADING | Middle-Eastern Windows: The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic. |
\ TA_UPDATECP   | The current position is updated after each text output call. The current position is used as the reference point. |
\ When the current font has a vertical default base line, as with Kanji, the following
\ values must be used instead of TA_BASELINE and TA_CENTER.
\ 
\ VTA_BASELINE | The reference point will be on the base line of the text. |
\ VTA_CENTER   | The reference point will be aligned vertically with the center of the bounding rectangle. |
\ The default values are TA_LEFT, TA_TOP, and TA_NOUPDATECP.
\ If the method fails, the return value is GDI_ERROR.
:M SETTEXTCHARACTEREXTRA: ( CharExtra -- OldCharExtra ) 
\ The SetTextCharacterExtra method sets the intercharacter spacing. Intercharacter
\ spacing is added to each character, including break characters, when the system
\ writes a line of text.
\  CharExtra  Specifies the amount of extra space, in logical units, to be added to
\ each character. If the current mapping mode is not MM_TEXT, the nCharExtra parameter
\ is transformed and rounded to the nearest pixel.
:M SETTEXTCOLOR: ( colorref -- PreviousColorref ) 
\ The SetTextColor method sets the text color for the specified device context
\ to the specified color.
\ Note:  colorref  can be a 'simple' colorref or the address of a pPen Object class !
:M SETVIEWPORTEXT: ( XExtent yExtent -- XExtent1 yExtent1 ) 
\ The SetViewportExt method sets the horizontal and vertical extents of the viewport
\ for a device context by using the specified values.
:M SETVIEWPORTORG: ( x y - x1 y1 ) 
\ The SetViewportOrg method specifies which device point maps to the window origin (0,0).
\ This method (along with SetViewportExt and SetWindowExt) helps define the mapping from
\ the logical coordinate space (also known as a window) to the device coordinate space (the
\ viewport). SetViewportOrg specifies which device point maps to the logical point (0,0).
\ It has the effect of shifting the axes so that the logical point (0,0) no longer refers to
\ the upper-left corner.
\ This is related to the SetViewportOrg method. Generally, you will use one method or the
\ other, but not both. Regardless of your use of SetWindowOrg and SetViewportOrg, the device
\ point (0,0) is always the upper-left corner.
:M SETWINDOWEXT: ( XExtent YExtent -- XExtent1 YExtent1 ) 
\ The SetWindowExt method sets the horizontal and vertical extents of the window for
\ a device context by using the specified values.
\  XExtent  Specifies the window's horizontal extent in logical units.
\  YExtent  Specifies the window's vertical extent in logical units.
:M SETWINDOWORG: ( x y -- x1 y1 ) 
\ The SetWindowOrg method specifies which window point maps to the viewport origin (0,0).
\ This helps define the mapping from the logical coordinate space (also known as a window) to
\ the device coordinate space (the viewport). SetWindowOrg specifies which logical point maps
\ to the device point (0,0). It has the effect of shifting the axes so that the logical point
\ (0,0) no longer refers to the upper-left corner.
\ This is related to the SetViewportOrg method. Generally, you will use one method or the
\ other, but not both. Regardless of your use of SetWindowOrg and SetViewportOrg, the device
\ point (0,0) is always the upper-left corner.
GDISIZE SIZE 
:M STROKEANDFILLPATH: ( -- ) 
\ The StrokeAndFillPath method closes any open figures in a path, strokes the outline of the
\ path by using the current pen, and fills its interior by using the current brush.
\ The StrokeAndFillPath method has the same effect as closing all the open figures in the path,
\ and stroking and filling the path separately, except that the filled region will not overlap the
\ stroked region even if the pen is wide.
:M STROKEPATH: ( -- ) 
\ The StrokePath method renders the specified path by using the current pen.
BYTES TABARRAY 
:M TABBEDTEXTOUT: ( x y addr len -- width height ) 
\ The TabbedTextOut method writes a character string at a specified
\ location, expanding tabs to the values specified in an array of tab-stop
\ positions. Text is written in the currently selected font, background
\ color, and text color.
\ If the method succeeds, the return value is the dimensions, in logical
\ units, of the string.
INT TABBUF 
INT TABCNT 
INT TABWIDTH 
GDITEXTMETRIC TEXTMETRIC 
:M TEXTOUT: ( x y addr len -- ) 
\ The TextOut method writes a character string at the specified location,
\ using the currently selected font, background color, and text color.
:M WIDENPATH: ( -- ) 
\ The WidenPath function redefines the current path as the area that would be painted if the path
\ were stroked using the pen currently selected into the given device context.
\ The WidenPath function is successful only if the current pen is a geometric pen created by the
\ ExtCreatePen function, or if the pen is created with the CreatePen function and has a width, in
\ device units, of more than one.
\ The device context must contain a closed path.
\ Any Bzier curves in the path are converted to sequences of straight lines approximating the
\ widened curves. As such, no Bzier curves remain in the path after WidenPath is called.
RECORD: &CHOOSEFONT 
: CHOOSE ( hWnd -- f ) 
:M CHOOSE: ( hWnd -- f ) 
\ Open a dialog to choose a Screen font. If the dialog is closed with OK, the font
\ will be created.
:M CHOOSEPRINTER: ( hWnd hDC -- f ) 
\ Open a dialog to choose a Printer font for the PrinterDC hDC. If the dialog is closed
\ with OK, the fontwill be created.
:M CLASSINIT: ( -- ) 
:M CREATE: ( -- f ) 
\ Create a new font. If the current font handle is valid, the font will be destroyed.
INT FLAGS 
:CLASS GDIFONT 
:CLASS GDIFONT 
:M GETCHARSET: ( -- n1 ) 
\ Get the character set.
:M GETCLIPPRECISION: ( -- n1 ) 
\ Get the clipping precision
:M GETESCAPEMENT: ( -- n1 ) 
\ Get the angle, in tenths of degrees, between the escapement vector and the x-axis of
\ the device. The escapement vector is parallel to the base line of a row of text.
:M GETFACENAME: ( -- a1 n1 ) 
\ Get the typeface name of the font.
:M GETHEIGHT: ( -- n1 ) 
\ Fet the height, in logical units, of the font's character cell or character
:M GETITALIC: ( -- f1 ) 
\ TRUE if it's an italic font.
:M GETLOGFONT: ( -- n1 ) 
\ Get the address of the LOGFONT structure
:M GETORIENTATION: ( -- n1 ) 
\ Get the angle, in tenths of degrees, between each character's base line and the x-axis of the device.
:M GETOUTPRECISION: ( -- n1 ) 
\ Get the output precision.
:M GETPITCHANDFAMILY: ( -- n1 ) 
\ Get the pitch and family of the font.
:M GETQUALITY: ( -- n1 ) 
\ Get the output quality.
:M GETSTRIKEOUT: ( -- f1 ) 
\ TRUE if it's a strikeout font.
:M GETUNDERLINE: ( -- f1 ) 
\ TRUE if it's a underlined font.
:M GETWEIGHT: ( -- n1 ) 
\ Get the weight of the font
:M GETWIDTH: ( -- n1 ) 
\ Get the average width, in logical units, of characters in the font
INT HDC 
INT HINSTANCE 
INT HWNDOWNER 
INT IPOINTSIZE 
INT LCUSTDATA 
BYTE LFCHARSET 
BYTE LFCLIPPRECISION 
INT LFESCAPEMENT 
BYTES LFFACENAME \ the font name
INT LFHEIGHT \ width  in pixels, device specific
BYTE LFITALIC \ TRUE/FALSE
INT LFORIENTATION \ in 10ths of a degree
BYTE LFOUTPRECISION 
BYTE LFPITCHANDFAMILY 
BYTE LFQUALITY 
BYTE LFSTRIKEOUT \ TRUE/FALSE
BYTE LFUNDERLINE \ TRUE/FALSE
INT LFWEIGHT 
INT LFWIDTH \ height in pixels, device specific
RECORD: LOGFONT 
INT LPFNHOOK 
INT LPLOGFONT 
INT LPSZSTYLE 
INT LPTEMPLATENAME 
INT LSTRUCTSIZE 
SHORT NFONTTYPE 
INT NSIZEMAX 
INT NSIZEMIN 
INT RGBCOLORS 
:M SETCHARSET: ( n1 -- ) 
\ Specifies the character set. The following values are predefined.
\ 
\ ANSI_CHARSET        |
\ BALTIC_CHARSET      |
\ CHINESEBIG5_CHARSET |
\ DEFAULT_CHARSET     |
\ EASTEUROPE_CHARSET  |
\ GB2312_CHARSET      |
\ GREEK_CHARSET       |
\ HANGUL_CHARSET      |
\ MAC_CHARSET         |
\ OEM_CHARSET         |
\ RUSSIAN_CHARSET     |
\ SHIFTJIS_CHARSET    |
\ SYMBOL_CHARSET      |
\ TURKISH_CHARSET     |
\ Windows NT/ 2000 or Middle-Eastern Windows 3.1 or later:
\ 
\ HEBREW_CHARSET |
\ ARABIC_CHARSET |
\ Windows NT/ 2000 or Thai Windows 3.1 or later:
\ 
\ THAI_CHARSET |
\ The OEM_CHARSET value specifies a character set that is operating-system dependent.
\ Windows 95/98: You can use the DEFAULT_CHARSET value to allow the name and size of a font
\ to fully describe the logical font. If the specified font name does not exist, a font from
\ any character set can be substituted for the specified font, so you should use DEFAULT_CHARSET
\ sparingly to avoid unexpected results. 
\ Windows NT/ 2000: DEFAULT_CHARSET is set to a value based on the current system locale. For
\ example, when the system locale is English (United States), it is set as ANSI_CHARSET. 
\ Fonts with other character sets may exist in the operating system. If an application uses a
\ font with an unknown character set, it should not attempt to translate or interpret strings
\ that are rendered with that font. 
\ This parameter is important in the font mapping process. To ensure consistent results, specify
\ a specific character set. If you specify a typeface name in the lfFaceName member, make sure
\ that the lfCharSet value matches the character set of the typeface specified in lfFaceName.
:M SETCLIPPRECISION: ( n1 -- ) 
\ Specifies the clipping precision. The clipping precision defines how to clip characters that are partially
\ outside the clipping region. It can be one or more of the following values.
\ 
\ CLIP_DEFAULT_PRECIS   | Specifies default clipping behavior. |
\ CLIP_CHARACTER_PRECIS | Not used. |
\ CLIP_EMBEDDED         | You must specify this flag to use an embedded read-only font. |
\ CLIP_LH_ANGLES        | When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.
\ For more information about the orientation of coordinate systems, see the description of the nOrientation parameter |
:M SETESCAPEMENT: ( n1 -- ) 
\ Set the angle, in tenths of degrees, between the escapement vector and the x-axis of the device.
\ The escapement vector is parallel to the base line of a row of text. 
\ Windows NT/ 2000: When the graphics mode is set to GM_ADVANCED, you can specify the escapement
\ angle of the string independently of the orientation angle of the string's characters. 
\ When the graphics mode is set to GM_COMPATIBLE, lfEscapement specifies both the escapement and
\ orientation. You should set lfEscapement and lfOrientation to the same value. 
\ Windows 95: The lfEscapement member specifies both the escapement and orientation. You should set
\ lfEscapement and lfOrientation to the same value.
:M SETFACENAME: ( a1 n1 -- ) 
\ Specifies the typeface name of the font. The length of this string must not exceed 32 characters, including
\ the null terminator. The EnumFontFamilies function can be used to enumerate the typeface names of all
\ currently available fonts. If lfFaceName is an empty string, GDI uses the first font that matches the other
\ specified attributes.
:M SETHEIGHT: ( n1 -- ) 
\ Set the height, in logical units, of the font's character cell or character. The character
\ height value (also known as the em height) is the character cell height value minus the
\ internal-leading value. The font mapper interprets the value specified in lfHeight in the
\ following manner.
\ 
\ > 0 | The font mapper transforms this value into device units and matches it against the cell height of the available fonts. |
\ 0   | The font mapper uses a default height value when it searches for a match. |
\ < 0 | The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts. |
\ For all height comparisons, the font mapper looks for the largest font that does not exceed
\ the requested size. This mapping occurs when the font is used for the first time.
:M SETITALIC: ( f1 -- ) 
\ Specifies an italic font if set to TRUE.
:M SETORIENTATION: ( n1 -- ) 
\ Set the angle, in tenths of degrees, between each character's base line and the x-axis of the device.
:M SETOUTPRECISION: ( n1 -- ) 
\ Specifies the output precision. The output precision defines how closely the output must match
\ the requested font's height, width, character orientation, escapement, pitch, and font type. It can
\ be one of the following values.
\ 
\ OUT_CHARACTER_PRECIS Not used.
\ OUT_DEFAULT_PRECIS | Specifies the default font mapper behavior. |
\ OUT_DEVICE_PRECIS  | Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name. |
\ OUT_OUTLINE_PRECIS | Windows NT/ 2000: This value instructs the font mapper to choose from TrueType and other outline-based fonts. |
\ OUT_RASTER_PRECIS  | Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name. |
\ OUT_TT_ONLY_PRECIS | Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior. |
\ OUT_TT_PRECIS      | Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name. |
\ Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, and OUT_TT_PRECIS values to control
\ how the font mapper chooses a font when the operating system contains more than one font with a
\ specified name. For example, if an operating system contains a font named Symbol in raster and TrueType
\ form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying
\ OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType
\ font of another name.
:M SETPITCHANDFAMILY: ( n1 -- ) 
\ Specifies the pitch and family of the font. The two low-order bits specify the pitch of the font and can
\ be one of the following values.
\ 
\ DEFAULT_PITCH  |
\ FIXED_PITCH    |
\ VARIABLE_PITCH |
\ Bits 4 through 7 of the member specify the font family and can be one of the following values.
\ 
\ FF_DECORATIVE
\ FF_DONTCARE
\ FF_MODERN
\ FF_ROMAN
\ FF_SCRIPT
\ FF_SWISS
\ The proper value can be obtained by using the Boolean OR operator to join one pitch constant with one
\ family constant.
\ Font families describe the look of a font in a general way. They are intended for specifying fonts
\ when the exact typeface desired is not available. The values for font families are as follows.
\ 
\ FF_DECORATIVE | Novelty fonts. Old English is an example. |
\ FF_DONTCARE   | Don't care or don't know. |
\ FF_MODERN     | Fonts with constant stroke width (monospace), with or without serifs. Monospace fonts are usually modern. Pica, Elite, and CourierNew are examples. |
\ FF_ROMAN      | Fonts with variable stroke width (proportional) and with serifs. MS Serif is an example. |
\ FF_SCRIPT     | Fonts designed to look like handwriting. Script and Cursive are examples. |
\ FF_SWISS      | Fonts with variable stroke width (proportional) and without serifs. MS Sans Serif is an example. |
:M SETQUALITY: ( n1 -- ) 
\ Specifies the output quality. The output quality defines how carefully the graphics device interface (GDI) must
\ attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following
\ values.
\ 
\ ANTIALIASED_QUALITY | Font is always antialiased if the font supports it and the size of the font is not too small or too large. |
\ DEFAULT_QUALITY     | Appearance of the font does not matter. |
\ DRAFT_QUALITY       | Appearance of the font is less important than when PROOF_QUALITY is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. <
\ NONANTIALIASED_QUALITY | Font is never antialiased. |
\ PROOF_QUALITY      | Character quality of the font is more important than exact matching of the logical-font attributes. |
\ If neither ANTIALIASED_QUALITY nor NONANTIALIASED_QUALITY is selected, the font is antialiased only if the user chooses
\ smooth screen fonts in Control Panel.
:M SETSTRIKEOUT: ( f1 -- ) 
\ Specifies a strikeout font if set to TRUE.
:M SETUNDERLINE: ( f1 -- ) 
\ Specifies an underlined font if set to TRUE.
:M SETWEIGHT: ( n1 -- ) 
\ Specifies the weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold.
\ If this value is zero, a default weight is used. The following values are defined for convenience.
\ 
\ FW_DONTCARE        | 0   |
\ FW_THIN            | 100 |
\ FW_EXTRALIGHT      | 200 |
\ FW_ULTRALIGHT      | 200 |
\ FW_LIGHT           | 300 |
\ FW_NORMAL          | 400 |
\ FW_REGULAR         | 400 |
\ FW_MEDIUM          | 500 |
\ FW_SEMIBOLD        | 600 |
\ FW_DEMIBOLD        | 600 |
\ FW_BOLD            | 700 |
\ FW_EXTRABOLD       | 800 |
\ FW_ULTRABOLD       | 800 |
\ FW_HEAVY           | 900 |
\ FW_BLACK           | 900 |
:M SETWIDTH: ( n1 -- ) 
\ Specifies the average width, in logical units, of characters in the font. If lfWidth is zero,
\ the aspect ratio of the device is matched against the digitization aspect ratio of the available
\ fonts to find the closest match, determined by the absolute value of the difference.
;RECORDSIZE: SIZEOF(CHOOSEFONT) 
;RECORDSIZE: SIZEOF(LOGFONT) 
SHORT ___MISSING_ALIGNMENT__ 
:M CLASSINIT: ( -- ) 
:M COPY: ( -- hCopy ) 
\ Create a copy of the metafile in memory
:M COPYTOCLIPBOARD: ( -- ) 
\ Copy the metafile to the clipboard
:M DESTROY: ( -- ) 
\ Destroy the metafile.
: FILENAME ( addr len -- addr1 ) 
:CLASS GDIMETAFILE 
:CLASS GDIMETAFILE 
:M GETFILEHEADER: ( pemh size -- n ) 
\ The GetFileHeader: method retrieves the record containing the header
\ for the specified enhanced-format metafile. 
\ pemh  Pointer to an ENHMETAHEADER structure that receives the header record.
\ If this parameter is NULL, the function returns the size of the header record. 
\ size Specifies the size, in bytes, of the buffer to receive the data. Only this
\ many bytes will be copied.
:M GETFROMCLIPBOARD: ( -- ) 
\ Get a metafile from the clipboard
:M GETPALETTEENTRIES: ( cEntries lppe -- n ) 
\ The GetPaletteEntries: methods retrieves optional palette entries from the
\ specified enhanced metafile. 
\ cEntries  Specifies the number of entries to be retrieved from the optional
\ palette. 
\ lppe Pointer to an array of PALETTEENTRY structures that receives the palette
\ colors. The array must contain at least as many structures as there are entries
\ specified by the cEntries parameter.
\ If the array pointer is NULL and the enhanced metafile contains an optional palette,
\ the return value is the number of entries in the enhanced metafile's palette; if
\ the array pointer is a valid pointer and the enhanced metafile contains an optional
\ palette, the return value is the number of entries copied; if the metafile does not
\ contain an optional palette, the return value is zero. Otherwise, the return value
\ is GDI_ERROR.
:M LOAD: ( addr len -- f ) 
\ Load a metafile from a file
:M PLAYINRECT: ( left top right bottom hDestDC -- ) 
\ Play the metafile in a rectangle
RECTANGLE RECT 
:M SAVE: ( addr len -- f ) 
\ Save the metafile in a file
:M SETHANDLE: ( hMF -- ) 
\ Set the handle of the metafile.
:M CALCMETARECT: { left top right bottom hDC \ iWidthMM iHeightMM iWidthPels iHeightPels -- } 
\ Calc the dimensions (in .01-millimeter units) of the picture to be
\ stored in the enhanced metafile.
:M CLASSINIT: ( -- ) 
:M DESTROY: ( -- ) 
\ Destroy the metafile.
:M DRAW: ( left top right bottom hDestDC -- ) 
\ Play the metafile in a rectangle
:CLASS GDIMETAFILEDC 
:CLASS GDIMETAFILEDC 
:M GETMETAFILE: ( -- MetafileObject ) 
\ Return the address of the metafile object used by this class
:M LOAD: ( addr len -- f ) 
\ Load a metafile from a file
GDIMETAFILE METAFILE 
RECTANGLE METARECT 
:M SAVE: ( addr len -- f ) 
\ Save the metafile in a file
:M SETRECT: ( left top right bottom -- ) 
\ Specify the dimensions (in .01-millimeter units) of the picture to be
\ stored in the enhanced metafile.
:M STARTRECORDING: ( hRefDC -- f ) 
\ Start recording of a Metafile
:M STOPRECORDING: ( -- f ) 
\ Stop recording of a Metafile
:M CHOOSECOLOR: ( hWnd -- f ) 
\ Open a dialog to choose the color of the pen.
:M CLASSINIT: ( -- ) 
\ Init the class
:M CLASSINIT: ( -- ) 
\ Init the class
GDICOLORREF COLOR 
:M CREATE: ( -- f ) 
\ Create the pen with the current style, color and width.
:M CREATEINDIRECT: ( pLogpen -- f ) 
\ The CreateIndirect function creates a logical cosmetic pen that
\ has the style, width, and color specified in a structure.
:CLASS GDIGEOMETRICPEN 
:CLASS GDIGEOMETRICPEN 
:CLASS GDIPEN 
:CLASS GDIPEN 
:M GETBVALUE: ( -- b ) 
\ Get the blue component of the pen color.
:M GETCOLOR: ( -- colorref ) 
\ Get the color of the pen as a windows COLORREF value.
:M GETGVALUE: ( -- g ) 
\ Get the green component of the pen color.
:M GETRVALUE: ( -- r ) 
\ Get the red component of the pen color.
:M GETSTYLE: ( -- style ) 
\ Get Syle of the pen. Possible values are:
\ 
\ PS_SOLID       | The pen is solid. |
\ PS_DASH        | The pen is dashed. This style is valid only when the pen width is one or less in device units. |
\ PS_DOT         | The pen is dotted. This style is valid only when the pen width is one or less in device units. |
\ PS_DASHDOT     | The pen has alternating dashes and dots. This style is valid only when the pen width is one or less in device units. |
\ PS_DASHDOTDOT  | The pen has alternating dashes and double dots. This style is valid only when the pen width is one or less in device units. |
\ PS_NULL        | The pen is invisible. |
\ PS_INSIDEFRAME | The pen is solid. When this pen is used the dimensions of the figure are shrunk so that it fits entirely in the bounding rectangle, taking into account the width of the pen. This applies only to geometric pens. |
:M GETWIDTH: ( -- width ) 
\ Get the width of the pen in logical units. If the width is zero, the pen is a single pixel
\ wide, regardless of the current transformation.
:M SETBVALUE: ( b -- ) 
\ Set the blue component of the pen color.
:M SETCOLOR: ( colorref -- ) 
\ Set color of the pen.
:M SETGVALUE: ( g -- ) 
\ Set the green component of the pen color.
:M SETRGB: ( r g b -- ) 
\ Set the red, green and blue component of the pen color.
:M SETRVALUE: ( r -- ) 
\ Set the red component of the pen color.
:M SETSTYLE: ( style -- ) 
\ Set Syle of the pen. Possible values are:
\ 
\ PS_SOLID       | The pen is solid. |
\ PS_DASH        | The pen is dashed. This style is valid only when the pen width is one or less in device units. |
\ PS_DOT         | The pen is dotted. This style is valid only when the pen width is one or less in device units. |
\ PS_DASHDOT     | The pen has alternating dashes and dots. This style is valid only when the pen width is one or less in device units. |
\ PS_DASHDOTDOT  | The pen has alternating dashes and double dots. This style is valid only when the pen width is one or less in device units. |
\ PS_NULL        | The pen is invisible. |
\ PS_INSIDEFRAME | The pen is solid. When this pen is used the dimensions of the figure are shrunk so that it fits entirely in the bounding rectangle, taking into account the width of the pen. Only for geometric pens. |
:M SETSYSCOLOR: ( n -- ) 
\ Set the color of the pen to a system color.
:M SETWIDTH: ( width -- ) 
\ Set the width of the pen in logical units. If Width is zero, the pen is a single pixel
\ wide, regardless of the current transformation.
INT STYLE \ Width of the pen, in logical units. If Width is zero, the pen is a single pixel
\ wide, regardless of the current transformation.
INT WIDTH \ Color of the pen.
RECORD: &CHOOSECOLOR 
RECORD: &COLORREF 
RECORD: &POINT 
RECORD: &SIZE 
RECORD: &TEXTMETRIC 
BYTE B 
:M CHOOSE: ( hWnd -- f ) 
\ Open the windows dialog for choosing a color.
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
CREATE CUSTOMCOLORS 
:M CUSTOMCOLORS: ( -- addr len ) 
\ Get the address and length (in cells) of the CustomColors array
\ used by Choose:
INT CX 
INT CY 
INT FLAGS 
BYTE G 
:CLASS GDICOLORREF 
:CLASS GDICOLORREF 
:CLASS GDICOLORREF 
:CLASS GDIPOINT 
:CLASS GDIPOINT 
:CLASS GDISIZE 
:CLASS GDISIZE 
:CLASS GDITEXTMETRIC 
:CLASS GDITEXTMETRIC 
:M GETASCENT: ( -- n ) 
\ 
:M GETAVECHARWIDTH: ( -- n ) 
\ 
:M GETBREAKCHAR: ( -- n ) 
\ 
:M GETBVALUE: ( -- b ) 
\ Get the blue value of the color
:M GETCHARSET: ( -- n ) 
\ 
:M GETCOLOR: ( -- colorref ) 
\ Get the color
:M GETDEFAULTCHAR: ( -- n ) 
\ 
:M GETDESCENT: ( -- n ) 
\ 
:M GETDIGITIZEDASPECTX: ( -- n ) 
\ 
:M GETDIGITIZEDASPECTY: ( -- n ) 
\ 
:M GETEXTERNALLEADING: ( -- n ) 
\ 
:M GETFIRSTCHAR: ( -- n ) 
\ 
:M GETGVALUE: ( -- g ) 
\ Get the green value of the color
:M GETHEIGHT: ( -- n ) 
\ 
:M GETINTERNALLEADING: ( -- n ) 
\ 
:M GETITALIC: ( -- n ) 
\ 
:M GETLASTCHAR: ( -- n ) 
\ 
:M GETMAXCHARWIDTH: ( -- n ) 
\ 
:M GETOVERHANG: ( -- n ) 
\ 
:M GETPITCHANDFAMILY: ( -- n ) 
\ 
:M GETRVALUE: ( -- r ) 
\ Get the red value of the color
:M GETSTRUCKOUT: ( -- n ) 
\ 
:M GETUNDERLINED: ( -- n ) 
\ 
:M GETWEIGHT: ( -- n ) 
\ 
:M GETX: ( -- x ) 
\ Get the x value
:M GETX: ( -- x ) 
\ Get the x value of the point.
:M GETY: ( -- y ) 
\ Get the y value
:M GETY: ( -- y ) 
\ Get the y value of the point.
INT HINSTANCE 
INT HWNDOWNER 
INT LCUSTDATA 
INT LPCUSTCOLORS 
INT LPFNHOOK 
INT LPTEMPLATENAME 
INT LSTRUCTSIZE 
BYTE R 
BYTE RESERVED 
INT RGBRESULT 
:M SETASCENT: ( n -- ) 
\ 
:M SETAVECHARWIDTH: ( n -- ) 
\ 
:M SETBREAKCHAR: ( n -- ) 
\ 
:M SETBVALUE: ( b -- ) 
\ Set the blue value of the color
:M SETCHARSET: ( n -- ) 
\ 
:M SETCOLOR: ( colorref -- ) 
\ Set the color
:M SETDEFAULTCHAR: ( n -- ) 
\ 
:M SETDESCENT: ( n -- ) 
\ 
:M SETDIGITIZEDASPECTX: ( n -- ) 
\ 
:M SETDIGITIZEDASPECTY: ( n -- ) 
\ 
:M SETEXTERNALLEADING: ( n -- ) 
\ 
:M SETFIRSTCHAR: ( n -- ) 
\ 
:M SETGVALUE: ( g -- ) 
\ Set the green value of the color
:M SETHEIGHT: ( n -- ) 
\ 
:M SETINTERNALLEADING: ( n -- ) 
\ 
:M SETITALIC: ( n -- ) 
\ 
:M SETLASTCHAR: ( n -- ) 
\ 
:M SETMAXCHARWIDTH: ( n -- ) 
\ 
:M SETOVERHANG: ( n -- ) 
\ 
:M SETPITCHANDFAMILY: ( n -- ) 
\ 
:M SETRGB: ( r g b -- ) 
\ Set the red, green and blue values of the color
:M SETRVALUE: ( r -- ) 
\ Set the red value of the color
:M SETSTRUCKOUT: ( n -- ) 
\ 
:M SETSYSCOLOR: ( n -- ) 
\ Set a system color. Possible values are:
\ 
\ COLOR_3DDKSHADOW | Dark shadow for three-dimensional display elements. |
\ COLOR_3DFACE, COLOR_BTNFACE | Face color for three-dimensional display elements and for dialog box backgrounds. |
\ COLOR_3DHILIGHT | Highlight color for three-dimensional display elements (for edges facing the light source.) |
\ COLOR_3DHIGHLIGHT | Highlight color for three-dimensional display elements (for edges facing the light source.) |
\ COLOR_BTNHILIGHT | Highlight color for three-dimensional display elements (for edges facing the light source.) |
\ COLOR_BTNHIGHLIGHT | Highlight color for three-dimensional display elements (for edges facing the light source.) |
\ COLOR_3DLIGHT | Light color for three-dimensional display elements (for edges facing the light source.) |
\ COLOR_3DSHADOW, COLOR_BTNSHADOW | Shadow color for three-dimensional display elements (for edges facing away from the light source). |
\ COLOR_ACTIVEBORDER | Active window border. |
\ COLOR_ACTIVECAPTION | Active window title bar. Windows 98, Windows 2000: Specifies the left side color in the color gradient of an active window's title bar if the gradient effect is enabled. |
\ COLOR_APPWORKSPACE | Background color of multiple document interface (MDI) applications. |
\ COLOR_BACKGROUND, COLOR_DESKTOP | Desktop. |
\ COLOR_BTNTEXT | Text on push buttons. |
\ COLOR_CAPTIONTEXT | Text in caption, size box, and scroll bar arrow box. |
\ COLOR_GRADIENTACTIVECAPTION | Windows 98, Windows 2000: Right side color in the color gradient of an active window's title bar.
\ COLOR_ACTIVECAPTION | Windows 98, Windows 2000: specifies the left side color.
\ COLOR_GRADIENTINACTIVECAPTION | Windows 98, Windows 2000: Right side color in the color gradient of an inactive window's title bar.
\ COLOR_INACTIVECAPTION | Windows 98, Windows 2000: specifies the left side color. |
\ COLOR_GRAYTEXT | Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color. |
\ COLOR_HIGHLIGHT | Item(s) selected in a control. |
\ COLOR_HIGHLIGHTTEXT | Text of item(s) selected in a control. |
\ COLOR_HOTLIGHT | Windows 98, Windows 2000: Color for a hot-tracked item. Single clicking a hot-tracked item executes the item. |
\ COLOR_INACTIVEBORDER | Inactive window border. |
\ COLOR_INACTIVECAPTION | Inactive window caption. Windows 98, Windows 2000: Specifies the left side color in the color gradient of an inactive window's title bar if the gradient effect is enabled. |
\ COLOR_INACTIVECAPTIONTEXT | Color of text in an inactive caption. |
\ COLOR_INFOBK | Background color for tooltip controls. |
\ COLOR_INFOTEXT | Text color for tooltip controls. |
\ COLOR_MENU | Menu background. |
\ COLOR_MENUTEXT | Text in menus. |
\ COLOR_SCROLLBAR | Scroll bar gray area. |
\ COLOR_WINDOW | Window background. |
\ COLOR_WINDOWFRAME | Window frame. |
\ COLOR_WINDOWTEXT | Text in windows. |
:M SETUNDERLINED: ( n -- ) 
\ 
:M SETWEIGHT: ( n -- ) 
\ 
:M SETX: ( x -- ) 
\ Set the x value
:M SETX: ( x -- ) 
\ Set the x value of the point.
:M SETY: ( y -- ) 
\ Get the y value of the point.
:M SETY: ( y -- ) 
\ Set the y value
:M SIZE: ( -- size ) 
\ Get the site of the point struct
:M SIZE: ( -- size ) 
\ Get the size of the SIZE struct
:M SIZE: ( -- size ) 
:M SIZE: ( -- size ) 
\ Get the size of the COLORREF struct
;RECORDSIZE: SIZEOF(CHOOSECOLOR) 
;RECORDSIZE: SIZEOF(COLORREF) 
;RECORDSIZE: SIZEOF(POINT) 
;RECORDSIZE: SIZEOF(SIZE) 
;RECORDSIZE: SIZEOF(TEXTMETRIC) 
INT TMASCENT 
INT TMAVECHARWIDTH 
BYTE TMBREAKCHAR 
BYTE TMCHARSET 
BYTE TMDEFAULTCHAR 
INT TMDESCENT 
INT TMDIGITIZEDASPECTX 
INT TMDIGITIZEDASPECTY 
INT TMEXTERNALLEADING 
BYTE TMFIRSTCHAR 
INT TMHEIGHT 
INT TMINTERNALLEADING 
BYTE TMITALIC 
BYTE TMLASTCHAR 
INT TMMAXCHARWIDTH 
INT TMOVERHANG 
BYTE TMPITCHANDFAMILY 
BYTE TMSTRUCKOUT 
BYTE TMUNDERLINED 
INT TMWEIGHT 
INT X 
INT Y 
:M CLASSINIT: ( -- ) 
:M DESTROY: ( -- ) 
:CLASS GDIWINDOWDC 
:CLASS GDIWINDOWDC 
:M GETDC: ( hWnd -- f ) 
\ The GetDC method retrieves a handle to a display device context
\ for the client area of a specified window.
:M GETDCEX: ( hrgnClip flags hWnd -- f ) 
\ The GetDCEx method  retrieves a handle to a display device context
\ for the client area of a specified window or for the entire screen.
\ You can use the returned handle in subsequent GDI functions to draw in the DC.
\ This function is an extension to the GetDC function, which gives an application
\ more control over how and whether clipping occurs in the client area.
\  hrgnClip  Specifies a clipping region that may be combined with the visible region
\ of the DC. If the value of flags is DCX_INTERSECTRGN or DCX_EXCLUDERGN, then the
\ operating system assumes ownership of the region and will automatically delete it
\ when it is no longer needed. In this case, applications should not use the region
\ not even delete it after a successful call to GetDCEx.
\  flags  Specifies how the DC is created. This parameter can be one or more of the
\ following values.
\  DCX_WINDOW  Returns a DC that corresponds to the window rectangle rather
\ than the client rectangle.
\  DCX_CACHE  Returns a DC from the cache, rather than the OWNDC or CLASSDC
\ window. Essentially overrides CS_OWNDC and CS_CLASSDC.
\  DCX_PARENTCLIP  Uses the visible region of the parent window. The parent's
\ WS_CLIPCHILDREN and CS_PARENTDC style bits are ignored. The
\ origin is set to the upper-left corner of the window identified
\ by hWnd.
\  DCX_CLIPSIBLINGS  Excludes the visible regions of all sibling windows above the
\ window identified by hWnd.
\  DCX_CLIPCHILDREN  Excludes the visible regions of all child windows below the
\ window identified by hWnd.
\  DCX_NORESETATTRS  Does not reset the attributes of this DC to the default attributes
\ when this DC is released.
\  DCX_LOCKWINDOWUPDATE  Allows drawing even if there is a LockWindowUpdate call in effect
\ that would otherwise exclude this window. Used for drawing during
\ tracking.
\  DCX_EXCLUDERGN  The clipping region identified by hrgnClip is excluded from the
\ visible region of the returned DC.
\  DCX_INTERSECTRGN  The clipping region identified by hrgnClip is intersected with the
\ visible region of the returned DC.
\  DCX_VALIDATE  When specified with DCX_INTERSECTUPDATE, causes the DC to be
\ completely validated. Using this function with both DCX_INTERSECTUPDATE
\ and DCX_VALIDATE is identical to using the BeginPaint function.
:M GETDCORG: ( -- x y ) 
\ The GetDCOrgEx function retrieves the final translation origin for a specified device
\ context (DC). The final translation origin specifies an offset that the system uses to
\ translate device coordinates into client coordinates (for coordinates in an application's
\ window).
:M GETWINDOWDC: ( hWnd -- f ) 
\ The GetWindowDC method retrieves the device context (DC) for the entire
\ window, including title bar, menus, and scroll bars. A window device
\ context permits painting anywhere in a window, because the origin of
\ the device context is the upper-left corner of the window instead of
\ the client area.
INT HWND \ handle of the window in which this device context is used
:M RELEASE: ( -- ) 
\ The Release: method releases a device context (DC), freeing it
\ for use by other applications. The effect of the ReleaseDC function depends
\ on the type of DC. It frees only common and window DCs. It has no effect on
\ class or private DCs.
: SETHANDLE ( hDC -- f ) 
: SETWINDOW ( hWnd -- f ) 
: (SETTEXTALIGN) ( flag hwnd -- ) 
INT (WSTATUS) 
: +DIALOGLIST ( -- ) 
\ link into dialog list in Start:
\ Used so window responds to Dialog messages. Used by ModeLessDialog DialogWindow and
\ MdiDialog classes but can be added to any descendants of class Window (including
\ descendants of Child-Window) so they can respond to dialog messages. Can also be
\ used programatically.
:M +STYLE: ( style -- ) 
\ Add a window style to a running window.
: -DIALOGLIST ( -- ) 
\ don't link from dialog list in Start:
\ Disable responding to dialog messages. This was mainly used for the ~: destructor method
\ though is no longer needed. Can also be used programatically.
:M -STYLE: ( style -- ) 
\ Remove a window style from a running window.
: ?DOADDDIALOGLIST ( -- ) 
\ Needs to be in On_Init: for all dialogs and dialog-windows.
: ?DOREMOVEDIALOGLIST ( -- ) 
\ Needs to be in On_Done: for all dialogs and dialog-windows.
:M BEGINPAINT: ( ps -- hdc ) 
\ The BeginPaint function prepares the window for painting and fills a
\ PAINTSTRUCT (ps) structure with information about the painting.
:M CHECKDLGBUTTON: ( uCheck id -- ) 
\ The CheckDlgButton function changes the check state of a button control.
\ Possible values for uCheck are:
\ 
\ BST_CHECKED       | Sets the button state to checked. |
\ BST_INDETERMINATE | Sets the button state to grayed, indicating an indeterminate state. Use this value only if the button has the BS_3STATE or BS_AUTO3STATE style. |
\ BST_UNCHECKED     | Sets the button state to cleared |
:M CHECKRADIOBUTTON: ( check_id first_id last_id -- ) 
\ The CheckRadioButton function adds a check mark to (checks) a specified radio button
\ in a group and removes a check mark from (clears) all other radio buttons in the group.
\ 
\ check_id | Specifies the identifier of the radio button to select. |
\ first_id | Specifies the identifier of the first radio button in the group. |
\ last_id  | Specifies the identifier of the last radio button in the group. |
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLOSE: ( -- ) 
\ Close the window.
:M DESTROYWINDOW: ( -- ) 
\ Destroy the window. The handle is always zero after executing this method. In a
\ multi-tasking application this method causes an error if executed by a task that
\ didn't create the window.
NEWUSER DIALOG-LINK 
BYTES DIALOGLINK \ must follow hwnd
: DODIALOGMSG { pMsg flag -- pMsg f | pMsg FALSE } 
:M ENABLEDLGITEM: ( flag id -- ) 
\ Enable or disable a control (id) in the window.
\ Possible values for flag are:
\ 
\ 0  | disable |
\ 1  | enable |
:M ENDPAINT: ( ps -- ) 
\ The EndPaint function marks the end of painting in the window. This function is
\ required for each call to the BeginPaint function, but only after painting is complete.
:M GDIFLUSH: ( -- ) 
\ Flush the calling thread's current batch.
:CLASS GENERIC-WINDOW 
:CLASS GENERIC-WINDOW 
: GET-MOUSE-XY ( hWnd -- x y) 
\ W32F
\ Return the co-ordinates of the mouse pointer in window, hWnd.
{ hWnd | CursorPoint -- x y } 
:M GETCLIENTRECT: ( rect -- ) 
\ The GetClientRect function retrieves the coordinates of the window's client area. The
\ client coordinates specify the upper-left and lower-right corners of the client area.
\ Because client coordinates are relative to the upper-left corner of a window's client
\ area, the coordinates of the upper-left corner are (0,0).
:M GETDC: ( -- hdc ) 
\ The GetDC function retrieves a handle to a display device context (DC)
\ for the client area of the window. 
\ You have to call ReleaseDC when the DC isn't needed any longer.
:M GETDLGITEM: ( id -- handle ) 
\ The GetDlgItem function retrieves a handle of the control (id) in the window.
:M GETDLGITEMTEXT: ( addr len id -- len ) 
\ The GetDlgItemText function retrieves the title or text associated with a control in the window.
:M GETHANDLE: ( -- hWnd ) 
\ Get the window handle.
:M GETSTYLE: ( -- style ) 
\ Retrieves the window styles of a running window.
:M GETTEXT: ( -- addr len ) 
\ The GetWindowText function copies the text of the window's title bar (if it has one)
\ into a buffer. If the window is a control, the text of the control is copied.
\ The text is stored in a dynamic buffer so should be copied if it needs to be
\ persistant.
:M GETWINDOWDC: ( -- hdc ) 
\ The GetWindowDC function retrieves the device context (DC) for the entire
\ window, including title bar, menus, and scroll bars. A window device context
\ permits painting anywhere in a window, because the origin of the device context
\ is the upper-left corner of the window instead of the client area. 
\ GetWindowDC assigns default attributes to the window device context each time it
\ retrieves the device context. Previous attributes are lost. 
\ You have to call ReleaseDC when the DC isn't needed any longer.
:M GETWINDOWLONG: ( index -- value ) 
\ The GetWindowLong function retrieves information about the window. The function
\ also retrieves the 32-bit (long) value at the specified offset into the extra
\ window memory. 
\ Index Specifies the zero-based offset to the value to be retrieved. Valid values are
\ in the range zero through the number of bytes of extra window memory, minus four; for
\ example, if you specified 12 or more bytes of extra memory, a value of 8 would be an
\ index to the third 32-bit integer. To retrieve any other value, specify one of the
\ following values.
\ 
\ GWL_EXSTYLE    | Retrieves the extended window styles. For more information, see CreateWindowEx. |
\ GWL_STYLE      | Retrieves the window styles. |
\ GWL_WNDPROC    | Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the CallWindowProc function to call the window procedure. |
\ GWL_HINSTANCE  | Retrieves a handle to the application instance. |
\ GWL_HWNDPARENT | Retrieves a handle to the parent window, if any. |
\ GWL_ID         | Retrieves the identifier of the window. |
\ GWL_USERDATA   | Retrieves the 32-bit value associated with the window. Each window has a corresponding 32-bit value intended for use by the application that created the window. This value is initially zero. |
:M GETWINDOWRECT: ( -- left top right bottom ) 
\ The GetWindowRect method retrieves the dimensions of the bounding rectangle of the window.
\ The dimensions are given in screen coordinates that are relative to the upper-left corner
\ of the screen.
IMPORT: GETWINDOWTEXT 
INT HWND \ handle to Win32 window object
:M INVALIDATERECT: ( bgflag rectangle -- ) 
\ The InvalidateRect function adds a rectangle to the window's update region.
\ The update region represents the portion of the window's client area that must be redrawn.
\ 
\ lpRect | Pointer to a RECT structure that contains the client coordinates of the rectangle to be added to the update region. If this parameter is NULL, the entire client area is added to the update region. |
\ bErase | Specifies whether the background within the update region is to be erased when the update region is processed. If this parameter is TRUE, the background is erased when the BeginPaint function is called. |
:M ISDLGBUTTONCHECKED: ( id -- f1 ) 
\ The IsDlgButtonChecked function determines whether a button control has a check mark next to
\ it or whether a three-state button control is grayed, checked, or neither.
:M ISVISIBLE?: ( -- f ) 
\ Check if the window is visible or not.
: LINK-WINDOW ( -- ) 
:M MESSAGEBOX: ( szText szTitle style -- result ) 
\ The MessageBox function creates, displays, and operates a message box. The message box contains an
\ application-defined message and title, plus any combination of predefined icons and push buttons.
\ 
\ szText  | Pointer to a null-terminated string that contains the message to be displayed. |
\ szTitle | Pointer to a null-terminated string that contains the dialog box title. If this parameter is NULL, the default title Error is used. |
\ Type    | Specifies the contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags. |
\ To indicate the buttons displayed in the message box, specify one of the following values. |
\ 
\ MB_ABORTRETRYIGNORE  | The message box contains three push buttons: Abort, Retry, and Ignore. |
\ MB_CANCELTRYCONTINUE | Windows 2000: The message box contains three push buttons: Cancel, Try Again, Continue. Use this message box type instead of MB_ABORTRETRYIGNORE. |
\ MB_HELP              | Adds a Help button to the message box. When the user clicks the Help button or presses F1, the system sends a WM_HELP message to the owner. |
\ MB_OK                | The message box contains one push button: OK. This is the default. |
\ MB_OKCANCEL          | The message box contains two push buttons: OK and Cancel. |
\ MB_RETRYCANCEL       | The message box contains two push buttons: Retry and Cancel. |
\ MB_YESNO             | The message box contains two push buttons: Yes and No. |
\ MB_YESNOCANCEL       | The message box contains three push buttons: Yes, No, and Cancel. |
\ To display an icon in the message box, specify one of the following values.
\ 
\ MB_ICONEXCLAMATION, MB_ICONWARNING  | An exclamation-point icon appears in the message box. |
\ MB_ICONINFORMATION, MB_ICONASTERISK | An icon consisting of a lowercase letter i in a circle appears in the message box. |
\ MB_ICONQUESTION                     | A question-mark icon appears in the message box. |
\ MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND | A stop-sign icon appears in the message box. |
\ To indicate the default button, specify one of the following values.
\ 
\ MB_DEFBUTTON1 | The first button is the default button. MB_DEFBUTTON1 is the default unless MB_DEFBUTTON2, MB_DEFBUTTON3, or MB_DEFBUTTON4 is specified.
\ MB_DEFBUTTON2 | The second button is the default button. |
\ MB_DEFBUTTON3 | The third button is the default button. |
\ MB_DEFBUTTON4 | The fourth button is the default button. |
\ To specify other options, use one or more of the following values.
\ 
\ MB_RIGHT         | The text is right-justified. |
\ MB_SETFOREGROUND | The message box becomes the foreground window. Internally, the system calls the SetForegroundWindow function for the message box. |
\ MB_TOPMOST       | The message box is created with the WS_EX_TOPMOST window style. |
\ If the function succeeds, the return value is one of the following menu-item values.
\ 
\ IDABORT    | Abort button was selected. |
\ IDCANCEL   | Cancel button was selected. |
\ IDCONTINUE | Continue button was selected. |
\ IDIGNORE   | Ignore button was selected. |
\ IDNO No    | button was selected. |
\ IDOK OK    | button was selected. |
\ IDRETRY    | Retry button was selected. |
\ IDTRYAGAIN | Try Again button was selected. |
\ IDYES      | Yes button was selected. |
:M MOVE: { x y w h -- } 
\ Change the position and dimensions of window.
\ For a top-level window, the position and dimensions are relative to the upper-left corner
\ of the screen. For a child window, they are relative to the upper-left corner of the parent
\ window's client area.
:M ON_DONE: ( -- ) 
\ Thing's to do when the window will be destroyed. Default does ?DoRemoveDialogList.
:M ON_INIT: ( -- ) 
\ Thing's to do during creation of the window.
\ Default does ?DoAddDialogList.
: OWNEDBYTASK ( -- f ) 
:M PAINT: ( -- ) 
\ Force window repaint. A WM_PAINT message is posted to the message queue.
:M PUTHANDLE: ( hWnd -- ) 
\ Set the window handle. Normally handled by the system.
:M RELEASEDC: ( hdc -- ) 
\ The ReleaseDC function releases the device context (DC) of the window. 
\ Call only after GetDC or GetWindowDC.
:M SCROLL: { x y -- } 
\ Scroll the contents of the specified window's client area.
:M SELECTDLGITEMALL: ( id -- ) 
\ Selects all characters in the edit control (id). You can use this forn an edit control
\ or a rich edit control.
:M SENDDLGITEMMESSAGE: ( lParam wParam message id -- long ) 
\ Send a message to the control (id) in the window.
: SENDMESSAGE:SELF ( lParam wParam message -- result ) 
\ Send a windows message to our self.
: SENDMESSAGE:SELFDROP ( lParam wParam message -- ) 
\ Send a windows message to our self and discard the result.
:M SETACTIVEWINDOW: ( -- ) 
\ The SetActiveWindow function activates a window. The window must be attached to the calling thread's message queue. 
\ The SetActiveWindow function activates a window, but not if the application is in the background. The window will be
\ brought into the foreground (top of Z order) if its application is in the foreground when the system activates the window. 
\ If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling
\ thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL. 
\ By using the AttachThreadInput function, a thread can attach its input processing to another thread.
\ This allows a thread to call SetActiveWindow to activate a window attached to another thread's message queue.
:M SETALIGN: ( flag id -- ) 
\ DEPRECATED
\ Obsolescent Method use SetDlgItemAlign: instead.
:M SETDLGITEMALIGN: ( flag id -- ) 
\ Set the text-alignment for a control (id) in the window. 
\ The current position is updated after each text output call.
\ The current position is used as the reference point.
\ Possible values for flag are:
\ 
\ 0  | The reference point will be on the left edge of the bounding rectangle. |
\ 1  | The reference point will be on the right edge of the bounding rectangle. |
\ 2  | The reference point will be aligned horizontally with the center of the bounding rectangle. |
:M SETDLGITEMFOCUS: ( id -- ) 
\ Set the focus to the control (id) in the window.
:M SETDLGITEMFONT: ( FontObject id -- ) 
\ Specify the font that the control (id) is to use when drawing text. 
\ FontObject must be the HANDLE of a font. If this parameter is NULL, the control uses the
\ default system font to draw text.
:M SETDLGITEMTEXT: ( addr len id -- ) 
\ The SetDlgItemText function sets the title or text of a control in then window.
:M SETFOCUS: ( -- ) 
\ The SetFocus function sets the keyboard focus to the window. The window must be
\ attached to the calling thread's message queue.
:M SETFOREGROUNDWINDOW: ( -- ) 
\ The SetForegroundWindow function puts the thread that created the specified window
\ into the foreground and activates the window. Keyboard input is directed to the window,
\ and various visual cues are changed for the user. The system assigns a slightly higher
\ priority to the thread that created the foreground window than it does to other threads. 
\ The foreground window is the window at the top of the Z order. It is the window that the
\ user is working with. In a preemptive multitasking environment, you should generally let the
\ user control which window is the foreground window. 
\ Windows 98, Windows 2000: The system restricts which processes can set the foreground window.
\ A process can set the foreground window only if one of the following conditions is true: 
\ - The process is the foreground process. 
\ - The process was started by the foreground process. 
\ - The process received the last input event. 
\ - There is no foreground process. 
\ - The foreground process is being debugged. 
\ - The foreground is not locked (see LockSetForegroundWindow). 
\ - The foreground lock time-out has expired (see SPI_GETFOREGROUNDLOCKTIMEOUT in SystemParametersInfo). 
\ - Windows 2000: No menus are active. 
\ With this change, an application cannot force a window to the foreground while the user is
\ working with another window. Instead, SetForegroundWindow will activate the window (see SetActiveWindow)
\ and call the FlashWindowEx function to notify the user. For more information, see Foreground and
\ Background Windows. 
\ A process that can set the foreground window can enable another process to set the foreground window by
\ calling the AllowSetForegroundWindow function. The process specified by dwProcessId loses the ability to
\ set the foreground window the next time the user generates input, unless the input is directed at that
\ process, or the next time a process calls AllowSetForegroundWindow, unless that process is specified. 
\ The foreground process can disable calls to SetForegroundWindow by calling the LockSetForegroundWindow function.
:M SETMENU: ( MenuHandle -- ) 
\ The SetMenu function assigns a new menu to the window.
\ If MenuHandle is NULL, the window's current menu is removed.
:M SETREDRAW: ( f -- ) 
\ Set the redraw state of the window.
\  f  Specifies the redraw state. If this parameter is TRUE, the
\ content can be redrawn after a change. If this parameter is FALSE,
\ the content cannot be redrawn after a change.
:M SETSTYLE: ( style -- ) 
\ Sets a new window style of a running window.
:M SETTEXT: { addr len \ text$ -- } 
\ The SetWindowText function changes the text of the window's title bar (if it has one).
\ If the window is a control, the text of the control is changed.
:M SETTEXTALIGN: ( flag -- ) 
\ Set the text-alignment for the window. 
\ The current position is updated after each text output call.
\ The current position is used as the reference point.
\ Possible values for flag are:
\ 
\ 0  | The reference point will be on the left edge of the bounding rectangle. |
\ 1  | The reference point will be on the right edge of the bounding rectangle. |
\ 2  | The reference point will be aligned horizontally with the center of the bounding rectangle. |
:M SETWINDOWLONG: ( value index -- oldval ) 
\ The SetWindowLong function changes an attribute of the window. The function also sets the
\ 32-bit (long) value at the specified offset into the extra window memory.
\ 
\ GWL_EXSTYLE   | Sets a new extended window style. For more information, see CreateWindowEx. |
\ GWL_STYLE     | Sets a new window style. |
\ GWL_WNDPROC   | Sets a new address for the window procedure. Windows NT/2000: You cannot change this attribute if the window does not belong to the same process as the calling thread. |
\ GWL_HINSTANCE | Sets a new application instance handle. |
\ GWL_ID        | Sets a new identifier of the window. |
\ GWL_USERDATA  | Sets the 32-bit value associated with the window. Each window has a corresponding 32-bit value intended for use by the application that created the window. This value is initially zero. |
:M SETWINDOWPOS: { x y -- } 
\ The SetWindowPos function changes the position of a child, pop-up, or top-level window. 
\ X Specifies the new position of the left side of the window, in client coordinates. 
\ Y Specifies the new position of the top of the window, in client coordinates.
:M SHOW: ( state -- ) 
\ Set the specified window's show state. 
\ Possible values for state are:
\ 
\ SW_FORCEMINIMIZE   | Windows 2000: Minimizes a window, even if the thread that owns the window is hung. This flag should only be used when minimizing windows from a different thread. |
\ SW_HIDE            | Hides the window and activates another window. |
\ SW_MAXIMIZE        | Maximizes the specified window. |
\ SW_MINIMIZE        | Minimizes the specified window and activates the next top-level window in the Z order. |
\ SW_RESTORE         | Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window. |
\ SW_SHOW            | Activates the window and displays it in its current size and position.  |
\ SW_SHOWDEFAULT     | Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application. |
\ SW_SHOWMAXIMIZED   | Activates the window and displays it as a maximized window. |
\ SW_SHOWMINIMIZED   | Activates the window and displays it as a minimized window. |
\ SW_SHOWMINNOACTIVE | Displays the window as a minimized window. This value is similar to SW_SHOWMINIMIZED, except the window is not activated. |
\ SW_SHOWNA          | Displays the window in its current size and position. This value is similar to SW_SHOW, except the window is not activated. |
\ SW_SHOWNOACTIVATE  | Displays a window in its most recent size and position. This value is similar to SW_SHOWNORMAL, except the window is not actived. |
\ SW_SHOWNORMAL      | Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time. |
\ If the window belongs to a different task or application the WM_SHOW is posted to the
\ the message queue to prevent the current task hanging. If the window belongs to the
\ current task the message is sent.
:M SHOWDLGITEM: ( flag id -- ) 
\ Hide or show a control (id) in the window.
\ Possible values for flag are:
\ 
\ 0  | hide |
\ 1  | show |
: STATIC-WINDOW? ( -- f1 ) 
\ is this a static window
: TRIM-DIALOGS ( nfa -- nfa ) 
: TRIM-WINDOWS ( nfa -- nfa ) 
\ for forgetting
:M UPDATE: ( -- ) 
\ Update the client area of the window by sending
\ a WM_PAINT message to the window if the window's update region is not empty. The
\ function sends a WM_PAINT message directly to the window procedure of the window,
\ bypassing the application queue. If the update region is empty, no message is sent.
VARIABLE WINDOWS-LINK 
ALIAS WINRECT \ Moved from control.f since it's also used by descendants of the class window.
\ Made thread-safe gah Sunday, May 20 2007
ALIAS WINRECT \ Moved from control.f since it's also used by descendants of the class window.
\ Made thread-safe gah Sunday, May 20 2007
ALIAS WINRECT \ Moved from control.f since it's also used by descendants of the class window.
\ Made thread-safe gah Sunday, May 20 2007
ALIAS WINRECT \ Moved from control.f since it's also used by descendants of the class window.
\ Made thread-safe gah Sunday, May 20 2007
ALIAS WINRECT \ Moved from control.f since it's also used by descendants of the class window.
\ Made thread-safe gah Sunday, May 20 2007
:M WM_CREATE ( hwnd msg wparam lparam -- res ) 
BITS WSTATUS0 
BITS WSTATUS0 
BITS WSTATUS1 
BITS WSTATUS10 
BITS WSTATUS11 
BITS WSTATUS12 
BITS WSTATUS13 
BITS WSTATUS14 
BITS WSTATUS15 
BITS WSTATUS16 
BITS WSTATUS17 
BITS WSTATUS18 
BITS WSTATUS19 
BITS WSTATUS2 
BITS WSTATUS20 
BITS WSTATUS21 
BITS WSTATUS22 
BITS WSTATUS23 
BITS WSTATUS24 
BITS WSTATUS25 
BITS WSTATUS26 
BITS WSTATUS27 
BITS WSTATUS28 
BITS WSTATUS29 
BITS WSTATUS3 
BITS WSTATUS30 
BITS WSTATUS31 \ Rectangle WinRect
\ The following is for backward compatibility. Use WinRect for new code since it will
\ be early bound whereas wRect will be latebound.
\ int wRect
\ synonym tempRect wRect
\ -----------------------------------------------------------------
\ -----------------------------------------------------------------
BITS WSTATUS4 
BITS WSTATUS5 
BITS WSTATUS6 
BITS WSTATUS7 
BITS WSTATUS8 
BITS WSTATUS9 
: ZERO-IMAGE-WINDOWS ( -- ) 
\ Zero all window handles.
:M ZEROWINDOW: ( -- ) 
\ Clear the window handle. Normally handled by the system. All window
\ handles are zeroed automatically in the image when saving.
: "SAVE ( cfa addr len -- ) 
\ save as Forth
CREATE &APPDIR 
: (SAVE) { addr len | $name -- } 
\ use current image & build .exe
: ->RVA ( n -- n' ) 
\ convert to RVA
: .APPDIR ( -- ) 
\ type application directory
CONSTANT 1MBYTE 
CONSTANT 4KBYTE 
: >IMAGE ( Addr1 -- Addr2|false ) 
: >IMAGE-APP ( Addr1 -- Addr2 ) 
: >IMAGE-CODE ( Addr1 -- Addr2 ) 
: >IMAGE-SYS ( Addr1 -- Addr2 ) 
: ?PEIMG-FERROR ( flag -- ) 
FLDBASE BASE-IMPSTR 
CREATE BDT \ base date struct for FileTimeToSystemTime
: BUILD ( addr len -- ) 
\ declare new image
VALUE BUILDTYPE \ EXE or DLL
: CHECKSUM ( -- n ) 
: COMPACT ( -- ) 
: CONSOLEBOOT ( -- ) 
\ directive used to override SAVE or TURNKEY default
\ the image will have a full Forth console
: CONSOLEHIDDENBOOT ( -- ) 
\ directive used to override SAVE or TURNKEY default
\ the image will have a hidden Console console
VALUE CONSOLEMODE 
DEFER DEFAULT-APPLICATION 
DEFER DOCONSOLEBOOT 
: DOSCONSOLEBOOT ( -- ) 
\ directive used to override SAVE or TURNKEY default
\ the image will have a DOS console
: ENDBUILD ( -- ) 
\ fixup all the missing info
: ENDIMPORTS ( -- addr len ) 
\ build import words, return buffer
{ \ CURR-IID CURR-ILT CURR-FUNCS         CURR-IAT LEN-IAT LEN-ALLIIDS } 
\ temporaries
: ENDSECTION ( -- ) 
\ tidy up section
: ENTRYPOINT ( n -- ) 
VALUE EXETYPE 
VALUE FILE-ALIGN \ file alignment, see compact
: GENERALBOOT ( -- ) 
\ boot word to be used with any program other than Forth itself
VALUE HEAD-BASESECT \ base of section ptr
VALUE HEAD-BUFF \ header buffer
: HEAPSIZE ( r c -- ) 
VALUE IMAGE-AACTUAL 
VALUE IMAGE-APPPTR 
VALUE IMAGE-ASEP 
VALUE IMAGE-ASIZE 
VALUE IMAGE-CACTUAL 
VALUE IMAGE-CODEPTR 
: IMAGE-COPY ( -- ) 
\ copy & adjust the current image
VALUE IMAGE-CSEP 
VALUE IMAGE-CSIZE 
VALUE IMAGE-ENTRY 
VALUE IMAGE-ORIGIN 
VALUE IMAGE-PTR 
VALUE IMAGE-SACTUAL 
VALUE IMAGE-SSEP 
VALUE IMAGE-SSIZE 
: IMAGE-STATS ( -- ) 
\ image statistics
VALUE IMAGE-SYSPTR 
FLD IMP-FUNC \ func ptr *must be second*
FLD IMP-HINT \ hint, only for functions
CONSTANT IMP-LEN 
FLD IMP-NAME \ name counted string, max id length is 33
FLD IMP-NEXT \ next ptr
FLD IMP-RVA \ RVA of field
VALUE IMPFUNC-COUNT \ count of IMPORTS
VARIABLE IMPFUNC-LINK \ head of IMPORTS
: IMPINIT ( -- ) 
\ initialise import
: IMPLIB ( addr len -- ) 
\ define library name
VALUE IMPLIB-COUNT \ count of IMPLIBS
VARIABLE IMPLIB-LINK \ head of IMPLIBs
: IMPORT ( n addr len -- ) 
\ define proc in the above library
VALUE IMPS-BUFF \ import section buffer
: IMPSTR ( addr len link -- ) 
\ scan, allocate string
VALUE IMPSTR-BUFF \ temp buffer
: IN-IMAGE? ( Addr1 -- flag ) 
: IS-IMAGE ( xt "name" -- ) 
\ preset a defer to xt
VALUE LEN-HEAD \ header length, see compact
: LINKTIME ( -- n ) 
\ secs since date above
: LOADPOINT ( n -- ) 
: MOVE-NAME { src dest -- len } 
: MSGBOX ( addr len -- ) 
\ display a message + OK (needs no console)
: NOCONSOLEBOOT ( -- ) 
\ directive used to override SAVE or TURNKEY default
\ the image will have no console
: PEIMG-FCLOSE ( -- ) 
: PEIMG-FCREATE ( -- ) 
: PEIMG-FOPEN ( -- ) 
: PEIMG-FPOS ( -- n ) 
\ file position
: PEIMG-FREPOS ( n -- ) 
\ reposition file
: PEIMG-FWRITE ( addr len -- ) 
VALUE PEIMG-HNDL 
CREATE PEIMG-NAME 
: PEIMG-PADWRITE ( addr len -- ) 
\ write zero padded block
: PORIG ( n -- ) 
: PRESETDOSCONSOLE ( -- ) 
\ Preset DOS console functions in Image
: PRESETNOCONSOLEIO ( -- ) 
\ Preset all defered I/O words to noop's.
VALUE PREV-SECTRVA \ previous section's RVA
: PSIZE ( n -- ) 
: PTABL ( -- ) 
: RESOURCES ( addr len -- ) 
\ build resource
\ dummy right now
VALUE RVA-BUFF 
: SAVE ( cfa -<exename>- -- ) 
\ create application "exename" that runs the
\ forth definition specified by 'cfa'. Forth interpreter, headers
\ and system space are still available. Defaulft console mode is
\ full Forth console.
\ Usage: ' myApp SAVE myfile.exe
VALUE SCINTILLA-DLL? \ W32F       Forth System Imageman
\ Set to true if your app needs the w32fScintilla.dll.
: SECTINIT ( -- ) 
\ initialise
: SECTION ( addr len -- ) 
\ section name code
: SECTIONDATA ( addr len -- ) 
\ section data, some fields get filled later
: SECTIONRVA ( n -- ) 
: SECTIONSIZE ( n -- ) 
\ section virtual size
: SECTIONTYPE ( n -- ) 
\ section characteristics
: SECTWRITE ( -- ) 
\ write out sections
: STACKSIZE ( r c -- ) 
: STD-IMG2EXE ( addr len -- ) 
\ compose STD image, addr/len is name
: SUBSYSTEM ( m -- ) 
\ declare subsystem
: TURNKEY ( cfa -<exename>- -- ) 
\ create application "exename" that runs the
\ forth definition specified by 'cfa'. Destroy headers, interpreter
\ and system space. Defaulft console mode is no console.
\ Usage: ' myApp TURNKEY myfile.exe
VOCABULARY VIMAGE 
VALUE ZERO-BUFF \ binary zeros for padding
CREATE ZERO-WORDS \ words to be zeroed on image-copy
\ these must be IN-APPLICATION!
\ &EXCEPT           ,            \ zero last exception
: #ELSE ( -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( "<spaces>name" ... -- )
\ Skipping leading spaces, parse and discard space-delimited words from the parse area,
\ including nested occurrences of #IF ... #THEN and #IF ... #ELSE ... #THEN, until
\ the word #THEN has been parsed and discarded. If the parse area becomes exhausted,
\ it is refilled as with REFILL. #ELSE is an immediate word.
: #ENDIF ( -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( -- )
\ Does nothing. #ENDIF is an immediate word.
: #IF ( flag -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( flag | flag "<spaces>name" ... -- )
\ If flag is true, do nothing. Otherwise, skipping leading spaces, parse and discard
\ space-delimited words from the parse area, including nested occurrences of
\ #IF ... #THEN, #IF ... #ELSE ... #THEN, #IF ... #ENDIF and
\ #IF ... #ELSE ... #ENDIF, until either the word #ELSE,
\ the word #THEN or the word #ENDIF has been parsed and discarded.
\ If the parse area becomes exhausted, it is refilled as with REFILL.
\ #IF is an immediate word.
\ An ambiguous condition exists if #IF is POSTPONEd.
\ If the end of the input buffer is reached and cannot be refilled before the terminating
\ #ELSE, #THEN or #ENDIF is parsed then error -58 is thrown.
: #IFDEF ( "aword" -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( "aword" | "aword<spaces>name" ... -- )
\ If "aword" is found in the search order, do nothing. Otherwise, skipping
\ leading spaces, parse and discard
\ space-delimited words from the parse area, including nested occurrences of
\ #IF ... #THEN, #IF ... #ELSE ... #THEN, #IF ... #ENDIF and
\ #IF ... #ELSE ... #ENDIF, until either the word #ELSE,
\ the word #THEN or the word #ENDIF has been parsed and discarded.
\ If the parse area becomes exhausted, it is refilled as with REFILL.
\ #IF is an immediate word.
\ An ambiguous condition exists if #IF is POSTPONEd.
\ If the end of the input buffer is reached and cannot be refilled before the terminating
\ #ELSE, #THEN or #ENDIF is parsed then error -58 is thrown.
\ This word is designed to ignore object.ivar type words.
: #IFNDEF ( "aword" -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( "aword" | "aword<spaces>name" ... -- )
\ If "aword" is not found in the search order, do nothing. Otherwise, skipping
\ leading spaces, parse and discard
\ space-delimited words from the parse area, including nested occurrences of
\ #IF ... #THEN, #IF ... #ELSE ... #THEN, #IF ... #ENDIF and
\ #IF ... #ELSE ... #ENDIF, until either the word #ELSE,
\ the word #THEN or the word #ENDIF has been parsed and discarded.
\ If the parse area becomes exhausted, it is refilled as with REFILL.
\ #IF is an immediate word.
\ An ambiguous condition exists if #IF is POSTPONEd.
\ If the end of the input buffer is reached and cannot be refilled before the terminating
\ #ELSE, #THEN or #ENDIF is parsed then error -58 is thrown.
\ This word is designed to ignore object.ivar type words.
: #THEN ( -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( -- )
\ Does nothing. #THEN is an immediate word.
: DEFINITE-WORD 
: MATCH-[#] ( possibly match an #if #then #else ) 
( if-count c-addr -- if-count' ) 
: MATCH-[STR] ( cstr addr len -- cstr fl ) 
: MATCH-[] ( possibly match an [if] [then] [else] ) 
( if-count c-addr -- if-count' ) 
CONSTANT THROW_INTERPRETCONDITIONAL 
: [DEFINED] ( "aword" -- f1 ) 
\ Forth200X            TOOLS EXT
\ Compilation: Perform the execution semantics given below. 
\ Execution: Return true if "aword" is found in a search of the search order.
\ This word is designed to ignore object.ivar type words.
: [ELSE] ( -- ) 
\ ANSI             TOOLS EXT
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( "<spaces>name" ... -- )
\ Skipping leading spaces, parse and discard space-delimited words from the parse area,
\ including nested occurrences of [IF] ... [THEN] and [IF] ... [ELSE] ... [THEN], until
\ the word [THEN] has been parsed and discarded. If the parse area becomes exhausted,
\ it is refilled as with REFILL. [ELSE] is an immediate word.
: [ENDIF] ( -- ) 
\ W32F            TOOLS EXTRA
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( -- )
\ Does nothing. [ENDIF] is an immediate word.
: [IF] ( flag -- ) 
\ ANSI            TOOLS EXT
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( flag | flag "<spaces>name" ... -- )
\ If flag is true, do nothing. Otherwise, skipping leading spaces, parse and discard
\ space-delimited words from the parse area, including nested occurrences of
\ [IF] ... [THEN], [IF] ... [ELSE] ... [THEN], [IF] ... [ENDIF] and
\ [IF] ... [ELSE] ... [ENDIF], until either the word [ELSE],
\ the word [THEN] or the word [ENDIF] has been parsed and discarded.
\ If the parse area becomes exhausted, it is refilled as with REFILL.
\ [IF] is an immediate word.
\ An ambiguous condition exists if [IF] is POSTPONEd.
\ If the end of the input buffer is reached and cannot be refilled before the terminating
\ [ELSE], [THEN] or [ENDIF] is parsed then error -58 is thrown.
: [THEN] ( -- ) 
\ ANSI            TOOLS EXT
\ Compilation: Perform the execution semantics given below. 
\ Execution: ( -- )
\ Does nothing. [THEN] is an immediate word.
: [UNDEFINED] ( "aword" -- f1 ) 
\ Forth200X            TOOLS EXT
\ Compilation: Perform the execution semantics given below. 
\ Execution: Return false if "aword" is found in a search of the search order.
\ This word is designed to ignore object.ivar type words.
CODE ! ( n1 a1 -- ) 
\ store cell n1 into address a1
: !CSP ( -- ) 
\ save current stack pointer for later stack depth check
CODE "#HASH ( a1 n1 #threads -- n2 ) 
: ", ( a1 n1 -- ) 
\ compile string a1,n1 as a counted string at here
: "CLIP" ( c-addr1 len1 -- c-addr2 len2 ) 
\ W32F           String Extra
\ Clip string c-addr1,len1 to c-addr2,len2 where c-addr2=c-addr1 and
\ len2 is between 0 and MAXCOUNTED.
CODE "FIND-PROC ( addr len -- proccfa -1 | 0 ) 
\ find windows proc by name **WINED**
: "FLOAD \ synonym of INCLUDED
: "HEADER ( a1 n1 -- ) 
\ build header in same dict as wordlist
DEFER "OPEN ( a1 n1 -- fileid f1 ) 
\ open filename a1,n1  ( but not in editor )
DEFER "PUSHKEYS 
: "TO-PATHEND" ( a1 n1 --- a2 n2 ) 
\ return a2 and count=n1 of filename
: "WINLIBRARY ( adr len -- ) 
CODE # ( d1 -- d2 ) 
\ convert a digit in pictured number output - see <#
: #(;CODE) ( a1 -- ) 
CONSTANT #-LOCALS \ must match code above!!!!
: #> ( d1 -- addr len ) 
\ ends a pictured number output - see <#
: #DOES> ( -- ) 
\ "compile time"
( a1 -- ) 
\ "runtime" a1=cfa of word being defined
: #S ( d1 -- d2 ) 
\ consume last digits in a pictured number output - see <#
: #TAB ( n1 -- ) 
CONSTANT #TIB \ address of terminal input buffer length
CONSTANT #VOCS \ Maximum number of vocabularies in search order
: $CURRENT-DIR! ( a1 -- f1 ) 
\ a1 is a null terminated directory string
: $FLOAD ( a1 -- ) 
\ a1 = counted file string
: $OPEN ( addr -- fileid f1 ) 
\ open counted filename specified by addr
\ return fileid and f1=false=ok
USER &EXCEPT 
USER &EXREC 
VALUE &FORTHDIR \ The Win32Forth installation directory
\ (in turnkey applications it's the path of the exe-file).
: &OF ( "name" -- addr ) 
\ get the address of a value or local
VALUE &PROGNAM \ The program name buffer
\ (the name of the exe-file including the full path).
DEFER &THE-SCREEN 
: ' ( "name" -- cfa ) 
\ get cfa of parsed word
: ("HEADER) ( a1 n1 -- ) 
NCODE (&OF-LOCAL) ( -- addr ) 
\ get address of local following
NCODE (&OF-VALUE) ( -- addr ) 
\ push the literal value following onto the data stack
NCODE ((")) ( -- counted-string ) 
: ((VERSION)) ( version# -- addr len ) 
NCODE (+LOOP) ( n1 -- ) 
\ "runtime" bump count by n1 and branch to
\ after DO if loop count not complete
NCODE (.") ( -- addr len ) 
\ for ."
: (;CODE) ( -- ) 
NCODE (?DO) ( n1 n2 -- ) 
\ "runtime" setup loop using n1,n2, if n1=n2
\ then discard n1,n2 and branch to after DO
: (ABORT") ( f -- ) 
NCODE (C") ( -- addr ) 
\ for c" type strings
: (D.) ( d -- addr len ) 
\ convert as signed double to ascii string
NCODE (DO) ( n1 n2 -- ) 
\ "runtime" setup loop using n1,n2
: (DOES>) ( -- ) 
: (DPRWARN) ( f -- f ) 
\ warn if deprecated word was found
: (IS) ( xt -- ) 
: (LOCAL) ( addr cnt -- ) 
\ create name in LOCALS vocab
NCODE (LOOP) ( -- ) 
\ "runtime" bump count and branch to after
\ DO if loop count not complete
DEFER (MEMLOCK) 
DEFER (MEMUNLOCK) 
: (NUMBER?) ( addr len -- d1 f1 ) 
NCODE (S") ( -- addr len ) 
\ for s" type strings
NCODE (SEARCH-SELF) ( addr len wid -- 0 | cfa flag ) 
\ uses VSRCH to search this wordlist
CODE (SEARCH-WID) ( addr len voc -- 0 | cfa bfa ) 
\ this is the standard vocab vsrch
\ returns bfa = 1 for immediate words, and
\ bfa = -1 for "normal" words
CREATE (SOURCE) \ input stream pointer
: (WINPAUSE) 
NCODE (Z") ( -- addr ) 
\ for z" type strings
CODE * ( n1 n2 -- n3 ) 
\ multiply n1 by n2, return single result n3
: */ ( n1 n2 n3 -- quotient ) 
\ same as */MOD but gives only quotient
CODE */MOD ( n1 n2 n3 -- remainder quotient ) 
\ integer single multiply and divide:
\ give remainder and quotient of [n1*n2]/n3. Intermediate result n1*n2
\ is a double, so there is no overflow.
CODE + ( n1 n2 -- n3 ) 
\ add n1 to n2, return sum n3
CODE +! ( n1 a1 -- ) 
\ add cell n1 to the contents of address a1
CODE +CELLS ( n1 a1 -- n1*cell+a1 ) 
\ multiply n1 by the cell size and add
\ the result to address a1
: +LOOP 
CODE +NULL ( c-addr -- ) 
\ W32F        String Extra
\ Append a NULL to the counted string.
CODE +PLACE ( c-addr1 len1 c-addr2 -- ) 
\ W32F    String Extra
\ Append string addr1,len1 to the counted string at addr2.
: +TO ( n -<value_name>- ) 
\ Add to a value as in
\ 10 VALUE X  then  20 +TO X  sets X to 30
: +TO ( n -<value_name>- ) 
\ Add to a value as in
\ 10 VALUE X  then  20 +TO X  sets X to 30
: , ( n -- ) 
( compile cell at HERE, increment DP) 
: ," ( -<string">- ) 
\ compile string delimited by " as a counted string at here
CODE - ( n1 n2 -- n3 ) 
\ subtract n2 from n1, return difference n3
 -1 
NCODE -?BRANCH ( f1 -- fl ) 
\ non-destructive "runtime" for branch on f1=FALSE
CODE -ALIGNED ( addr1 -- addr2 ) 
CONSTANT -CELL 
CODE -CELLS ( n1 a1 -- a1-n1*cell ) 
\ multiply n1 by the cell size and
\ subtract the result from address a1
: -IF 
: -NULLS ( c-addr u1 -- c-addr u2 ) 
\ W32F          String Extra
\ If u1 is greater than zero, u2 is equal to u1 less the number of nulls at
\ the end of the character string specified by c-addr u1. If u1 is zero or the
\ entire string consists of nulls, u2 is zero.
CODE -ROT ( n1 n2 n3 -- n3 n1 n2 ) 
\ rotate top of data stack to third item
CODE -SCAN ( addr len char -- addr' len' ) 
\ Scan for char BACKWARDS starting
\ at addr, the end of the string, back through len bytes before addr,
\ returning addr' and len' of char.
CODE -SKIP ( addr len char -- addr' len' ) 
\ Skip occurances of char BACKWARDS
\ starting at addr, the end of the string, back through len bytes
\ before addr, returning addr' and len' of char.
CODE -TRAILCHARS ( c-addr u1 char -- c-addr u2 ) 
\ W32F          String Extra
\ If u1 is greater than zero, u2 is equal to u1 less the number of chars at
\ the end of the character string specified by c-addr u1. If u1 is zero or the
\ entire string consists of chars, u2 is zero.
: -TRAILING ( c-addr u1 -- c-addr u2 ) 
\ ANSI          String
\ If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
\ the end of the character string specified by c-addr u1. If u1 is zero or the
\ entire string consists of spaces, u2 is zero.
VALUE -VE-NUM? \ negate value flag
: . ( n -- ) 
\ display as signed single
: ." \ comp: ( -<string">- ) run: ( -- ) \ See also  s"  and  .(
\ Compiletime: Parses the input stream until it finds the next " and
\ compiles it into the current definition.
\ Runtime: Prints the compiled text to the console window
: .( ( -- ) 
\ - interpretation only -  ( see also  ."  and  S" )
\ parses the input stream until it finds the next ) and
\ prints the text beetween .( and ) in the console window
: .ID ( nfa -- ) 
\ display header's name
: .NAME ( xt -- ) 
\ show name, if can't find name, show address
: .R ( n w -- ) 
\ display as signed single right justified in w wide field
DEFER .REFILL 
: .S ( -- ) 
\ display current data stack contents
CREATE .SMAX 
: .VERSION ( -- ) 
: / ( n1 n2 -- quot ) 
\ integer single divide : quotient
CODE /MOD ( n1 n2 -- rem quot ) 
\ integer signed single divide with remainder & quotient
: /PARSE ( -- addr u ) 
: /PARSE-S$ ( -- a1 ) 
\ parse possibly quoted string
: /PARSE-WORD ( -- a1 ) 
CODE /STRING ( c-addr1 u1 n -- c-addr2 u2 ) 
\ ANSI   String
\ Adjust the character string at c-addr1 by n characters. The resulting character
\ string, specified by c-addr2 u2, begins at c-addr1 plus n characters and is u1
\ minus n characters long. 
\ If n1 greater than len1, then returned len2 will be zero. 
\ For early (pre Nov 2000) versions of W32F, if n1 less than zero,
\ then returned length u2 was zero.
\ /STRING is used to remove or add characters relative to the left end of the
\ character string. Positive values of n will exclude characters from the string
\ while negative values of n will include characters to the left of the string.
 0 
CODE 0< ( n1 -- f1 ) 
\ return true if n1 is less than zero
CODE 0<> ( n1 -- f1 ) 
\ return true if n1 is not equal to zero
CODE 0= ( n1 -- f1 ) 
\ return true if n1 equals zero
CODE 0> ( n1 -- f1 ) 
\ return true if n1 is greater than zero
CODE 0MAX ( n1 -- n2 ) 
\ return n2 the greater of n1 and zero
 1 
CODE 1+ ( n1 -- n2 ) 
\ add one to n1
CODE 1- ( n1 -- n2 ) 
\ subtract one from n1
 2 
CODE 2! ( d1 a1 -- ) 
\ store the double number d1 into address a1
CODE 2* ( n1 -- n2 ) 
\ multiply n1 by two
CODE 2/ ( n1 -- n2 ) 
\ signed divide n1 by two
CODE 2>R ( n1 n2 -- ) 
( R: -- n1 n2 ) 
\ push two items onto the returnstack
CODE 2@ ( a1 -- d1 ) 
\ fetch the double number d1 from address a1
: 2CONSTANT ( n1 n2 -- ) 
\ create a double constant
CODE 2DROP ( n1 n2 -- ) 
\ discard two single items - one double - from the data stack
CODE 2DUP ( n1 n2 -- n1 n2 n1 n2 ) 
\ duplicate the top two single items
\ on the data stack
CODE 2NIP ( n1 n2 n3 n4 -- n3 n4 ) 
\ discard third and fourth items from data stack
CODE 2OVER ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 ) 
\ copy second double on top
CODE 2R> ( -- n1 n2 ) 
( R: n1 n2 -- ) 
\ pop two items off the return stack
CODE 2R@ ( -- n1 n2 ) 
\ get a copy of the top two items on the return stack
CODE 2ROT ( n1 n2 n3 n4 n5 n6 -- n3 n4 n5 n6 n1 n2 ) 
\ rotate 3 double
CODE 2SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n2 ) 
\ exchange the two topmost doubles
: 2VARIABLE ( "name" -- ) 
\ create a double variable
CODE 3DROP ( n1 n2 n3 -- ) 
\ discard three items from the data stack
CODE 3DUP ( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 ) 
\ duplicate 3 topmost cells
CODE 3REVERSE ( n1 n2 n3 -- n3 n2 n1 ) 
\ exchange first and third items on data stack
CODE 4DROP ( n1 n2 n3 n4 -- ) 
\ discard four items from the data stack
CODE 4DUP ( a b c d -- a b c d a b c d ) 
\ duplicate 4 topmost cells
CODE 4REVERSE ( n1 n2 n3 n4 -- n4 n3 n2 n1 ) 
\ exchange first and fourth plus second and
\ third items on the data stack
 : 
: :NONAME ( -- xt ) 
\ start a headerless colon definition
: ; ( -- ) 
CODE < ( n1 n2 -- f1 ) 
\ return true if n1 is less than n2
: <# ( ud -- ) 
\ begin a pictured number output. Full example :
\ : test dup 0< if negate -1 else 0 then >r
\ s>d <# [char] $ hold # # [char] . hold # # # [char] , hold #S r> sign #>
\ cr type ;
\ 1234599 test    displays    12,345.99$
\ -1234599 test    displays   -12,345.99$
CODE <= ( n1 n2 -- f1 ) 
\ return true if n1 is less than n2
CODE <> ( n1 n2 -- f1 ) 
\ return true if n1 is not equal to n2
: <MARK ( -- addr ) 
: <RESOLVE ( addr -- ) 
CODE = ( n1 n2 -- f1 ) 
\ return true if n1 is equal to n2
CODE > ( n1 n2 -- f1 ) 
\ return true if n1 is greater than n2
CODE >= ( n1 n2 -- f1 ) 
\ return true if n1 is greater than n2
: >APPLICATION ( -- ) 
\ select app dict, save prev dict
CODE >BODY ( cfa -- pfa ) 
\ convert code field address to parameter field address
: >CODE ( -- ) 
\ select code dict, save prev dict
: >DP ( dp -- ) 
\ save the current DP, set new
: >FFA@ ( cfa -- ffa ) 
\ get the File Field Address
: >HEAD-FIELD ( cfa mask -- addr  ) 
\ get the optional field's address
VARIABLE >IN \ offset in to input stream
: >MARK ( -- addr ) 
CODE >NAME ( CFA -- NFA  ) 
\ search vocabs for cfa, return nfa
\ Follows the VOC-LINK pointer to all of the vocabularies, searches threads for CFA
\ EBX is CFA to search for. On exit, EBX is NFA
\ Uses: EAX is voc link field, ECX is voc thread fields, EDX is thread link entry
\ If entry is not found, returns NFA of [UNKNOWN]
CODE >NUMBER ( ud addr len -- ud addr len ) 
: >OFA@ ( cfa -- ofa@ ) 
\ get the Optimization Field Address value
CODE >R ( n1 -- ) 
( R: -- n1 ) 
\ push n1 onto the return stack
: >RESOLVE ( addr -- ) 
: >SYSTEM ( -- ) 
\ select sys dict, save prev dict
: >VIEW ( cfa -- vfa ) 
: >VIEW@ ( cfa -- ffa ) 
\ get the View Field Address
: ? ( addr -- ) 
\ display single stored at address
VALUE ?:M 
NCODE ?BRANCH ( f1 -- ) 
\ "runtime" for branch on f1=FALSE
: ?COMP 
DEFER ?CR ( n -- ) 
( stdout: CR if not room for n chars) 
: ?CSP ( -- ) 
\ check current stack pointer against saved stack pointer
: ?DEFEXT ( addr -- ) 
\ conditionally add a default extension
: ?DO 
CODE ?DUP ( n -- n [n] ) 
\ duplicate top of data stack if non-zero
: ?EXEC 
: ?EXIT ( F1 -- ) 
: ?EXIT ( F1 -- ) 
: ?IS ( xt -- xt ) 
\ error if not a deferred word
NCODE ?LEAVE ( f1 -- ) 
\ exit the current DO LOOP if f1=TRUE
: ?MEMCHK ( n1 -- ) 
\ test to see if we have enough memory
: ?MISSING ( f -- ) 
: ?PAIRS ( n1 n2 -- ) 
: ?STACK ( -- ) 
\ check the data stack for stack underflow
NCODE ?THROW ( f n -- ) 
\ SWAP IF THROW ELSE DROP THEN ;
DEFER ?UNSAVE-SRC 
CODE @ ( a1 -- n1 ) 
\ get the cell n1 from address a1
NCODE @(IP) ( -- n ) 
: ABORT ( -- ) 
: ABORT! ( addr -- ) 
\ abort, print counted string passed
: ABORT" ( flag -<ccc>- -- ) 
\ abort and display message ccc if flag is true
CODE ABS ( n -- |n| ) 
\ return the absolute value of n1 as n2
DEFER ACCEPT ( addr nbmax -- nb ) 
( stdin: input line) 
CODE ADD-LINK ( addr list -- ) 
\ W32F         List
\ Add a link to the head of a list.
CREATE ADP 
: ADVANCE-FILE ( len-ud fileid -- ior ) 
\ RELATIVE position file, not ANS \ ior - 0 = success
: AGAIN 
: AHEAD 
: ALIAS ( xt "name" -- ) 
\ W32F
\ Creates an alias of a word that is non-imediate (unless IMMEDIATE is used).
\ NOTE View of either name can go to the synonym instead (it depends which name
\ is found first in a full dictionary search).
: ALIGN ( -- ) 
\ align DP & pad
CODE ALIGNED ( addr1 -- addr2 ) 
\ addr2 is the next cell aligned address following addr1
: ALLOCATE ( u -- addr fl ) 
\ ansi version of malloc
: ALLOT ( n -- ) 
\ allocate n bytes at HERE, increment DP
CODE AND ( n1 n2 -- n3 ) 
\ perform bitwise AND of n1,n2, return result n3
: APP-ALIGN ( -- ) 
: APP-ALLOT ( n1 -- ) 
: APP-FREE ( -- n1 ) 
: APP-HERE ( -- a ) 
CONSTANT APP-OFFS 
: APP-ORIGIN ( -- a1 ) 
CONSTANT APP-SIZE 
CODE APPEND-LINK ( addr list -- ) 
\ W32F         List
\ Append a link to the end of a list.
: APPEND-STRAND ( cfa <-name-> -- ) 
\ add cfa to chain end
VALUE APPINST \ the application instance (origin of code), set in MAIN
: APPLICATION> ( -- ) 
\ back to previous DP  (synonym of DP>)
: ASCII-Z ( addr len buff -- buff-z ) 
\ W32F      String Extra
\ Make a null-terminated copy of string addr len in buff and return the address of the
\ first character.
CONSTANT ASSYNC-TASK 
USER BASE 
: BEGIN 
CODE BETWEEN ( n1 low high -- f1 ) 
\ f1=true if ( (n1 >= low) and (n1 <= high) )
CONSTANT BFA_DEPRECATED \ bit of header's field BFA : true if word is deprecated
CONSTANT BFA_FFA_PRESENT \ bit of header's field BFA : true if file field present
CONSTANT BFA_IMMEDIATE \ bit of header's field BFA : true if word is immediate
CONSTANT BFA_OFA_PRESENT \ bit of header's field BFA : true if optimize field present
CONSTANT BFA_UNUSED1 
CONSTANT BFA_UNUSED2 
CONSTANT BFA_UNUSED3 
CONSTANT BFA_VFA_PRESENT \ bit of header's field BFA : true if view field present
DEFER BG@ ( f b -- ) 
( stdout: get background color) 
: BIN 
: BINARY 
CODE BIT-MSB ( n -- msb ) 
\ most significant bit in n
CODE BIT-POP ( n -- bits-in-n ) 
\ population count of bits in ebx
CONSTANT BL 
NCODE BLANK ( c-addr u -- ) 
\ ANSI         String
\ If u is greater than zero, store the character value for space in u consecutive
\ character positions beginning at c-addr.
CODE BODY> ( pfa -- cfa ) 
\ convert parameter field address to code field address
DEFER BOOT 
CODE BOUNDS ( adr len -- lim first ) 
\ calculate loop bounds from adr,len
NCODE BRANCH ( -- ) 
\ "runtime" for branch always
CONSTANT BUILD# 
DEFER BYE 
CODE BYTE-SORT ( a1 n1 -- ) 
\ perform in place sort buffer a1 of n1 bytes
CODE C! ( c1 a1 -- ) 
\ store character c1 into address a1
: C" \ comp: ( -<string">- ) run: \ ( -- addr )
\ compile a string, delimiteb by " , from input stream. When
\ run, give the string as the address of its count byte
CODE C+! ( c1 a1 -- ) 
\ add character c1 to the contents of address a1
: C, ( n -- ) 
( compile byte at HERE, increment DP) 
CODE C@ ( a1 -- c1 ) 
\ fetch the character c1 from address a1
: CALL ( [args..] -<proc>- result ) 
\ compile or execute a windows procedure
CODE CALL-PROC ( [ n ] ep -- r ) 
\ call ep on top of stack
ASSEMBLER CALLF 
: CAPS-FIND ( str -- str FALSE | cfa flag ) 
: CASE 
: CATCH ( cfa -- flag ) 
\ execute the word given by its cfa in a way that
\ will pass control to the word just after CATCH, whatever an error
\ occurs while cfa is executed or not - see THROW which may be
\ used inside the word "cfa" to handle errors if any.
\ if no error occured, flag is 0, else the flag is given by THROW
\ Beware: if an error occurs, any parameters for the word "cfa" are
\ still on the stack, under "flag"
CODE CDECR ( addr -- ) 
\ decrement the BYTE contents of addr
CREATE CDP 
CONSTANT CELL 
CODE CELL+ ( a1 -- a1+cell ) 
\ add a cell to a1
CODE CELL+ ( a1 -- a1+cell ) 
\ add a cell to a1
CODE CELL- ( a1 -- a1-cell ) 
\ subtract a cell from a1
CODE CELL-SORT ( a1 n1 -- ) 
\ perform in place sort buffer a1 of n1 cells
CODE CELLS ( n1 -- n1*cell ) 
\ multiply n1 by the cell size
CODE CELLS+ ( a1 n1 -- a1+n1*cell ) 
\ multiply n1 by the cell size and add
\ the result to address a1
CODE CELLS- ( a1 n1 -- a1-n1*cell ) 
\ multiply n1 by the cell size and subtract
\ the result from address a1
OFFSET CFA>PROC ( addr -- addr ) 
\ offset to proc from cfa
: CFAPTR! ( xt -- ) 
\ set cfaptr to cfa
: CHAIN-ADD ( chain_address -<word_to_add>- ) 
\ Add chain item.
\ For normal forward chains.
: CHAIN-ADD-BEFORE ( chain_address -<word_to_add>- ) 
\ Add chain item
\ For reverse chains like BYE
VARIABLE CHAIN-LINK \ linked list of chains
: CHAIN-REMOVE ( cfa chain_address -- ) 
\ Remove the specified item from the chain.
: CHAR ( "c" -- char ) 
\ parse char from input stream and put its ascii code on stack.
\ If <c> is longer than a char, takes its first char.
\ If parse area is empty return 0.
CODE CHAR+ ( a1 -- a1+char ) 
\ add the characters size in bytes to a1
CODE CHARS ( n1 -- n1*char ) 
\ multiply n1 by the character size (1)
DEFER CHARWH 
CODE CINCR ( addr -- ) 
\ increment the BYTE contents of addr
DEFER CLASS>SYS 
: CLOSE-FILE ( fileid -- ior ) 
\ Does not save it
DEFER CLS ( -- ) 
( stdout: clear screen) 
: CMDLINE ( -- addr len ) 
\ fetch command line
NCODE CMOVE ( from to count -- ) 
\ move "count" bytes from address "from" to
\ address "to" - start with the first byte of "from"
NCODE CMOVE> ( from to count -- ) 
\ move "count" bytes from address "from" to
\ address "to" - start with the last byte of "from"
: CODE-, ( n -- ) 
: CODE-ALIGN ( -- ) 
: CODE-ALLOT ( n1 -- ) 
: CODE-C, ( n -- ) 
: CODE-FREE ( -- n1 ) 
: CODE-HERE ( -- a ) 
CONSTANT CODE-OFFS 
: CODE-ORIGIN ( -- a1 ) 
CONSTANT CODE-SIZE \ values set in meta compile
: CODE-W, ( n -- ) 
: CODE> ( -- ) 
\ back to previous DP  (synonym of DP>)
: COL ( n -- ) 
\ goto nth column
CODE COMPARE ( adr1 len1 adr2 len2 -- n ) 
\ COMPARE compares two strings. The return value is:
\ 0 = string1 = string2
\ -1 = string1 < string2
\ 1 = string1 > string2
CODE COMPILE ( -- ) 
\ compile xt following
: COMPILE, ( xt -- ) 
\ compile (same as , but with warning)
CREATE CONSFILE 
DEFER CONSOLE ( -- ) 
( stdout: switch I/O to console) 
: CONSTANT ( n "name" -- ) 
\ create a constant (unchangeable) value
VARIABLE CONTEXT 
CODE COUNT ( str -- addr len ) 
\ byte counted strings
DEFER CR ( -- ) 
( stdout: emit carriage return) 
: CREATE ( "<spaces>name" -- ) 
\ Create a definition for name.
: CREATE-FILE ( adr slen fmode -- fileid ior ) 
CREATE CRLF$ 
VARIABLE CSP \ Current Stack Pointer variable
VALUE CUR-FILE \ ptr to CUR-FILE
VARIABLE CURRENT 
: CURRENT-DIR$ ( -- a1 ) 
\ get the full path to the current directory
CODE D+ ( d1 d2 -- d3 ) 
\ add 2 doubles - no overflow check
CODE D- ( d1 d2 -- d3 ) 
\ substract 2 doubles
: D. ( d -- ) 
\ display as signed double
: D.R ( d w -- ) 
\ display as signed double right justified in w wide field
CODE D0< ( d1 -- f1 ) 
\ Signed compare d1 double number with zero.
: D0= ( d -- f) 
\ double compare to 0
CODE D2* ( d1 -- d2 ) 
\ multiply the double number d1 by two
CODE D2/ ( d1 -- d2 ) 
\ divide the double number d1 by two
CODE D< ( d1 d2 -- f ) 
\ Signed compare two double numbers.
: D<> ( d1 d2 -- d ) 
\ Signed compare two double numbers.
: D= ( d1 d2 -- f1 ) 
\ f1=true if double d1 is equal to double d2
: D> ( d1 d2 -- f ) 
\ Signed compare two double numbers.
: D>S ( d -- s ) 
\ convert double to single
CODE DABS ( d1 -- d2 ) 
\ return the absolute value of d1 as d2
: DECIMAL 
CODE DECR ( addr -- ) 
\ decrement the contents of addr
: DEFER ( "name" -- ) 
\ create a deferred execution function, defaults to a NOOP
\ Typical usage    ' new-action is deferred-action
\ -or- : new-word ['] new-action is deferred-action ;
\ See also: is-default restore-default action-of defer@ defer!
VARIABLE DEFER-LIST \ The head of a linked-list of deferred words
: DEFEXT ( -<F>- ) 
\ make -<F>- the default extension
CREATE DEFEXT$ ( -- a1 ) 
\ the default extension buffer (max 8 chars)
CONSTANT DEFEXTMAX 
CREATE DEFEXTZ$ ( -- a1 ) 
\ copy, with . and null terminated
VARIABLE DEFEXT_ON? \ January 17th, 2000 - 10:31 added to better
: DEFINED ( -- str 0 | cfa flag ) 
CREATE DELAYS 
: DELETE-FILE ( adr len -- ior ) 
\ ior - 0 = success
: DEPRECATED ( -- ) 
\ mark the last header created as a deprecated word
CODE DEPTH ( -- n ) 
\ return the current data stack depth (n excluded)
CODE DIGIT ( char base -- n flag ) 
: DLL ( 'name.DLL' <-name-> ) 
\ usage: DLL "USER32.DLL" USER32
: DMAX ( d1 d2 -- d3 ) 
\ Replace with the larger of the two (signed).
: DMIN ( d1 d2 -- d3 ) 
\ Replace with the smaller of the two (signed).
CODE DNEGATE ( d1 -- d2 ) 
\ negate d1, returning 2's complement d2
: DO 
DEFER DO-;CHAIN 
: DO-CHAIN ( chain_address -- ) 
\ Execute all words in a chain.
: DO-LINK ( i*x xt list -- j*x ) 
\ W32F        List
\ Apply input function, xt to each element of the list in turn. i*x and j*x are the
\ input(s) to and output(s) of xt (normally the number of inputs=number of outputs).
\ Usage: [parms] ' x link do-link 
\ Follows link, for each link executes x. x must have a stack picture
\ ( [parms ...] link -- [parms ...] ).
\ Safe to use even if x destroys next link and can be used recursively.
ASSEMBLER DO2VALUE 
ASSEMBLER DOCALL 
ASSEMBLER DOCALL-MULTI 
ASSEMBLER DOCALL-SINGLE 
ASSEMBLER DOCOL 
ASSEMBLER DOCON 
ASSEMBLER DODEFER 
ASSEMBLER DODOES 
: DODOES-CALL, ( -- ) 
\ compile call to does> (in code-only section)
: DOES> ( -- ) 
: DOES>? ( ip -- flag ) 
\ is cfa a does> section of code
ASSEMBLER DOEXTERN 
VALUE DOFCON 
CONSTANT DOLOCAL 
CONSTANT DOLOCAL! 
CONSTANT DOLOCAL+! 
ASSEMBLER DOOFF 
VARIABLE DOSCHAR 
VALUE DOUBLE? \ double value
ASSEMBLER DOUSER 
ASSEMBLER DOVALUE 
ASSEMBLER DOVALUE! 
ASSEMBLER DOVALUE+! 
ASSEMBLER DOVAR 
ASSEMBLER DOVOC 
VALUE DP \ data pointer defaults to app space
VARIABLE DP-LINK \ list of xDP structures
VALUE DP-LOCATION \ decimal point location
: DP> ( -- ) 
\ back to previous DP
: DPR-WARNING-OFF ( -- ) 
\ disable warning for use of deprecated words
: DPR-WARNING-ON ( -- ) 
\ enable warning for use of deprecated words
VALUE DPR-WARNING? 
CODE DROP ( n -- ) 
\ discard top entry on data stack
CODE DU< ( ud1 ud2 -- f1 ) 
\ return true if unsigned double ud1 is
\ less than unsigned double ud2
CODE DUP ( n -- n n ) 
\ duplicate top entry on data stack
: DUP-WARNING-OFF ( -- ) 
\ disable warning for redefinitions
: DUP-WARNING-ON ( -- ) 
\ enable warning for redefinitions
VALUE DUP-WARNING? 
CODE DUP>R ( n1 -- n1 ) 
( R: -- n1 ) 
\ push a copy of n1 onto the return stack
: D_ACCEPT ( c-addr nbmax -- nbread ) 
\ accept a string
: D_CR ( -- ) 
\ emit a carriage return
: D_EKEY ( -- u ) 
\ get extended char
: D_EKEY>CHAR ( u -- u false | char true ) 
\ is char ?
: D_EMIT ( char -- ) 
\ emit a character
: D_INIT-CONSOLE ( -- flg ) 
\ init kernel's DOS console, ff if already inited
: D_KEY ( -- char ) 
\ get key from keyboard
: D_KEY? ( -- flag ) 
\ is a char (ie key pressed) available ?
: D_TYPE ( addr cnt -- ) 
\ type a string
: D_UNINIT-CONSOLE ( -- ) 
\ free the character-mode console
VARIABLE ECHO \ ECHO ON echos everything to the console that's included
DEFER EDIT-ERROR 
: ELSE 
DEFER EMIT ( char -- ) 
( stdout: display char) 
: EMIT. ( n -- ) 
: EMPTY-COMMAND-LINE ( -- ) 
DEFER END-INCLUDE 
: ENDCASE 
: ENDIF 
: ENDOF 
NCODE ERASE ( addr u -- ) 
\ ANSI        Core Ext
\ If u is greater than zero, clear all bits in each of u consecutive address
\ units of memory beginning at addr .
: EVALUATE ( addr len -- ) 
\ interpret string addr,len
USER EXC-ACCESS 
USER EXC-GUARD 
ASSEMBLER EXCEPT-HANDLER 
CONSTANT EXCEPT-VALLOC \ points at VirtualAlloc ep
ASSEMBLER EXEC-SEQ 
NCODE EXECUTE ( cfa -- ) 
\ execute a Forth word, given its cfa
: EXECUTE-PARSING ( addr len xt -- ... ) 
ASSEMBLER EXEM 
: EXTERN ( "name" -- ) 
\ extern var
CONSTANT FALSE 
DEFER FG@ ( -- f ) 
( stdout: get foregroung color) 
DEFER FGBG! ( f b -- ) 
( stdout: set back and fore colors) 
: FIELD+ ( n1 n2 <-name-> -- n3 ) 
\ compiling n3=n1+n2 stored offset=n1
( addr1 -- addr2 ) 
\ runtime addr2=addr1+n1
: FILE-APPEND ( fileid -- ior ) 
\ ior - 0 = success
: FILE-POSITION ( fileid -- len-ud ior ) 
: FILE-SIZE ( fileid -- len-ud ior ) 
: FILE-STATUS ( adr len -- x ior ) 
#VOCABULARY FILES \ files vocab
NCODE FILL ( addr len char -- ) 
\ fill addr with char for len bytes
DEFER FIND ( str -- str 0 | cfa flag ) 
VALUE FIND-BUFFER \ ptr to FIND-BUFFER
: FLOAD ( -<filename>- ) 
\ load "filename" into application dictionary
: FLUSH-FILE ( fileid -- ior ) 
CODE FM/MOD ( d n -- rem quot ) 
VOCABULARY FORTH \ main vocabulary
\ #PTHREADS #LEXICON    PROCS             \ procs vocabulary; there's only 1
VOCABULARY FORTH \ main vocabulary
\ #PTHREADS #LEXICON    PROCS             \ procs vocabulary; there's only 1
CODE FPARMS-FP ( len-ud fileid move --  \ parms for file-position words using SetFilePointer \                -- MoveHigh move ptrMoveHigh MoveLow fileid ) 
\ results
\ ptr points here:   ^
: FREE ( addr -- f1 ) 
\ release the memory pointer
\ f1=TRUE=failed, f1=FALSE=ok
: FREE-DLL ( lib-entry -- ) 
\ free a lib entry
: FSAVE-FILE ( addr len filename -- ) 
DEFER GET-CURSOR 
DEFER GETCOLROW 
: GETLASTWINERR ( -- n ) 
\ get windows error code
: GETLASTWINERRMSG ( n -- addr ) 
\ build string for error message
DEFER GETROWOFF ( -- n ) 
( first visible row in new console) 
DEFER GETXY ( -- x y ) 
( stdout: get cursor position) 
DEFER GOTOXY ( x y -- ) 
( stdout: set cursor to x,y) 
: H. ( u -- ) 
\ display as signed single in hexadecimal whatever BASE is
: H.2 ( n1 -- ) 
: H.4 ( n1 -- ) 
: H.8 ( n1 -- ) 
: H.N ( n1 n2 -- ) 
\ display n1 as a HEX number of n2 digits
: H.R ( n1 n2 -- ) 
\ display n1 as a hex number right
\ justified in a field of n2 characters
USER HANDLER 
: HEADER ( "name" -- ) 
\ build a header
: HERE ( -- a1 ) 
( current dictionary pointer, points to next free space) 
: HEX 
#VOCABULARY HIDDEN \ hidden words
\ -------------------- Vocabulary dictionary structure ----------------------
\ [ cfa field        ] +0           VCFA = vocabulary cfa -> DOES> code
\ [ num voc threads  ] +4           #THREADS
\ [ voc link         ] +8           VLINK
\ [ voc header       ] +12          VHEAD
\ [ voc search       ] +16          VSRCH
\ [ voc iterate      ] +20          VITER
\ [ voc thread 0     ] +24          VOC thread 0 = voc-address
\ [ voc thread 1     ] +28          VOC thread 1
\ [ voc thread 2     ] +32          VOC thread 2
\ [ voc thread ...   ] +n*4+24      VOC thread n
: HIDE ( -- ) 
USER HLD 
CODE HOLD ( char -- ) 
\ insert char in number output picture - see <#
CODE I ( -- u ) 
\ push u, the value of the current loop index
CODE I' ( -- u ) 
\ push u, the value of the current loop limit
: IF 
VALUE IGNORE-MISSING-PROCS? \ used to ignore entry point missing, default is load now
\ -------------------- Required PROCs ---------------------------------------
CONSTANT IMG-ENTRY \ -------------------- Compiling words ----------------------------
\ DP is the current data pointer, DP @ is the equivalent of HERE
\ 
\ Each set of pointers to a data ("dictionary") space is a structure.
\ These structures MUST RESIDE IN THE APPLICATION SPACE if they are linked
\ 
\ CELL OFFSET  FUNCTION
\ ---- ------  --------
\ 0     0     Current pointer to area
\ 1     4     Address of the area (origin)
\ 2     8     Highest address of area (origin + length)
\ 4    16     Link of all the xDP areas; set in DP-LINK
\ 5    20     Counted name of the area
\ 
\ 3 defined by default; APP -- std area, SYS -- system area, not saved on
\ TURNKEY and CODE -- area for executable x86 code.
\ 
\ Actual values for these 3 are filled in by the meta compiler.
\ See also PDP and LDP (procs and locals data respectively)
: IMMEDIATE ( -- ) 
\ mark the last header created as an immediate word
: IN-APPLICATION ( -- ) 
\ w32f
\ Activate the application data area.
: IN-CODE ( -- ) 
\ w32f
\ Activate the code data area.
: IN-PREVIOUS ( -- ) 
\ w32f
\ Restore the data area after a call to IN-APPLICATION IN-SYSTEM or IN-CODE.
: IN-SYS? ( -- f ) 
: IN-SYSTEM ( -- ) 
\ w32f
\ Activate the system data area.
: INCLUDE \ synonym of FLOAD
: INCLUDE-FILE ( fileid -- ) 
\ load file open on "fileid" to current dictionary
: INCLUDED ( addr len -- ) 
\ load file addr,len into current dictionary
VALUE INCLUDING? 
CODE INCR ( addr -- ) 
\ increment the contents of addr
VALUE INH \ console input handle
DEFER INIT-CONSOLE 
NCODE INIT-LOCALS ( loc1 loc2 ... -- ) 
DEFER INIT-SCREEN 
VALUE INPARMS \ number of input parameters (locals)
CREATE INP_REC 
: INSERT-STRAND ( cfa <-name-> -- ) 
\ add cfa to chain start
DEFER INTERPRET 
CODE INVERT ( n1 -- n2 ) 
\ perform a bitwise -1 XOR on n1, return result n2
: IS ( xt "name" -- ) 
\ assign xt to a defer
: ISABSOLUTEPATH? ( a1 n1 -- f ) 
\ returns true if path is absolute
CODE ISTR= ( adr1 len1 adr2 len2 -- flag ) 
\ compares two strings, case insensitive, true if equal
CODE J ( -- u ) 
\ push u, the value of the outer loop index
CODE J' ( -- u ) 
\ push u, the value of the outer loop limit
CODE K ( -- u ) 
\ push u, value of the second outer loop index
CODE K' ( -- u ) 
\ push u, the value of the second outer loop limit
KERNEL32.DLL K32DLL 
CONSTANT KERNFILE \ kernel file
DEFER KEY ( -- k ) 
( stdin: get a key ) 
DEFER KEY ( -- k ) 
( stdin: get a key ) 
: KWORDS ( -- ) 
\ simple version of words
: K_BYE ( -- ) 
\ Exit Forth
: K_NOOP0 
: K_NOOP1 
: K_NOOP2 
OFFSET L>NAME ( lfa -- nfa ) 
\ Convert link address to name address.
CODE LARGEST ( a1 n1 --- a2 n2 ) 
VARIABLE LAST \ NFA of last header created
VALUE LAST-ERROR \ last forth error reported
VARIABLE LAST-LINK \ address of last link for last header created
VARIABLE LATEST-NFA 
VARIABLE LATESTXT 
CREATE LCASETAB \ LOWERcase a thru z to A thru Z
CODE LCOUNT ( str -- addr len ) 
\ long (4 bytes) counted strings
NCODE LEAVE ( -- ) 
\ unconditionnaly exit the current DO LOOP
VALUE LEN-PREV 
OFFSET LIB>HANDLE ( addr -- addr ) 
\ offset from link to pfa
OFFSET LIB>NAME ( addr -- addr ) 
\ offset to lib name
: LINK, ( list -- ) 
\ W32F           List
\ Add a link in the dictionary (i.e. at here) to the head of the list.
CODE LINK> ( link -- cfa ) 
\ Convert the link address to the CFA (xt).
OFFSET LINK>HADDR ( addr -- addr' ) 
\ from link to heap address
OFFSET LINK>MEM ( addr -- addr' ) 
\ from link to mem pointer
: LINKFILE ( a1 -- ) 
\ link name a1 as current file IF LOADING ONLY !!
NCODE LIT ( -- n ) 
\ push the literal value following LIT in the
\ dictionary onto the data stack
: LITERAL ( n -- ) 
: LOAD-DLL ( lib-entry -- f1 ) 
\ f1=TRUE if all is ok
VALUE LOADFILE \ pointer to loaded filename
: LOADING? ( -- flag ) 
\ are we loading?
VARIABLE LOADLINE 
LOCAL LOCAL0 
LOCAL LOCAL1 
LOCAL LOCAL10 
LOCAL LOCAL11 
LOCAL LOCAL12 
LOCAL LOCAL13 
LOCAL LOCAL14 
LOCAL LOCAL15 
LOCAL LOCAL2 
LOCAL LOCAL3 
LOCAL LOCAL4 
LOCAL LOCAL5 
LOCAL LOCAL6 
LOCAL LOCAL7 
LOCAL LOCAL8 
LOCAL LOCAL9 
: LOCALALLOC ( n1 -- a1 ) 
\ allocate n1 bytes of return stack
\ return a1 the address of the array
: LOCALALLOC: ( n1 "name" -- ) 
\ allocate a local n1 byte buffer to local "name"
#VOCABULARY LOCALS \ locals vocab
: LOCALS| ( -- ) 
\ ANS standard locals
VALUE LOCFLG \ 1 = compiling args, 0 = compiling locals
: LOOP 
: LOWER ( addr len -- ) 
\ translate string to lowercase
USER LP 
CODE LSCAN ( adr len long -- adr' len' ) 
\ search first occurence of cell "long" in string
CODE LSHIFT ( u1 n -- u2 ) 
\ shift u1 left by n bits (multiply)
CODE LSKIP ( adr len long -- adr' len' ) 
\ skip leading cells "long" in string
CODE M* ( n1 n2 -- d1 ) 
\ multiply n1 by n2, return double result d1
CONSTANT MAIN-TASK 
: MAIN? ( -- f ) 
\ Returns true if this is the main (i.e. console task).
: MALLOC ( u -- addr ) 
\ allocate dynamic memory
CONSTANT MALLOC-ADJLEN \ adjustment for headers + extra cells
CONSTANT MALLOC-HFLAG \ heap flags
VARIABLE MALLOC-LINK \ head of single linked list
CODE MAX ( n1 n2 -- n3 ) 
\ return the greater of n1 and n2
CONSTANT MAX-HANDLE \ maximum length of filename
CONSTANT MAX-PATH \ maximum length of a filename buffer
VALUE MAXASCII \ to support xchar extension
CONSTANT MAXCOUNTED \ maximum length of contents of a counted string
\ -------------------- System WIde Constants --------------------------------
CONSTANT MAXSTRING \ maximum length of a counted string
DEFER MESSAGE 
: MHEAPSIZE ( rel-addr -- n ) 
\ size of abs-addr bytes
CODE MIN ( n1 n2 -- n3 ) 
\ return the lesser of n1 and n2
: MOD ( n1 n2 -- rem ) 
\ integer single divide : remainder
NCODE MOVE ( source dest len -- ) 
\ move len bytes from source address to dest address
ASSEMBLER MOVE-LOCALS 
DEFER MS 
VARIABLE MSG 
OFFSET N>BFA ( nfa -- bfa ) 
\ Convert neme address to the address of the bit fields.
OFFSET N>CFAPTR ( nfa -- cfa-ptr ) 
\ Convert name address to the address of the CFA pointer address.
: N>HEAD ( nfa -- head-fields ) 
OFFSET N>LINK ( nfa -- lfa ) 
\ Convert name address to link address.
: NABORT! ( addr n -- ) 
\ set message, n throw
CODE NALIGNED ( addr n -- addr2 ) 
VALUE NAME-MAX-CHARS \ function names can be this long
CODE NAME> ( nfa -- cfa ) 
\ Convert the name address to the CFA (xt).
CODE NEGATE ( n1 -- n2 ) 
\ negate n1, returning 2's complement n2
DEFER NEW$ 
: NEW-CHAIN ( -- ) 
\ Create a new chain.
: NEW-SYS-CHAIN ( -- ) 
\ Create a new chain in the system space.
: NEWUSER ( size "name" -- ) 
\ Creates a user. A user can be
\ a byte, cell, float, string or stack
ASSEMBLER NEXT-SEQ 
VARIABLE NEXT-USER \ offset of next defineable user variable
: NEXTWORD ( char -- adr flag ) 
\ flag=TRUE if we got a word, else FALSE
: NFA-COUNT ( nfa -- addr count ) 
CODE NIP ( n1 n2 -- n2 ) 
\ discard second item on data stack
CODE NOOP ( -- ) 
\ the Forth no-operation word (does nothing)
: NOOP-CHAIN-ADD ( chain_address -- addr ) 
\ Add chain item, return addr of cfa added.
\ For normal forward chains.
: NOOP-CHAIN-ADD-BEFORE ( chain_address -- addr ) 
\ Add chain item, return addr of cfa added.
\ For reverse chains like BYE
: NUF? ( -- f1 ) 
CONSTANT NULL 
: NUM-INIT ( -- ) 
\ initialise number values
DEFER NUMBER 
DEFER NUMBER, 
: OCTAL 
VALUE ODP \ data pointer defaults to app space
\ ----------------- Switching dictionary words ---------------
\ To switch between data areas, >DP saves and resets the data pointer.
\ NOTE: >DP does a "double UNNEST", so >DP must be the last word in
\ any definition that uses it.
\ 
\ IN-xxxx is used in open code to switch HERE ALLOT , W, etc to point
\ to the specific data area; the current DP is saved in ODP, so
\ it can be reseted using IN-PREVIOUS.
\ 
\ >XXXX and XXXX> move to and from a specific data area, and save the
\ current DP. Should only be used in code, as the return stack is used
\ to save/restore the current value, and must be used in matching pairs.
\ 
: OF 
: OFA-LAST ( -- addr ) 
\ address of last OFA
CODE OFF ( addr -- ) 
\ set the contents of addr of OFF (0)
: OFFSET ( n1 <-name-> -- ) 
\ compiling
( n2 -- n3 ) 
\ runtime n3=n1+n2
: OK ( -- ) 
CODE ON ( addr -- ) 
\ set the contents of addr to ON (-1)
USER OP 
: OPEN-FILE ( adr slen fmode -- fileid ior ) 
CODE OR ( n1 n2 -- n3 ) 
\ perform bitwise OR of n1,n2, return result n3
VALUE OUTH \ console output handle
CODE OVER ( n1 n2 -- n1 n2 n1 ) 
\ copy second item to top of data stack
USER PAD 
: PARMFIND ( addr -- addr FALSE | cfa -1 | cfa 1 ) 
VALUE PARMS \ number of parameters (locals)
: PARMS-INIT ( -- ) 
CODE PARSE ( char "ccc<char>" -- c-addr u ) 
\ parse the input stream
\ for a string delimited by char. Skip ONLY ONE leading char.
\ Give the string as address and count.
ALIAS PARSE-WORD 
ALIAS PARSE-WORD 
CREATE PDP 
NCODE PERFORM ( addr -- ) 
\ execute a Forth word whose cfa is stored at addr
CODE PICK ( ...  k -- ... n[k] ) 
CODE PLACE ( c-addr1 len1 c-addr2 -- ) 
\ W32F           String Extra
\ Place string c-addr1,len1 at c-addr2 as a counted string.
VALUE POCKET \ ptr to POCKET allocated in MAIN
: POSTPONE ( "name" -- ) 
\ compilation only - compile xt of word
: PROC ( #params "name" -- ) 
\ #arguments proc MessageBeep
DEFER PROC-ERROR 
OFFSET PROC>CFA ( addr -- addr ) 
\ offset to proc cfa
OFFSET PROC>EP ( addr -- addr ) 
\ offset to proc ep
OFFSET PROC>LIB ( addr -- addr ) 
\ offset to lib pointer
OFFSET PROC>NAME ( addr -- addr ) 
\ offset to proc name
\ -------------------- Resolving Procedures ---------------------------------
OFFSET PROC>PCNT ( addr -- addr ) 
\ offset to proc count
CREATE PTRNULL 
DEFER PUSHKEY 
: QUERY ( -- ) 
\ accept a line of input from the user to TIB
: QUERY-INTERPRET ( -- ) 
: QUIT ( -- ) 
CONSTANT R/O \ GENERIC_READ
CONSTANT R/W \ READ/WRITE
CODE R> ( -- n1 ) 
( R: n1 -- ) 
\ pop n1 off the return stack
CODE R>DROP ( -- ) 
( R: n1 -- ) 
\ discard one item off of the return stack
CODE R@ ( -- n1 ) 
( R: n1 -- n1 ) 
\ get a copy of the top of the return stack
CODE RDROP ( -- ) 
( R: n1 -- ) 
\ discard one item off of the return stack
: READ-FILE ( b-adr b-len fileid -- len ior ) 
\ ior = 0 = success
: READ-LINE ( adr len fileid -- len eof ior ) 
: REALLOC ( u addr -- addr' fl ) 
: RECURSE ( -- ) 
\ cause current definition to execute itself
: REFILL ( -- f ) 
\ refill TIB from current input stream
: RELEASE ( addr -- ) 
\ release block
: RENAME-FILE ( adr1 len adr2 len -- ior ) 
: REPEAT 
: REPOSITION-FILE ( len-ud fileid -- ior ) 
\ ior - 0 = success
: RES-LOADPROC ( procname lib -- proc-ep | 0 ) 
\ helper to get proc address
: RES-MULTI-LIBS ( proc-cfa -- ) 
\ resolve proc address, search all libs
: RES-SINGLE-LIB ( proc-cfa -- ) 
\ resolve proc address, search the specified lib
DEFER RESET-STACKS 
: RESIZE ( a1 n1 -- a2 f1 ) 
\ ansi version of realloc
: RESIZE-FILE ( len-ud fileid -- ior ) 
: RESTORE-INPUT ( ... 7 -- flag ) 
\ restore input
NCODE RETURNF ( -- ) 
\ internal ITC word for return
: REVEAL ( -- ) 
#VOCABULARY ROOT \ root vocab
CODE ROT ( n1 n2 n3 -- n2 n3 n1 ) 
\ rotate third item to top of data stack
CODE RP! ( a1 -- ) 
\ set the address of the return stack
USER RP0 
CODE RP@ ( -- a1 ) 
\ get a1 the address of the return stack
CODE RSHIFT ( u1 n -- u2 ) 
\ shift u1 right by n bits (divide)
: S" \ comp: ( -<string">- ) run: ( -- addr len )
\ Compiletime: s" parses the input stream until it finds the next " and
\ compiles it into the current definition. Runtime: s" leaves the address
\ and the length of the compiled string on the stack.
CODE S-REVERSE ( n[k]..2 1 0 k -- 0 1 2..n[k] ) 
\ w32f
\ Reverse n items on stack   
\ Usage: 1 2 3 4 5 5 S_REVERSE ==> 5 4 3 2 1
CODE S>D ( n1 -- d1 ) 
\ convert single signed single n1 to a signed
\ double d1
: SAVE-INPUT ( -- ... 7 ) 
\ save input
DEFER SAVE-SRC 
CODE SCAN ( adr len char -- adr' len' ) 
\ search first occurence of char "char" in string
VALUE SCREENDELAY \ delay value for some screen output
DEFER SCROLLTOVIEW 
CREATE SDP 
CODE SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag ) 
\ Search the string specified by c-addr1 u1 for the (sub)string specified by c-addr2 u2.
\ If flag is true, a match was found at c-addr3 with u3 characters remaining.
\ If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
: SEARCH-WORDLIST ( addr len wid -- 0 | cfa flag ) 
\ SEARCH-WORDLIST is case insensitive
DEFER SET-CURSOR 
DEFER SETCHARWH 
: SIGN ( f1 -- ) 
\ insert a sign in pictured number output - see <#
CODE SKIP ( adr len char -- adr' len' ) 
\ skip leading chars "char" in string
VALUE SLFACTOR \ adjust this to slow down loading
: SLITERAL ( a1 n1 -- ) 
\ compile string as literal
: SLOW ( -- ) 
CODE SM/REM ( d n -- rem quot ) 
: SOURCE ( -- addr len ) 
VALUE SOURCE-ID 
VALUE SOURCE-POSITION \ readded for cf32 port (Samstag, August 13 2005 dbu)
\ Renamed ?LOADING to LOADING? because ?LOADING was defined as a variable
\ in older w32f versions (Dienstag, Oktober 03 2006 dbu).
CODE SP! ( addr -- ) 
\ set the data stack to point to addr
USER SP0 
CODE SP@ ( -- addr ) 
\ get addr, the pointer to the top item on data stack
: SPACE ( -- ) 
\ emit a space
: SPACES ( n -- ) 
\ emit n spaces
VALUE SPCS 
CONSTANT SPCS-MAX ( optimization for SPACES ) 
DEFER STACK-CHECK 
DEFER START-INCLUDE 
: START-INTERPRETER ( -- ) 
DEFER START/STOP 
VARIABLE STATE 
CODE STR= ( adr1 len1 adr2 len2 -- flag ) 
\ compares two strings, case sensitive, same as COMPARE 0=
: STRAND ( <-name-> -- ) 
\ new chain
VARIABLE SUPPRESS 
CODE SW@ ( a1 -- w1 ) 
\ fetch and sign extend the word (16bit) w1 from address a1
CODE SWAP ( n1 n2 -- n2 n1 ) 
\ exchange first and second items on data stack
: SYNONYM ( "newname" "oldname" -- ) 
\ 200X
\ Creates an alias of a word that will be immediate if the original word was
\ immediate.  The word order is the same as when making a colon definition.
\ <newname> is hidden during the search for <oldname> so that an alias of an
\ existing word in another vocabulary can be created (NOTE versions prior to
\ V6.10.05 and V6.11.10 incorrectly created a void definition when <newname>
\ was found in the search. If <oldname> is not found then <newname> remains
\ hidden (only since V6.10.05 and V6.11.10).
\ NOTE View of either name can go to the synonym instead (it depends which name
\ is found first in a full dictionary search).
: SYS-, ( n -- ) 
: SYS-ADDR? ( a -- f ) 
\ is it a system address?
: SYS-ALIGN ( -- ) 
: SYS-ALLOT ( n1 -- ) 
: SYS-C, ( n -- ) 
VARIABLE SYS-CHAIN-LINK \ linked list of system chains
: SYS-COMPILE ( -- ) 
: SYS-COMPILE, ( xt -- ) 
: SYS-FLOAD ( -<filename>- ) 
\ load "filename" into system dictionary
: SYS-FREE ( -- n1 ) 
: SYS-HERE ( -- a ) 
CONSTANT SYS-OFFS 
: SYS-ORIGIN ( -- a1 ) 
CONSTANT SYS-SIZE 
: SYS-W, ( n -- ) 
: SYS-WARN-DOES? ( newcode destxt -- ) 
: SYS-WARNING-OFF ( -- ) 
\ disable warning for use of system words in application
: SYS-WARNING-ON ( -- ) 
\ enable warning for use of system words in application
VALUE SYS-WARNING? 
: SYSTEM> ( -- ) 
\ back to previous DP  (synonym of DP>)
: TASK-CLEAR ( u -- ) 
\ Clear task-status bit.
ASSEMBLER TASK-ENTRY 
: TASK-FLIP ( u -- ) 
\ Toggle task-status bit.
: TASK-SET ( u -- ) 
\ Set task-status bit to true.
: TASK-STATUS? ( u -- f ) 
\ Test task-status bit.
USER TCB 
VALUE TEMP$ \ ptr to TEMP$
: THEN 
: THROW ( n -- ) 
\ throw an error, identified by n, while executing a word
\ whose execution is "protected" by CATCH .
VARIABLE THROW_MSGS 
: TIB ( -- addr ) 
: TO ( n -<value_name>- ) 
\ store n in a value. Ex: -1 TO myvalue
: TO ( n -<value_name>- ) 
\ store n in a value. Ex: -1 TO myvalue
CODE TOGGLE ( addr byte -- ) 
\ XOR the byte contents of "addr" with "byte"
CODE TR ( addr len table -- ) 
\ translate a buffer
CODE TRTNZ ( addr len table -- addr' len' code ) 
\ translate & test a buffer, stop at ~0
CODE TRTZ ( addr len table -- addr' len' ) 
\ translate & test a buffer, stop at =0
CONSTANT TRUE 
CODE TUCK ( n1 n2 -- n2 n1 n2 ) 
\ copy top data stack to under second item
: TURNKEYED? ( -- f ) 
\ return true if running as a Turnkey application
DEFER TYPE ( addr len -- ) 
( stdout: display string) 
: U. ( u -- ) 
\ display as unsigned single
: U.R ( u w -- ) 
\ display as unsigned single right justified in w wide field
CODE U2/ ( n1 -- n2 ) 
\ unsigned divide n1 by two
CODE U< ( u1 u2 -- f1 ) 
\ return true if unsigned u1 is less than
\ unsigned u2
CODE U> ( u1 u2 -- f1 ) 
\ return true if unsigned u1 is greater than
\ unsigned n2
CREATE UCASETAB \ uppercase a thru z to A thru Z
CODE UM* ( u1 u2 -- ud1 ) 
\ multiply unsigned u1 by unsigned u2
CODE UM/MOD ( ud1 u1 -- rem quot ) 
\ divide unsigned double ud1 by the
\ unsigned number u1
CODE UMAX ( u1 u2 -- n3 ) 
\ return the greater of unsigned u1 and
\ unsigned u2
CODE UMIN ( u1 u2 -- n3 ) 
\ return the lesser of unsigned u1 and
\ unsigned u2
CODE UN-LINK ( addr link -- f1 ) 
\ W32F        List
\ Unlink addr from list. f1 is 0 if addr was removed from list or non-zero if addr
\ wasn't in the list.
CODE UNDER+ ( a x b -- a+b x ) 
\ add top of stack to third stack item
DEFER UNLOAD-FORTH 
NCODE UNLOOP ( -- ) 
\ discard LOOP parameters from return stack
NCODE UNNEST ( -- ) 
\ exit the current Forth definition
NCODE UNNESTP ( -- ) 
\ exit the current Forth definition, remove parms
NCODE UNNESTP ( -- ) 
\ exit the current Forth definition, remove parms
: UNTIL 
CODE UP! ( addr -- ) 
\ set the pointer to the user area
CODE UP@ ( -- addr ) 
\ get the pointer to the user area
CODE UPC ( char -- char ) 
\ convert char to uppercase
: UPPER ( addr len -- ) 
\ translate string to uppercase
NCODE UPPERCASE ( str -- str ) 
\ translate to uppercase, but not '.' or '.
: USER ( n "name" -- ) 
\ create a user variable (changeable) value
CONSTANT USEREXTRA ( add to USERMIN if you are going to do I/O ) 
( *1 ) 
CONSTANT USERMIN ( absolute min user area ) 
CONSTANT USEROFFS ( user offset, 3 cells ) 
\ The following words are for altering the task-status bits so u should be a power of 2 representing
\ the relevant mask.
CONSTANT USERSIZE \ user area size for task variables
: VALUE ( n "name" -- ) 
\ create a self fetching changeable value
: VARIABLE ( "name" -- ) 
\ create a variable (changeable) value
OFFSET VCFA>VOC ( vocabulary-cfa -- voc-address ) 
CONSTANT VERSION# 
OFFSET VLINK>VOC ( voc-link-field -- voc-address ) 
: VOC#THREADS ( voc-address -- #threads ) 
DEFER VOC-ALSO 
VARIABLE VOC-LINK \ linked list of vocabularies
\ Vocabularies; currently, these MUST be defined as specified
OFFSET VOC>VCFA ( voc-address -- vocabulary-cfa ) 
OFFSET VOC>VLINK ( voc-address -- voc-link-field ) 
CODE W! ( w1 a1 -- ) 
\ store word (16bit) w1 into address a1
CODE W+! ( w1 a1 -- ) 
\ add word (16bit) w1 to the contents of address a1
: W, ( n -- ) 
( compile word at HERE, increment DP) 
CONSTANT W/O \ GENERIC_WRITE
CODE W@ ( a1 -- w1 ) 
\ fetch the word (16bit) w1 from address a1
: WAIT ( -- ) 
VARIABLE WARNING 
: WARNMSG ( n -- ) 
\ prints Warning:
CODE WCOUNT ( str -- addr len ) 
\ word (2 bytes) counted strings
: WHILE 
VARIABLE WINERRMSG 
VARIABLE WINLIB-LAST \ last library found/defined
VARIABLE WINLIB-LINK \ linkage for libraries
: WINLIBRARY ( 'name.DLL' -- ) 
\ usage: WINLIBRARY user32.dll
DEFER WINPAUSE ( -- ) 
\ release control to OS for a moment, pump the message loop
VARIABLE WINPROC-LAST \ last proc found/defined
VARIABLE WINPROC-LINK \ linkage for procedures
CODE WITHIN ( n1 low high -- f1 ) 
\ f1=true if ( (n1 >= low) and (n1 < high) )
CODE WORD ( char "<chars>ccc<char>" -- c-addr ) 
\ parse the input stream for a string delimited by char. Skip all leading char. Give a
\ counted string (the string is ended with a blank, not included in count).
\ If char is a blank treat all control characters as delimiter.
\ Use only inside colon definition.
CODE WORD-JOIN ( low high -- n1 ) 
\ join the high and low 16bit quantities
\ into a single 32bit n1
CODE WORD-SPLIT ( u1 -- low high ) 
\ split the unsigned 32bit u1 into its high
\ and low 16bit quantities.
: WRITE-FILE ( adr slen fileid -- ior ) 
\ ior = 0 = success
: WRITE-LINE ( adr len fileid -- ior ) 
CODE WSCAN ( adr len word -- adr' len' ) 
\ search first occurence of word "word" in string
CODE WSKIP ( adr len word -- adr' len' ) 
\ skip leading words "word" in string
CODE XOR ( n1 n2 -- n3 ) 
\ perform bitwise XOR of n1,n2, return result n3
: Z" ( -<string">- ) 
\ If compiling puts string in the dictionary
: Z", ( addr len -- ) 
\ W32F     String Extra
\ compile the string, addr len as uncounted chars at here
: Z," ( -<string">- ) 
\ compile string delimited by " as uncounted
\ chars null-terminated chars at here
CODE ZCOUNT ( str -- addr len ) 
\ null terminated string, whose 1rst char is at addr
DEFER [ 
: ['] ( "name" -- ) 
\ compile xt of "name" as a literal
: [CHAR] ( <c> -- char ) 
\ parse char from input stream and compile its
\ ASCII value as a literal
: [COMPILE] ( "name" -- ) 
\ compile the xt of word "name"
: \ ( -- ) 
DEFER \N->CRLF ( a1 n1 -- ) 
DEFER ] 
: _"OPEN ( a1 n1 -- fileid f1 ) 
\ open filename a1,n1
\ return fileid and f1=false=ok
NCODE _AGAIN ( -- ) 
\ "runtime" branch back to after BEGIN
NCODE _BEGIN ( -- ) 
\ "runtime" marker for the decompiler, a noop
NCODE _CASE ( -- ) 
\ "runtime" marker for the decompiler, a noop
VALUE _CONHNDL \ window handle for the original console handle
NCODE _ENDCASE ( n1 -- ) 
\ "runtime" discard n1 and continue
NCODE _ENDOF ( -- ) 
\ "runtime" branch to after ENDCASE
: _HEADER-OFA ( -- ) 
\ optional fields
: _INTERPRET ( -- ) 
NCODE _LOCALALLOC ( n1 -- a1 ) 
NCODE _LOCALALLOCP ( n1 -- a1 ) 
NCODE _LOCALFREE ( -- ) 
\ release local allocation
: _MESSAGE ( n -- ) 
\ prints Error:
: _NUMBER, ( d -- ) 
NCODE _OF ( n1 n2 -- [n1] ) 
\ "runtime"
\ if n1<>n2 branch to after ENDOF, return n1
\ else continue and don't return n1
: _PROC-ERROR ( addr -- ) 
NCODE _REPEAT ( -- ) 
\ "runtime" branch back to after BEGIN
: _RESET-STACKS ( ?? -- ) 
\ reset the stack
: _START/STOP ( -- ) 
NCODE _THEN ( -- ) 
\ "runtime" marker for the decompiler, a noop
NCODE _UNTIL ( f1 -- ) 
\ "runtime" if f1=FALSE branch to after BEGIN
NCODE _WHILE ( f1 -- ) 
\ "runtime" if f1=FALSE branch to after REPEAT
: _[ ( -- ) 
\ turn off compiling
: _] ( -- ) 
: { ( -- ) 
\ begin local variable usage in the form;
\ { initedloc1 initedloc2 \ uninitedloc3 -- comments }
: {: ( -- ) 
\ begin local variable usage in the form;
\ {: initedloc1 initedloc2 \ uninitedloc3 -- comments :}
: +K_ALT ( c1 -- c2 ) 
: +K_CONTROL ( c1 -- c2 ) 
: +K_SHIFT ( c1 -- c2 ) 
: FKEY ( n1 -<name>- ) 
SPLKEY K-DOWN 
SPLKEY K-DOWN 
SPLKEY K-END 
SPLKEY K-END 
FKEY K-F1 
FKEY K-F1 
FKEY K-F10 
FKEY K-F10 
FKEY K-F11 
FKEY K-F11 
FKEY K-F12 
FKEY K-F12 
FKEY K-F2 
FKEY K-F2 
FKEY K-F3 
FKEY K-F3 
FKEY K-F4 
FKEY K-F4 
FKEY K-F5 
FKEY K-F5 
FKEY K-F6 
FKEY K-F6 
FKEY K-F7 
FKEY K-F7 
FKEY K-F8 
FKEY K-F8 
FKEY K-F9 
FKEY K-F9 
SPLKEY K-HOME 
SPLKEY K-HOME 
SPLKEY K-NEXT 
SPLKEY K-NEXT 
SPLKEY K-PAUSE 
SPLKEY K-PAUSE 
SPLKEY K-PRIOR 
SPLKEY K-PRIOR 
SPLKEY K-SCROLL 
SPLKEY K-SCROLL 
LITKEY K_BACKSPACE 
LITKEY K_CR 
SYNONYM K_DELETE K-DELETE 
SYNONYM K_DELETE K-DELETE 
LITKEY K_ESC 
SYNONYM K_INSERT K-INSERT 
SYNONYM K_INSERT K-INSERT 
SYNONYM K_LEFT K-LEFT 
SYNONYM K_LEFT K-LEFT 
LITKEY K_LF 
SYNONYM K_RIGHT K-RIGHT 
SYNONYM K_RIGHT K-RIGHT 
LITKEY K_TAB 
SYNONYM K_UP K-UP 
SYNONYM K_UP K-UP 
: LITKEY ( -- n ) 
: SPLKEY ( n2 -<name>- ) 
: "LOG ( a1 n1 -- ) 
:M "LOG: ( a1 n1 -- ) 
: "NEW-LOG ( a1 n1 -- ) 
:M "NEWLOG: ( a1 n1 -- ) 
: "PLAYKEYS ( a1 n1 -- ) 
VALUE #REPEATING-MACRO \ In this definition, 'parent' can be either the parent window, or CONHNDL
\ in the case of the forth console window
CREATE &KEY 
: CHARTOKEY ( -- char | -1 = end_of_file) 
:M CLASSINIT: ( -- ) 
:M CLOSELOG: ( -- ) 
: CON-NEW-MACRO ( -- ) 
: CON-PLAY-MACRO ( -- ) 
: F"LOG ( -- ) 
: GET1HEXLINE ( -- ) 
: GET1LINE ( -- ) 
:M GETLOGNAME: ( -- a1 n1 ) 
VALUE IGNORED-KEYS \ keys in this counted string are not logged
LOGFILE KEY-LOG-FILE 
BYTES KEYBUF 
INT LOG# 
: LOG-ALSO ( c1 -- c1 ) 
: LOG-EMIT { logChar \ prepad$ -- } 
DEFER LOG-MORE 
:M LOGCR: ( -- ) 
:M LOGEMIT: ( c1 -- ) 
:CLASS LOGFILE 
:CLASS LOGFILE 
BYTES LOGFILEBUF 
INT LOGFILEDEFAULT 
INT LOGFILENAME 
: LOGGING-OFF ( -- ) 
: LOGGING-ON ( -- ) 
VALUE LOGGING? 
INT LOGHNDL 
INT LOGOUT 
:M LOGSPACES: ( n1 -- ) 
:M LOGTAB: ( -- ) 
INT LOGTABSIZE 
: NEW-LOG ( -- ) 
FILESAVEDIALOG NEWLOG 
:M NEWLOG: { \ key$ -- } 
:M OPENLOG: ( -- ) 
VALUE PLAY0CNT 
: PLAY1KEY ( -- ) 
: PLAY1KEY? ( f1 -- f1 ) 
:M PLAYCLOSE: ( -- ) 
INT PLAYHNDL 
:M PLAYING: ( -- f1 ) 
:M PLAYKEY: ( -- char ) 
FILEOPENDIALOG PLAYLOG 
:M PLAYLOG: ( a1 n1 -- ) 
\ play log file a1,n1
VALUE PLAYRATE 
: REPEAT-AMACRO { parent \ repeat$ -- } 
NEWEDITDIALOG REPEATMACRODLG 
: REPLAY-MACRO ( -- ) 
:M SETLOGTAB: ( n1 -- ) 
: START/STOP-MACRO ( -- ) 
CREATE VIEW-IGNORED-KEYS \ list of keys ignored by macro recording
ANEW -ACCELERATORTABLES.F 
: ACCELENTRY ( flags key-code command-id -- ) 
\ W32F sys
\ Add an entry to the current table
: ACCELERATORTABLE ( <name> -- ) 
\ Create a new named Accelerator Table
VALUE CURRENTTABLE \ current named accelerator table
: DISABLEACCELERATORS ( a -- ) 
\ W32F
\ Destroys the Windows Accelerator Table.
\ It does not matter trying to destroy a table more than once.
: DUMP-ACCELERATOR-KEY-TABLE ( a -- ) 
\ W32F sys
\ Dump an Accelerator Table to the console window-
: ENABLEACCELERATORS ( a -- ) 
\ W32F
\ Creates the Windows Accelerator Table.
\ It does not matter creating the same table again as long as it is destroyed first.
: HANDLESTHEM ( Window -- ) 
\ W32F
\ Close a table and assign it to the given window.
\ adds the code in #DOES> to the message chain
\ Changed to add it on the start of the chain instead of the end, because
\ accelerator keys bust be handled before any other things happen in the
\ massage loop, to work correctly (Sonntag, Mai 21 2006 dbu).
: TABLE ( a -- ) 
\ W32F sys
\ Start a table of entries in the dictionary
:M (EXECUTE): ( str len option -- ) 
:M (SAVE): ( str len type -- ) 
 ADARRAY 
 ADBIGINT 
 ADBINARY 
 ADBOOLEAN 
 ADBSTR 
 ADCHAPTER 
 ADCHAR 
 ADCURRENCY 
 ADDATE 
 ADDBDATE 
 ADDBTIME 
 ADDBTIMESTAMP 
 ADDECIMAL 
 ADDOUBLE 
:M ADDROW: ( -- ) 
\ Adds a new record to the end of the recordset and sets this as the current row.  The row
\ is not actually created until the update method is called.
 ADEMPTY 
 ADERROR 
 ADFILETIME 
 ADGUID 
 ADIDISPATCH 
 ADINTEGER 
 ADIUNKNOWN 
 ADLOCKBATCHOPTIMISTIC 
 ADLOCKOPTIMISTIC 
 ADLOCKPESSIMISTIC 
 ADLOCKREADONLY 
 ADLOCKUNSPECIFIED 
 ADLONGVARBINARY 
 ADLONGVARCHAR 
 ADLONGVARWCHAR 
 ADMODEREAD 
 ADMODEREADWRITE 
 ADMODERECURSIVE 
 ADMODESHAREDENYNONE 
 ADMODESHAREDENYREAD 
 ADMODESHAREDENYWRITE 
 ADMODESHAREEXCLUSIVE 
 ADMODEUNKNOWN 
 ADMODEWRITE 
 ADNUMERIC 
:CLASS ADOCONNECTION 
:CLASS ADOCONNECTION 
:CLASS ADOCURSOR 
:CLASS ADOCURSOR 
 ADOPENDYNAMIC 
 ADOPENFORWARDONLY 
 ADOPENKEYSET 
 ADOPENSTATIC 
 ADOPENUNSPECIFIED 
 ADPROPVARIANT 
 ADSINGLE 
 ADSMALLINT 
 ADTINYINT 
 ADUNSIGNEDBIGINT 
 ADUNSIGNEDINT 
 ADUNSIGNEDSMALLINT 
 ADUNSIGNEDTINYINT 
 ADUSERDEFINED 
 ADVARBINARY 
 ADVARCHAR 
 ADVARIANT 
 ADVARNUMERIC 
 ADVARWCHAR 
 ADWCHAR 
:M ASYNCEXECUTE: ( str len -- ) 
\ Operates the same as the execute method, but is asyncronous.  The cursor's
\ state will indicate if the query has finished executing or not.
:M BOF: ( -- flag ) 
\ Flag that indicates if the current record position is before the first record.
:M BSTR>ASC: ( bstr -- str len ) 
:M BSTR>ASC: ( bstr -- str len ) 
:M CLEARERRORS: ( -- ) 
\ Clears the FIFO error queue
:M CLOSE: ( -- ) 
\ Closes the cursor.  Another query can be executed on the cursor once it has been closed.
:M CLOSE: ( -- flag ) 
\ Closes the database connection.  The COM component still exists and a new
\ connection may be made if desired.
:M COMMIT: ( -- ) 
\ Commit all changes in the current transaction to the database.
BYTES CONN 
:M CONNECT: ( -- ) 
\ Connects to the data source specified by the connection string with the given
\ connection properties.
INT CONNPTR 
:M DELETEROW: ( -- ) 
\ Deletes the current record.
:M EOF: ( -- flag ) 
\ Flag that indicates if the current record position is after the last record.
:M ERR: ( n -- ) 
\ thows an error on any problem
\ Displays and clears all errors in the queue
:M ERROR>STR: ( n -- str len ) 
\ Return the error string of the 'cnt' error in the error queue
BYTES ERRS 
:M EXECUTE: ( str len -- ) 
\ Execute a SQL query on the cursor.  Any returned data will be in the cursor.
:M EXECUTING?: ( -- flag ) 
\ Returns true if the query is still executing.
:M FETCHING?: ( -- flag ) 
\ Returns true if the rows are still being retrieved
:M FIELDCNT: ( -- n ) 
\ Returns the number of columns in the current record.
:M FIELDNAME: ( field -- str len ) 
\ Returns the column name of the given column number.
:M FIELDSIZE: ( field -- n ) 
\ Returns the data size of the given column number.
:M FIELDTYPE: ( field -- DataTypeEnum ) 
\ Returns the data type constant of the given column. Possible data types are:
\ 
\ adEmpty |
\ adTinyInt |
\ adSmallInt |
\ adInteger |
\ adBigInt|
\ adUnsignedTinyInt  |
\ adUnsignedSmallInt |
\ adUnsignedInt |
\ adUnsignedBigInt |
\ adSingle |
\ adDouble |
\ adCurrency  |
\ adDecimal |
\ adNumeric  |
\ adBoolean  |
\ adError  |
\ adUserDefined  |
\ adVariant  |
\ adIDispatch  |
\ adIUnknown |
\ adGUID |
\ adDate  |
\ adDBDate  |
\ adDBTime  |
\ adDBTimeStamp |
\ adBSTR |
\ adChar  |
\ adVarChar  |
\ adLongVarChar |
\ adWChar |
\ adVarWChar |
\ adLongVarWChar |
\ adBinary |
\ adVarBinary  |
\ adLongVarBinary |
\ adChapter |
\ adFileTime |
\ adPropVariant |
\ adVarNumeric  |
\ adArray |
BYTES FLD 
BYTES FLDS 
:M FREEMSTR: ( -- ) 
:M FREEMSTR: ( -- ) 
:M GETCACHESIZE: ( -- n ) 
\ Returns the cache size of the cursor.  The value is the number of records in the
\ cache before updates are required.
:M GETCONN: ( -- IConn ) 
:M GETCONNSTRING: ( -- str len ) 
\ Return the connection string for the data source.  This may not necessarily
\ be the same string that was given to the object
:M GETCURSORTYPE: ( -- ctype ) 
\ Returns the cursor type.
:M GETDATETIME: ( field -- sec min hour day month year ) 
\ Returns the datetime values of the given column on the current row.
:M GETDOUBLE: ( field -- d ) 
\ Returns the double of the given column on the current row.
:M GETERROR: ( cnt -- n ) 
\ Return the error number of the 'cnt' error in the error queue
:M GETERRORCNT: ( -- cnt ) 
\ Return the number of errors in the FIFO error queue
:M GETFLOAT: ( field -- float ) 
\ Returns the floating point value of the given column on the current row.
:M GETINT: ( field -- int ) 
\ Returns an integer value of the given column on the current row.
:M GETLOCKTYPE: ( -- n ) 
\ Returns the lock type.
:M GETMAXROWS: ( -- n ) 
\ Returns the maximum number of records to be returned in a query.
:M GETMODE: ( -- n ) 
\ Returns the connection mode.
:M GETPROVIDER: ( -- str len ) 
\ Returns the provider for the connection.
:M GETSTATE: ( -- n ) 
\ Returns the current state of the connection object.
:M GETSTATE: ( -- n ) 
\ Returns the state of the cursor.  Useful when executing queries asyncronously.
:M GETSTR: ( field -- str len ) 
\ Returns the string of the given column on the current row.  May be much longer than 255
:M GETTIMEOUT: ( -- n ) 
\ Returns the timeout time (in seconds) that queries will give up.
:M GETTIMESTAMP: ( field -- float ) 
\ Return the timestamp value of the given column on the current row.  The timestamp value is
\ a floating point number that indicates the number of days since Dec 31, 1899.
:M GETVALUE: ( field -- ) 
:M ISNULL?: ( field -- flag ) 
\ Returns true if the given field for the given flag is null
:M LOADFILE: ( str len -- ) 
\ Loads a cursor data file that was saved previously.
\ A connection object is not required to load this data.
:M MOVE: ( n -- ) 
\ Move to the record number 'n' of the cursor's data
:M MOVEFIRST: ( -- ) 
\ Move to the first record of the cursor's data.
:M MOVELAST: ( -- ) 
\ Move to the last record of the cursor's data
:M MOVENEXT: ( -- ) 
\ Move to the next record of the cursor's data
:M MOVEPREVIOUS: ( -- ) 
\ Move to the previous record of the cursor's data
INT MSTR 
INT MSTR 
INT MSTRLEN 
INT MSTRLEN 
BYTES REC 
:M RECORDCOUNT: ( -- n ) 
\ Return the number of records in cursor.  May not work with the adOpenForwardOnly
\ cursor type.
:M REQUERY: ( n -- ) 
\ Rerun the last query.
:M ROLLBACK: ( -- ) 
\ Drop all changes in the current transaction - no changes are made for the
\ transaction session.
:M SAVEADTG: ( str len -- ) 
\ Saves the cursor's data in the Microsoft Advanced Data TableGram (ADTG) format.
\ Requires a filename.
:M SAVECSV: ( str len -- ) 
\ Saves the cursor's data to a comma separated value file for easy viewing.
\ Cannot be loaded later through the loadfile method.
:M SAVENATIVE: ( str len -- ) 
\ Saves the cursor's data to a file that is in a unspecified format.
:M SAVEXML: ( str len -- ) 
\ Saves the cursor's data as a XML file.
:M SETCACHESIZE: ( n -- ) 
\ Sets the cache size of the cursor.  The default is 1, or updates occur with every
\ new record edited.
:M SETCONNECTION: ( ADOConnection -- ) 
\ Sets the connection object for this cursor.  It is required before any query
\ is executed.
:M SETCONNSTRING: ( str len -- ) 
\ Set the connection string for the data source.  The connection string tells
\ the object what drivers to use, where the database is, user name, and password.
:M SETCURSORTYPE: ( ctype -- ) 
\ Sets the cursor type.  The cursor type determines what is allowed on the cursor
\ data and how data is seen in a multi-client environment.  The possible values are:
\ 
\ adOpenUnspecified | The cursor type is unspecified.  Usually defaults to adOpenForwardOnly |
\ adOpenStatic | All movement methods are available.  Changes from other users are not visible |
\ adOpenForwardOnly | The cursor can only move forward.  The record count and other navigation methods are invalid.  This should have the best performance of the cursors. |
\ adOpenDynamic  | All additions, deletions and changes from other users are visible |
\ adOpenKeyset | Like a dynamic cursor, except added records can't be seen and deleted records are inaccessible |
:M SETDATETIME: ( sec min hour day month year field -- ) 
\ Sets the datetime values of the given column on the current row.
:M SETDOUBLE: ( d field -- ) 
\ Sets the double value of a given column on the current row.
:M SETFLOAT: ( float field -- ) 
\ Sets the floating point number of a given column on the current row.
:M SETINT: ( int field -- ) 
\ Sets the integer value of a given column on the current row.
:M SETLOCKTYPE: ( n -- ) 
\ Sets the lock type.  The lock type determines how the database is to handle changes
\ to the data on a cursor.  The possible values are:
\ 
\ adLockUnspecified | The lock type is unspecified.  Usually defaults to adLockReadOnly |
\ adLockReadOnly | The records are read-only. Data cannot be altered |
\ adLockPessimistic | Pessamistic locking.  Record(s) are locked at the data source immediately when the alterations begin. |
\ adLockOptimistic | Optimistic locking.  Record(s) are locked only when the update method is called |
\ adLockBatchOptimistic | Useful for batch updates. |
:M SETMAXROWS: ( n -- ) 
\ Sets the maximum number of records to be returned from a query (0 = unlimited)
:M SETMODE: ( n -- ) 
\ Sets the connection mode.  The connection mode indicates whether the database
\ is read-only, write-only, sharable, etc...
\ See the ConnectModeEnum constants below the class descriptions.
:M SETNULL: ( field -- ) 
\ Sets the field value to null of a given column on the current row.
:M SETPROVIDER: ( str len -- ) 
\ Sets the provider for the connection.  Can be set through the connection string
\ as well.
:M SETSTR: ( str len field -- ) 
\ Sets the string value of a given column on the current row.
:M SETTIMEOUT: ( n -- ) 
\ Sets the timeout time (in seconds) that queries will give up.
:M SETTIMESTAMP: ( float field -- ) 
\ Sets the timestamp value of the given column on the current row.  The timestamp value is
\ a floating point number that indicates the number of days since Dec 31, 1899.
:M SETVALUE: ( variant field -- ) 
\ puts xtra variant into Field
:M START: ( -- ) 
\ Initializes the ADO Recordset Component.  Most methods will not execute properly
\ if this is not called when the object instance is created
:M START: ( -- ) 
\ Initializes the ADO Connection Component.  Most methods will not execute properly
\ if this is not called when the object instance is created
:M TRANSACTION: ( -- ) 
\ Starts a transaction session for this connection.  All changes
\ performed on the database will not take effect until they are committed.
\ Some databases may not support this functionality.
CREATE UCOMMA 
CREATE UCRLF 
CREATE UNULL 
:M UPDATE: ( -- ) 
\ Updates the alterations to the data.
BYTES XTRA 
BYTES XTRA 
:M ~: ( --  ) 
:M ~: ( --  ) 
: #BYTE-ARRAY ( n1 -<name>- ) 
\ compile time          8-bits
( n1 -- byte ) 
\ runtime
: #DOUBLE-ARRAY ( n1 -<name>- ) 
\ compile time          2 x 32-bits
( n1 -- long ) 
\ runtime
: #LONG-ARRAY ( n1 -<name>- ) 
\ compile time          32-bits
( n1 -- long ) 
\ runtime
: #WORD-ARRAY ( n1 -<name>- ) 
\ compile time          16-bits
( n1 -- word ) 
\ runtime
: B#+> ( n1 n2 -<name>- ) 
\ store byte n1 into element n2
\ of byte array
: B#-> ( n1 n2 -<name>- ) 
\ store byte n1 into element n2
\ of byte array
: BYTE-ARRAY ( n1 -<name>- ) 
\ compile time
( -- a1 ) 
\ runtime
: D#+> ( n1 n2 -<name>- ) 
\ store long n1 into element n2
\ of double array
: D#-> ( n1 n2 -<name>- ) 
\ store long n1 into element n2
\ of double array
: DOUBLE-ARRAY ( n1 -<name>- ) 
\ compile time
( -- a1 ) 
\ runtime
: L#+> ( n1 n2 -<name>- ) 
\ store long n1 into element n2
\ of long array
: L#-> ( n1 n2 -<name>- ) 
\ store long n1 into element n2
\ of long array
: LONG-ARRAY ( n1 -<name>- ) 
\ compile time
( -- a1 ) 
\ runtime
: W#+> ( n1 n2 -<name>- ) 
\ store word n1 into element n2
\ of word array
: W#-> ( n1 n2 -<name>- ) 
\ store word n1 into element n2
\ of word array
: WORD-ARRAY ( n1 -<name>- ) 
\ compile time
( -- a1 ) 
\ runtime
: ^#BYTE-ARRAY ( a1 -<name>- ) 
\ compile time          8-bits
( n1 -- byte ) 
\ runtime
: ^#DOUBLE-ARRAY ( a1 -<name>- ) 
\ compile time          2 x 32-bits
( n1 -- long ) 
\ runtime
: ^#LONG-ARRAY ( a1 -<name>- ) 
\ compile time          32-bits
( n1 -- long ) 
\ runtime
: ^#WORD-ARRAY ( n1 -<name>- ) 
\ compile time          16-bits
( n1 -- word ) 
\ runtime
ANEW -AXCONTROL.F 
:CLASS AXCONTROL 
:CLASS AXCONTROL 
:M AXCREATE: ( str len -- ) 
\ Initialize the ActiveX control
:M AXUCREATE: ( ustr -- ) 
\ calls unicode creation function
:M QUERYINTERFACE: ( ppv riid -- flag ) 
\ flag is true on error
CREATE ARRAY 
DEFER B-COMPARE ( key1 key2 -- result ) 
: BSEARCH ( key array count -- index flag ) 
ANEW FOO 
DEFER GET-KEY ( index array -- key ) 
CONSTANT NELEM 
: TEST ( key -- ) 
: "LOAD-BITMAP ( fname cnt -- ) 
\ load bitmap file to here, search fpath
{ \ bmpaddr fileid filelength -- } 
: "MEM-LOADBITMAP { fname cnt \ fileid filelength bmpaddr -- addr } 
\ load bitmap filename fname,cnt to memory, return address
INT &BITMAP 
ANEW -BITMAP.F 
: >RGB { colorref -- r g b } 
: ?BITMAPERROR ( -- ) 
\ abort on bitmap not set
:M ANDBLIT: { sprite# x y  --  } 
INT BACKGROUNDCOLOR 
INT BITMAP#1 
INT BITMAP#2 
WINDC BITMAP-DC 
:CLASS BITMAPOBJECT 
:CLASS BITMAPOBJECT 
BYTES BUTTONTEXT 
: CALCIMAGESIZE { width height -- wDib hDib } 
\ adapted from imagewindow.f
\ calc scale factor
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLOSE: ( --  ) 
: CREATEDIBITMAP { hdc \ -- hbitmap } 
\ return a bitmap handle for image in memory compatible with hdc
VALUE CURRENTBITMAP 
: DIB.BITS ( -- addr ) 
\ address of bitmap bits
: DIB.BITS/PIXEL ( -- n ) 
\ bits per pixel
: DIB.BYTES/LINE ( -- n ) 
\ number of bytes required for one scan line
: DIB.CLRIMP ( -- n ) 
\ important colors
: DIB.COLORS ( -- n ) 
\ colors in bitmap
: DIB.COMPRESSION ( -- n ) 
\ type of compression
: DIB.FILESIZE ( -- n ) 
\ total size of file
: DIB.HEIGHT ( -- n ) 
\ height of bitmap in pixels
: DIB.IMAGESIZE ( -- n ) 
\ size of image in bytes
: DIB.INFOHEADER ( -- addr ) 
\ address of bitmapinfoheader
: DIB.INFOHEADERSIZE ( -- n ) 
\ size of infoheader
: DIB.PITCH ( -- n ) 
\ width of bitmap in bytes, rounded to 32-bit boundary
: DIB.PLANES ( -- n ) 
: DIB.RGBQUAD ( -- addr ) 
\ return address of RGBQUAD array
: DIB.WIDTH ( -- n ) 
\ width of bitmap in pixels
: DIB.XPIXELS ( -- n ) 
\ xpixels per metre
: DIB.YPIXELS ( -- n ) 
\ y pixels per metre
:M DISABLE: ( -- ) 
:M ENABLE: ( f -- ) 
:M GETIMAGE: { sprite# x y --  } 
:M GETOFFSETY: ( -- y ) 
:M GETPARENTDC: ( -- dc ) 
:M GETSPRITESIZE: ( -- width height ) 
:M GETWINDC: ( -- dc ) 
INT IFLAG 
INT IFONT 
:CLASS IMAGEBUTTON 
:CLASS IMAGEBUTTON 
INT IMAGEDC 
CONSTANT IMAGE_TIMER 
: ISBITMAP? ( -- f ) 
\ verify valid bitmap
: LOAD-BITMAP ( <name> "file" -- ) 
: LOADBITMAP ( z" string" -- hbitmap ) 
VALUE LOADFLAGS 
: LOADICON ( z"string" -- hbitmap ) 
: MAP-3DCOLORS { \ #colors -- } 
\ simulates WIN32 APi (LR_LOADMAP3DCOLORS) in mapping values in color table
VALUE MAP-COLOR \ opportunity to set own color
: MAP-TRANSPARENT ( -- ) 
\ simulates WIN32 API ( LR_LOADTRANSPARENT ), changes background color of bitmap
INT OFFSETY 
:M ORBLIT: { sprite# x y --  } 
: PAINTBUTTON ( -- ) 
INT PARENTDC 
:M PUTBMP: { x y --  } 
:M PUTIMAGE: { sprite# x y --  } 
:M PUTIMAGEMASKED: { sprite# x y --  } 
: RGB>RGBQUAD { rgbquad r g b -- } 
\ save rgb color refernce to RGBQUAD cell
:M SETBACKGROUNDCOLOR: ( color_object -- ) 
:M SETBITMAP: ( <addr of bitmap> -- ) 
:M SETFONT: ( fonthndl -- ) 
:M SETIMAGE#2: ( &bitmap -- ) 
:M SETIMAGE: ( &bitmap -- ) 
:M SETOFFSETY: ( y --  ) 
:M SETPARENTDC: ( dc --  ) 
:M SETSPRITESIZE: ( width height --  ) 
:M SETTEXT: ( addr cnt -- ) 
:M SETXY: ( x y -- ) 
:M SHOWBITMAP: { x y hdc -- } 
\ display bitmap at &bitmap in DC at handle hdc
\ full size of bitmap will allways be shown
:M SHOWFITTEDBITMAP: { width height hdc -- } 
\ load and draw Image; fit to window of size w h
:M SHOWSCALEDBITMAP: { width height hdc -- } 
\ load and draw Image; keep aspect ratio
CONSTANT SIZEOF(FILEHEADER) 
INT SPRITE-BITMAP 
INT SPRITEHEIGHT 
INT SPRITEWIDTH 
:M START: { \ hdcMem hbm --  } 
INT TEXTCOLOR 
BITMAPOBJECT THEIMAGE 
: USEBITMAP ( <bitmap addr> -- ) 
\ set bitmap to be used
:M WM_LBUTTONDBLCLK ( h m w l -- ) 
:M WM_LBUTTONDOWN ( h w m l -- res ) 
:M WM_LBUTTONUP ( h w m l -- ) 
:M WM_MOUSEMOVE ( h m w l -- res ) 
:M WM_PAINT ( h m w l -- res ) 
:M WM_TIMER ( h m w l -- ) 
INT XPOS 
INT YPOS 
INT BITMAP 
:CLASS BITMAP-DC 
:CLASS BITMAP-DC 
INT BITMAP-HEIGHT 
INT BITMAP-WIDTH 
:M CLASSINIT: ( -- ) 
\ Init the class
:M DESTROY: ( -- ) 
\ Destroys the display bitmap.
\ first we destroy the device context
:M FILL: { color_object \ -- } 
\ Fill the display bitmap with a specified color.
:M FILLAREA: ( color_object -- ) 
\ Fill the display bitmap with a specified color.
:M INIT: { width height RefDC \ -- } 
\ Create the display bitmap and select it to our device context.
\ Our device context will be compatible to the reference device.
:M PAINT: { ps_left ps_top ps_right ps_bottom DestDC -- } 
\ Draw the display bitmap into the destination device condtext.
:M VALID?: ( -- f ) 
\ Check if it's save to use this device.
:M ~: ( -- ) 
\ Clean up on dispose.
: #BLOCKS ( -- u ) 
\ W32F         Block extra
\ u is the number of blocks in the current blockfile.
CONSTANT #BUFFERS \ W32F         Block extra
\ Number of block buffers.
: >REC#FIL ( n1 --- a1 ) 
\ return the buffer n1's file addr
: >REC#S ( n1 --- a1 ) 
\ return the buffer n1's record addr
: >REC#UPDT ( n1 --- a1 ) 
\ return the buffer n1's update addr
: ?GOTREC ( n1 --- <n2> f1 ) 
\ Do we have block n1 in memory?
CONSTANT B/BUF \ W32F         Block extra
\ Length of each block.
VARIABLE BLK ( -- a-addr ) 
\ ANSI         Block
\ a-addr is the address of a cell containing zero or the number of the mass-storage
\ block being interpreted. If BLK contains zero, the input source is not a block
\ and can be identified by SOURCE-ID, if SOURCE-ID is available. An ambiguous
\ condition exists if a program directly alters the contents of BLK.
: BLKMESSAGE ( n1 -- ) 
CONSTANT BLOCK 
: BLOCK ( u -- a-addr ) 
\ ANSI         Block
\ a-addr is the address of the first character of the block buffer assigned to
\ mass-storage block u. An ambiguous condition exists if u is not an available
\ block number. 
\ If block u is already in a block buffer, a-addr is the address of that block buffer.  
\ If block u is not already in memory and there is an unassigned block buffer,
\ transfer block u from mass storage to an unassigned block buffer. a-addr is
\ the address of that block buffer. 
\ If block u is not already in memory and there are no unassigned block buffers, unassign
\ a block buffer. If the block in that buffer has been UPDATEd, transfer the block to
\ mass storage and transfer block u from mass storage into that buffer. a-addr is the
\ address of that block buffer. 
\ At the conclusion of the operation, the block buffer pointed to by a-addr is the
\ current block buffer and is assigned to u.
CONSTANT BLOCK-EXT 
VALUE BLOCKHANDLE \ W32F         Block extra
\ The handle of the current block file, or -1 if no current block file.
: BUBBLEUP ( n1 --- ) 
\ move buffer # n1 to end of list
: BUF#>BUFADDR ( n1 --- a1 ) 
\ Calculate address a1 of buffer n1.
: BUFFER ( u -- a-addr ) 
\ ANSI         Block
\ a-addr is the address of the first character of the block buffer assigned to block u.
\ The contents of the block are unspecified. An ambiguous condition exists if u is not
\ an available block number. 
\ If block u is already in a block buffer, a-addr is the address of that block buffer. 
\ If block u is not already in memory and there is an unassigned buffer, a-addr is the
\ address of that block buffer. 
\ If block u is not already in memory and there are no unassigned block buffers,
\ unassign a block buffer. If the block in that buffer has been UPDATEd, transfer
\ the block to mass storage. a-addr is the address of that block buffer.
\ At the conclusion of the operation, the block buffer pointed to by a-addr is
\ the current block buffer and is assigned to u.
CONSTANT BUFLEN 
CONSTANT C/L \ W32F         Block extra
\ Number of characters per line.
: CHKFIL ( n1 --- n1 f1 ) 
\ verify file in bufer n1 is current
: CLOSE-BLOCKFILE ( -- ) 
\ W32F         Block extra
\ Close the current blockfile, flushing any updated buffers. Set the current blockfile
\ to no file.
: CREATE-BLOCKFILE ( u "<spaces>'filename'" ) 
\ W32F         Block extra
\ Close the current blockfile. Create a file of u blocks long, initialise the
\ blocks to blanks and make it the current blockfile.
VARIABLE CUR_BUFFER# \ current buffer # of current block
: EMPTY-BUFFERS ( -- ) 
\ ANSI         Block ext
\ Unassign all block buffers. Do not transfer the contents of any updated
\ block buffer to mass storage.
: EVALUATE ( a1 n1 -- ) 
: FLUSH ( -- ) 
\ ANSI         Block
\ Perform the function of SAVE-BUFFERS, then unassign all block buffers.
: LIST ( u -- ) 
\ ANSI         Block ext
\ Display block u in the console in a 16 line format. Store u in SCR. 
\ An error occurs if u is greater than the number of blocks in the current blockfile.
: LIST-ALL ( -- ) 
\ W32F         Block extra
\ To list all blocks in the current blockfile.
: LOAD ( i*x u -- j*x ) 
\ ANSI         Block
\ Save the current input-source specification. Store u in BLK (thus making block
\ u the input source and setting the input buffer to encompass its contents), set
\ >IN to zero, and interpret. When the parse area is exhausted, restore the prior
\ input source specification. Other stack effects are due to the words LOADed.
\ An ambiguous condition exists if u is zero or is not a valid block number.
{ loadblk \ incntr outcntr -- } 
: OPEN-BLOCKFILE ( "<spaces>'filename'" ) 
\ W32F         Block extra
\ Close the current blockfile. Open the file and make it the current block file.
: POS_BLOCK ( n1 --- ) 
\ Set file pointer to block pos n1
: READ_BLOCK ( a1 n1 --- ) 
\ read block n1 to address a1
VARIABLE REC#FIL 
VARIABLE REC#S 
VARIABLE REC#UPDT 
VARIABLE REC#USE 
VARIABLE REC_ARRAY 
: REFILL ( -- f1 ) 
: RESTORE-INPUT ( xxx 8 -- f1 ) 
: SAVE-BUFFERS ( -- ) 
\ ANSI         Block
\ Transfer the contents of each updated block buffer to mass storage.
\ Mark all buffers as unmodified.
: SAVE-INPUT ( -- xxx 8 ) 
VARIABLE SCR ( -- a-addr ) 
\ ANSI         Block ext
\ a-addr is the address of a cell containing the block number of the block most
\ recently listed.
: SET-BLOCKFILE ( fileid -- ) 
\ W32F         Block extra
\ Make fileid the current blockfile.
: THRU ( i*x u1 u2 -- j*x ) 
\ ANSI         Block ext
\ LOAD the mass storage blocks numbered u1 through u2 in sequence. Other stack
\ effects are due to the words LOADed.
: UPDATE ( -- ) 
\ ANSI         Block
\ Mark the current block buffer as modified. An ambiguous condition exists if there
\ is no current block buffer. 
\ Update does not write the block to the disc.
: VIRTUAL-INIT ( --- ) 
\ and during the system startup initialization
: WIPE ( u -- ) 
\ W32F         Block extra
\ Erase the specified block to blanks.
: WRITE_BLOCK ( n1 n2 --- ) 
\ write block n1 to disk
: \ ( -- ) 
CALLBACK &BROWSECALLBACKPROC 
ANEW -BROWSEFLD.F 
CONSTANT BFFM_INITIALIZED \ 2 constant BFFM_SELCHANGED
\ 3 constant BFFM_VALIDATEFAILEDA \ lParam:szPath ret:1(cont),0(EndDialog)
\ 4 constant BFFM_VALIDATEFAILEDW \ lParam:wzPath ret:1(cont),0(EndDialog)
\ 5 constant BFFM_IUNKNOWN        \ provides IUnknown to client. lParam: IUnknown*
\ messages to browser
\ WM_USER 100 + constant BFFM_SETSTATUSTEXTA
\ WM_USER 101 + constant BFFM_ENABLEOK
CONSTANT BFFM_SETSELECTIONA \ WM_USER 103 + constant BFFM_SETSELECTIONW
\ WM_USER 104 + constant BFFM_SETSTATUSTEXTW
\ WM_USER 105 + constant BFFM_SETOKTEXT
\ WM_USER 106 + constant BFFM_SETEXPANDED
CONSTANT BIF_EDITBOX \ Add an editbox to the dialog
CONSTANT BIF_NEWDIALOGSTYLE \ Use the new dialog layout with the ability to resize
\ Caller needs to call OleInitialize() before using this API
\ 0x0080 constant BIF_BROWSEINCLUDEURLS   \ Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)
\ 0x0100 constant BIF_UAHINT              \ Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX
\ 0x0200 constant BIF_NONEWFOLDERBUTTON   \ Do not add the "New Folder" button to the dialog.  Only applicable with BIF_NEWDIALOGSTYLE.
\ 0x0400 constant BIF_NOTRANSLATETARGETS  \ don't traverse target as shortcut
\ 0x1000 constant BIF_BROWSEFORCOMPUTER   \ Browsing for Computers.
\ 0x2000 constant BIF_BROWSEFORPRINTER    \ Browsing for Printers
\ 0x4000 constant BIF_BROWSEINCLUDEFILES  \ Browsing for Everything
\ 0x8000 constant BIF_SHAREABLE           \ sharable resources displayed (remote shares, requires BIF_USENEWUI)
\ BIF_NEWDIALOGSTYLE BIF_EDITBOX or constant BIF_USENEWUI
\ message from browser
CONSTANT BIF_RETURNONLYFSDIRS \ For finding a folder to start document searching
\ 0x0002 constant BIF_DONTGOBELOWDOMAIN   \ For starting the Find Computer
\ 0x0004 constant BIF_STATUSTEXT          \ Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
\ this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
\ rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
\ all three lines of text.
\ 0x0008 constant BIF_RETURNFSANCESTORS   \ ???
CONSTANT BIF_VALIDATE \ insist on valid result (or CANCEL)
: BROWSECALLBACKPROC { hwnd msg wParam lParam -- flag } 
: BROWSEFORFOLDER ( lpszTitle pszFolder hwndOwner -- flag ) 
CREATE BROWSEINFO 
VALUE HWNDOWNER 
VALUE IIMAGE 
VALUE LPARAM 
VALUE LPFN 
VALUE LPSZTITLE 
VALUE PIDLROOT 
VALUE PSZDISPLAYNAME 
VALUE ULFLAGS 
CALLBACK &BROWSECALLBACKPROC 
ANEW -BROWSEFLD.F 
CONSTANT BFFM_INITIALIZED \ 2 constant BFFM_SELCHANGED
\ 3 constant BFFM_VALIDATEFAILEDA \ lParam:szPath ret:1(cont),0(EndDialog)
\ 4 constant BFFM_VALIDATEFAILEDW \ lParam:wzPath ret:1(cont),0(EndDialog)
\ 5 constant BFFM_IUNKNOWN        \ provides IUnknown to client. lParam: IUnknown*
\ messages to browser
\ WM_USER 100 + constant BFFM_SETSTATUSTEXTA
\ WM_USER 101 + constant BFFM_ENABLEOK
CONSTANT BFFM_SETSELECTIONA \ WM_USER 103 + constant BFFM_SETSELECTIONW
\ WM_USER 104 + constant BFFM_SETSTATUSTEXTW
\ WM_USER 105 + constant BFFM_SETOKTEXT
\ WM_USER 106 + constant BFFM_SETEXPANDED
CONSTANT BIF_EDITBOX \ Add an editbox to the dialog
CONSTANT BIF_NEWDIALOGSTYLE \ Use the new dialog layout with the ability to resize
\ Caller needs to call OleInitialize() before using this API
\ 0x0080 constant BIF_BROWSEINCLUDEURLS   \ Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)
\ 0x0100 constant BIF_UAHINT              \ Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX
\ 0x0200 constant BIF_NONEWFOLDERBUTTON   \ Do not add the "New Folder" button to the dialog.  Only applicable with BIF_NEWDIALOGSTYLE.
\ 0x0400 constant BIF_NOTRANSLATETARGETS  \ don't traverse target as shortcut
\ 0x1000 constant BIF_BROWSEFORCOMPUTER   \ Browsing for Computers.
\ 0x2000 constant BIF_BROWSEFORPRINTER    \ Browsing for Printers
\ 0x4000 constant BIF_BROWSEINCLUDEFILES  \ Browsing for Everything
\ 0x8000 constant BIF_SHAREABLE           \ sharable resources displayed (remote shares, requires BIF_USENEWUI)
\ BIF_NEWDIALOGSTYLE BIF_EDITBOX or constant BIF_USENEWUI
\ message from browser
CONSTANT BIF_RETURNONLYFSDIRS \ For finding a folder to start document searching
\ 0x0002 constant BIF_DONTGOBELOWDOMAIN   \ For starting the Find Computer
\ 0x0004 constant BIF_STATUSTEXT          \ Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
\ this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
\ rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
\ all three lines of text.
\ 0x0008 constant BIF_RETURNFSANCESTORS   \ ???
CONSTANT BIF_VALIDATE \ insist on valid result (or CANCEL)
: BROWSECALLBACKPROC { hwnd msg wParam lParam -- flag } 
: BROWSEFORFOLDER ( lpszTitle pszFolder hwndOwner -- flag ) 
CREATE BROWSEINFO 
VALUE HWNDOWNER 
VALUE IIMAGE 
VALUE LPARAM 
VALUE LPFN 
VALUE LPSZTITLE 
VALUE PIDLROOT 
VALUE PSZDISPLAYNAME 
VALUE ULFLAGS 
ANEW -BUTTONBAR.F 
:M DISABLE: ( -- ) 
\ Disable the control.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: { flag \ hb1 -- } 
\ Enable the control.
:M ENABLE: { flag \ hb1 -- } 
\ Enable the control.
:CLASS HORIZBUTTONBAR 
:CLASS HORIZBUTTONBAR 
:M SETFONT: { fonthndl \ hb1 -- } 
\ Set the font in the control.
:M SETFONT: { fonthndl \ hb1 -- } 
\ Set the font in the control.
:CLASS VERTBUTTONBAR 
:CLASS VERTBUTTONBAR 
ANEW -BUTTONS.F 
:CLASS BITMAPBUTTON 
:CLASS BITMAPBUTTON 
:M CHECK: ( f -- ) 
:M CHECK: ( f -- ) 
\ Set the button state to either checked or unchecked.
:CLASS CHECKBOX 
:CLASS CHECKBOX 
:M CHECKBUTTON: ( -- ) 
:M CHECKBUTTON: ( -- ) 
\ Set the button state to checked.
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLOSE: ( -- ) 
\ DeleteIcon: self
:M CLOSE: ( -- ) 
\ DeleteBitmap: self
:CLASS DEFPUSHBUTTON 
:CLASS DEFPUSHBUTTON 
:M DELETEBITMAP: ( -- ) 
:M DELETEICON: ( -- ) 
:M DISABLE: ( -- ) 
\ Disable the control.
:M DISABLE: ( -- ) 
\ Disable the control.
:M DISABLE: ( -- ) 
\ Disable the control.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M GETBITMAP: ( -- hbitmap ) 
\ 0 IMAGE_BITMAP BM_GETIMAGE SendMessage:Self to hbitmap
:M GETICON: ( -- hIcon) 
\ get the icon image used with the button
\ 0 IMAGE_ICON BM_GETIMAGE SendMessage:Self to hicon
:M GETIMAGE: ( -- hicon ) 
:M GETIMAGE: ( -- hbitmap ) 
:CLASS GROUPBOX 
:CLASS GROUPBOX 
:CLASS GROUPRADIOBUTTON 
:CLASS GROUPRADIOBUTTON 
INT HBITMAP \ bitmap handle for button
INT HICON 
:CLASS ICONBUTTON 
:CLASS ICONBUTTON 
:M ISBUTTONCHECKED?: ( -- f ) 
\ Check if the radio button is checked or unchecked.
:M ISBUTTONCHECKED?: ( -- f ) 
\ send message to self through parent
:CLASS PUSHBUTTON 
:CLASS PUSHBUTTON 
:CLASS RADIOBUTTON 
:CLASS RADIOBUTTON 
:M SETBITMAP: ( hbitmap -- ) 
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETICON: ( hIcon -- ) 
\ set the icon image to use with the button
:M SETIMAGE: ( hicon -- ) 
:M SETIMAGE: ( hbmp -- ) 
:M UNCHECKBUTTON: ( -- ) 
\ Set the button state to unchecked.
:M UNCHECKBUTTON: ( -- ) 
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: BS_ICON.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: BS_DEFPUSHBUTTON.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default is BS_GROUP.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: BS_BITMAP.
ANEW -CALENDAR.F 
: >DATE ( day month year -- ) 
: DATE> ( -- day month year ) 
|CLASS DATETIMECONTROL 
|CLASS DATETIMECONTROL 
:CLASS DATETIMEPICKER 
:CLASS DATETIMEPICKER 
SHORT DAY 
SHORT DAYOFWEEK 
:M GETDATE: ( -- day month year ) 
\ get user selected date
\ GetTime: self 3dup or or 0<>
\ if      3drop wDay w@ wMonth w@ wYear w@
\ then    ;M
:M GETDATE: ( -- day month year ) 
\ Retrieves the currently selected date.
\  day  is the day of the month (0-31).
\  Month  is the month (January = 1; December = 12)
\  year  is the year (1601 - 30827).
\ _SystemTime 0  MCM_GETCURSEL SendMessage:SelfDrop
\ wday w@ wmonth w@ wyear w@ ;M
:M GETTIME: ( -- hrs min secs ) 
\ get user selected time
\ _SystemTime 0 DTM_GETSYSTEMTIME SendMessage:Self GDT_VALID =
\ if      wHour w@ wMinute w@ wSecond w@
\ else    0 0 0
\ then    ;M
:M GETTODAY: ( -- day month year ) 
\ Retrieves the date information for the date specified as "today".
\  day  is the day of the month (0-31).
\  Month  is the month (January = 1; December = 12)
\  year  is the year (1601 - 30827).
\ MCM_GETTODAY SendMessage:Self ?Win-Error
\ wday w@ wmonth w@ wyear w@ ;M
SHORT HOUR 
SHORT MILLISECONDS 
:M MINSIZE: ( -- x y ) 
\ Return minimum size required to display a month.
SHORT MINUTE 
SHORT MONTH 
:CLASS MONTHCALENDAR 
:CLASS MONTHCALENDAR 
SHORT SECOND 
: SENDTIMEMESSAGE ( message -- ) 
:M SETCUSTOMFORMAT: ( z"format"  -- ) 
\ set the display format for time or date
:M SETTIME: ( hr min sec -- ) 
\ set time for user to edit
\ wSecond w! wMinute w! wHour w!
\ 0 wMilliSeconds w!
\ _SystemTime GDT_VALID DTM_SETSYSTEMTIME SendMessage:Self ?Win-Error
\ ;M
;RECORDSIZE: SIZEOFTIME 
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
RECORD: TIME 
SHORT YEAR 
: CTYPE@ ( n -- x ) 
CREATE CTYPE_ARRAY 
CONSTANT CTYPE_CONTROL ( control characters ) 
CONSTANT CTYPE_DIGIT ( digit characters ) 
CONSTANT CTYPE_GRAPH ( is printable [ie., "graphic"] ) 
CONSTANT CTYPE_HEX ( hexadecimal digits ) 
CONSTANT CTYPE_LOWER ( lower case letters ) 
CONSTANT CTYPE_PUNCT ( punctuation characters ) 
CONSTANT CTYPE_UPPER ( upper case letters ) 
CONSTANT CTYPE_WS ( white space ) 
: IS-ALNUM ( n -- flag ) 
: IS-ALPHA ( n -- flag ) 
: IS-CNTRL ( n -- flag ) 
: IS-DIGIT ( n -- flag ) 
: IS-FORTH-SPACE ( n -- flag ) 
: IS-GRAPH ( n -- flag ) 
: IS-HEX ( n -- flag ) 
: IS-LOWER ( n -- flag ) 
: IS-PRINT ( n -- flag ) 
: IS-PUNCT ( n -- flag ) 
: IS-SPACE ( n -- flag ) 
: IS-UPPER ( n -- flag ) 
: TOLOWER ( n -- n' ) 
: TOUPPER ( n -- n' ) 
ANEW -ENUM.F 
VALUE ENUM-VALUE 
: ENUM: ( -- ) 
\ create a list of constants until terminating ;
VALUE INCREMENT 
: NOT-A-COMMENT? ( addr cnt -- f ) 
: %GET ( addr -- addr ) 
\ pointer to structure, allow setting structure memory block
: &GET ( addr -- addr ) 
\ allow accessing structure or member directly
ANEW -ESTRUCT.F 
VALUE .STRUCT-MSG? 
: :STRUCT ( <name> -- addr n ) 
: ;STRUCT ( link addr cnt -- ) 
CODE @+ ( n adr - adr@+n ) 
: ADDROF> ( <name> -- addr ) 
: END-WITH ( -- ) 
: FREE-STRUCT { structure -- } 
: GET ( addr -- data | struc ) 
: GET> ( <name> -- ) 
\ single member access only!
: MAKE-DYNAMIC { structure -- } 
\ create a dynamic structure
: MAKE-STATIC { structure -- } 
: PUT ( n1 n2 addr -- ) 
( f:   n -- ) 
: PUT> ( data <name> -- ) 
\ single member access only!
: S! \ synonym of put
: S@ \ synonym of get
: SIZE> ( <name> -- n ) 
: SIZEOF() ( struct -- addr size-of-structure ) 
CREATE STRUCT-MSG 
VOCABULARY STRUCT-VOC \ avoids conflicts. eg word
\ forth definitions
: WITH{ ( -- ) 
: }WITH ( addr -- ) 
\ allow multiple member access on a structure
:M CLASSINIT: ( -- ) 
\ Init the class
:M DESTROY: ( -- ) 
\ Destroy the device context.
:CLASS EXT-WINDC 
:CLASS EXT-WINDC 
:M PUTHANDLE: ( hObject -- ) 
\ Set the handle of the object.      
\ If the current handle of the object is valid it will be destroyed.
INT SAVEDSTATE 
:M SETHANDLE: ( hObject -- ) 
\ Set the handle of the object.      
\ If the current handle of the object is valid it will be destroyed.
:M ~: ( -- ) 
\ Clean up on dispose.
ANEW -EXTSTRUCT.F 
: :STRUCT ( -<name-struct>- -- ptr-size ) 
: MKSTRUCT: ( size-struct <-name-> -- ) 
: SIZEOF ( -<name-struct>- -- size ) 
: STRUCT, ( -<Struct>- -<name-struct>- -<member>- -- ) 
VOCABULARY STRUCTS \ all vocabularies for the struct's go in this one
: "APPEND ( -- ) 
: #APPEND ( n -- ) 
VALUE #CHARS \ current number of characters on line
VALUE #LINES \ number lines written
: (FLOAD-BUFFER) { s1 c1 \ curstr curlen lcnt -- f } 
\ compile a memory file
\ We need to save the string because if interpreting a line and a value is
\ left on the stack, e.g from "if", the system hangs somewhat
: +CHARS ( n -- ) 
: +CRLF ( -- ) 
: +SPACES ( n -- ) 
: +TABS ( n -- ) 
: >STR ( n -- addr cnt ) 
\ converts n to counted string, return unique buffer
: APPEND { addr cnt -- } 
: APPEND&CRLF ( addr cnt -- ) 
: APPEND.L ( addr cnt n -- ) 
\ justify to n length
POINTER BUFFERADDRESS 
: BUFFERFULL? ( size -- f ) 
CONSTANT BUFFERMAX 
: CAPPEND ( char -- ) 
: COPY-CLIPBOARD { str cnt \ hnd memptr -- } 
: EXECUTEFILE { addr cnt hndl \ temp$ -- } 
\ open file using default application
: FLOAD-BUFFER ( addr cnt --  ) 
: INITBUFFER ( -- ) 
: INTAPPEND ( n -- ) 
\ append an integer value
: MORE? ( -- f ) 
: PROGNAM>PAD ( -- ) 
: READLINE-MEMORY { addr cnt \ str2 cnt2 -- addr2 cnt2 str2 cnt2 } 
\ parse CRLF delimited strings in memory
\ addr2 cnt2 = line read minus crlf, str2 cnt2 = remaining buffer and count
: RELPATH&APPEND&CRLF ( addr cnt -- ) 
: S"APPEND ( -- ) 
VALUE TABSIZE 
: THEBUFFER ( -- addr cnt ) 
: Z"APPEND ( -- ) 
: "OF ( n1 n2 n3 -- n1 ) 
\ extension to CASE for a string
\ compares two strings for exact match
\ The parameter before CASE is a counted string given by its count address
\ use: s" this" "of do_if_case_parameter_is_exactly_"this" endof
: "OF-BEGIN ( n1 n2 n3 -- n1 ) 
\ extension to CASE for a string
\ compares two strings at their beginning.
\ The parameter before CASE is a counted string given by its count address
\ use: s" this" "of do_if_case_parameter_begins_with_"this" endof
: "OF-CONTAIN ( n1 n2 n3 -- n1 ) 
\ extension to CASE for a string
\ checks for tokens presence in the source string
\ The parameter before CASE is a counted string given by its count address
\ use: s" this" "of do_if_case_parameter_contains_"this" endof
: ("OF) ( counted-source a1 c1 -- counted-source ff | tf ) 
: ("OF-BEGIN) ( counted-source a1 c1 -- counted-source ff | tf ) 
: ("OF-CONTAIN) ( counted-source a1 c1 -- counted-source ff | tf ) 
: (|IF) ( n n1...nn -- n f ) 
: (|OF) ( n n1...nn -- n f | f ) 
ANEW -FCASES.F 
: RANGEOF ( n1 n2 n3 -- n1 ) 
\ extension to CASE for a range
\ use: 2  case 1 5 RangeOf do_if_2_is_>=1_and<=5 endof
VALUE SAVEDSP 
: _RANGEOF ( n1 n2 n3 -- n1 ff | tf ) 
: | ( n -- n ) 
: |IF ( n n1..nn -- f ) 
\ allow IF to check for a value in a list
\ use:  5 | 1 2 3 4 8 9 5 |if do_if_five_is_in_list then
\ Beware: not reentrant
: |OF ( n n1..nn -- f ) 
\ allow OF to check for a value in a list
\ use:  5 | 1 2 3 4 8 9 5 |of do_if_five_is_in_list endof
\ Beware: not reentrant
: (GUID,) ( addr len -- ) 
\ comments in a guid
ANEW -FCOM.F 
: .CONSTS ( typeinfo -- ) 
\ list all constants in an Enumeration
: .DISPWORDS ( interface -- ) 
: .METHODS ( typeinfo -- ) 
: .SFIELD ( typeinfo -- ) 
\ types the fields in a structure
: .VT ( -- ) 
: >ALLBIND ( tcomp -- buf tinfo kind ) 
: >BIND ( ustr tcomp -- buf tinfo kind ) 
\ returns a typeinfo, desckind, and a buffer
: >BINDF ( ustr tcomp -- buf tinfo kind ) 
\ returns a typeinfo, desckind, and a buffer
: >BINDG ( ustr tcomp -- buf tinfo kind ) 
\ returns a typeinfo, desckind, and a buffer
: >BINDP ( ustr tcomp -- buf tinfo kind ) 
\ returns a typeinfo, desckind, and a buffer
: >BINDPR ( ustr tcomp -- buf tinfo kind ) 
\ returns a typeinfo, desckind, and a buffer
: >BINDTYPE ( ustr tcomp -- tinfo) 
\ returns the ITypeinfo of ustr
: >VT ( n VT -- ) 
\ push Virtual Type onto Stack
: ?TYPELIB ( c-addr len flag -- c-addr len flag ) 
: ARG. ( funcdesc n -- ) 
\ prints an argument
: ARG>STR ( funcdesc n -- ) 
\ prints an argument to the screen
: ARG>VT ( funcdesc n -- vt ) 
\ returns argument type
: ARGCELLS ( VT -- #cells ) 
\ returns the number of cells needed for a vtype
: ARGSIZE ( funcdesc -- n ) 
\ returns size (in cells) of arguments
VALUE ARGTYPEI 
: BACKUP ( -- ) 
: CGUID ( tinfo -- ) 
\ compiles a guid
: CIFACE ( tinfo -- ) 
\ creates an interface pointer object
: CLOSE-INTERFACE ( -- ) 
: CLOSE-STRUCT ( -- ) 
: CLSID>STR ( addr -- str len ) 
: COCLASSES ( -- ) 
\ print a list of all available coclasses
: COM ( | name -- ... ) 
\ followed by Interface or structure
: COMCONSTS ( -- ) 
\ print a list of all constants
: COMFIND ( str -- str 0 | cfa flag ) 
: COMIFACE ( interface -- ) 
: COMPILE-INTERFACE ( pointer imethod -- ) 
\ fast compile interface call
: COM_INIT 
: CONSTBIND ( vardesc tinfo -- ) 
\ constants
: CSTRUCT ( tinfo -- ) 
\ creates a structure from a com typeinfo iface
CONSTANT DESCKIND_FUNCDESC 
CONSTANT DESCKIND_IMPLICITAPPOBJ 
CONSTANT DESCKIND_MAX \ pre-defined data types used by COM interface descriptors:
CONSTANT DESCKIND_NONE 
CONSTANT DESCKIND_TYPECOMP 
CONSTANT DESCKIND_VARDESC 
: DISPATCHCALL ( type ID Interface -- hres ) 
\ Call IDispatch Invoke method
: DISPATCHER ( <name> <progID> -- ) 
STRUCT DISPCALL \ calling structure
VARIABLE DISPERR 
: DISPLATE" ( interface "method"" -- hres ) 
\ late-late bound dispatch
STRUCTTYPE DISPPARAMS 
: DO-CIFACE ( ptr itypecomp -- ) 
: DO-DISP ( interface -- hres ) 
\ behavior of a dispatcher
: DO-DISPLATE ( interface interface str len -- hres ) 
\ bind by string, not by ID
: DO-LATE ( tinfo -- ) 
: DO-LATE-TCOMP ( ptr typecomp kind -- ) 
: DO-STRUCT ( offset itypecomp -- offset ) 
: DO-TDISPATCH ( tinfo -- ) 
: DO-TINTERFACE ( tinfo -- ) 
: DO-TYPELIB ( tcomp -- flag ) 
\ performs the function of the typelib stuff
STRUCTTYPE ELEMDESC 
: FIELD-XT ( addr -- n ) 
: FIELD: ( offset |name -- ) 
\ makes an offset
: FREE-LASTTYPELIB ( -- ) 
\ frees the last type library
: FREETYPELIBS ( -- ) 
: FUNCBIND ( obj funcdesc tinfo -- ) 
\ function
STRUCTTYPE FUNCDESC 
: FUNCOFF ( funcdesc -- offset ) 
\ returns offset into vtable ( bytes )
CONSTANT FUNC_DISPATCH \ typekind enumeration
CONSTANT FUNC_NONVIRTUAL 
CONSTANT FUNC_PUREVIRTUAL 
CONSTANT FUNC_STATIC 
CONSTANT FUNC_VIRTUAL 
: GET-NEXT ( tcomp -- buf tinfo kind ) 
\ if kind = -1, then tinfo is a nested struct
: GETDISPID ( ustr Interface -- ID ) 
\ Get Dispatch ID
: GLOBALTYPE ( type typelib -- ) 
: GUID, ( -- ) 
\ comments in a guid
UUID GUID_NULL 
: HATOI 
INTERFACE ICREATEERRORINFO 
INTERFACE IDISPATCH 
STRUCTTYPE IDLDESC 
INTERFACE IERRORINFO 
: IMETHOD ( n -- ) 
\ n is vtable index
: INTERFACE ( interface |guid -- ) 
: INTERFACE-CALL ( n1 n2 n3 ... nx a indx ) 
\ vtable call
: INTERFACES ( -- ) 
\ print a list of all available interfaces
CONSTANT INVOKE_FUNC 
CONSTANT INVOKE_PROPERTYGET 
CONSTANT INVOKE_PROPERTYPUT 
CONSTANT INVOKE_PROPERTYPUTREF \ Desckind enumeration
: ISTYPE? ( str len tcomp -- flag ) 
INTERFACE ISUPPORTERRORINFO 
INTERFACE ITYPECOMP 
INTERFACE ITYPEINFO 
INTERFACE ITYPELIB 
INTERFACE IUNKNOWN 
CONSTANT MAXVT \ Height of Stack
: METHKIND ( str len -- ustr kind ) 
: NESTED-STRUC? ( vardesc -- htyperef ) 
: OPEN-INTERFACE ( interface -- ) 
: OPEN-STRUCT ( interface -- ) 
VALUE OPENIFACE 
VALUE OPENSTRUCT 
STRUCTTYPE PARAMDESC 
STRUCTTYPE PARAMDESCEX 
: PEEK 
STRUCT RETVT \ return value - only one allowed :-(
: RETVT@ ( -- n VT ) 
: RUN-INTERFACE ( pointer imethod -- ) 
\ runtime interface call
: SEARCH-IFACE ( str len interface -- addr -1 | 0 ) 
: SEARCH-STRUCT ( str len structtype -- addr -1 | 0 ) 
: SKIP-WORD 
: STRUCT ( structtype -- ) 
: STRUCT-XT ( addr -- n ) 
: STRUCT: ( offset structtype |name -- ) 
: STRUCTBIND ( vardesc tinfo -- offset ) 
\ structures
: STRUCTSIZE ( structtype -- size ) 
: STRUCTTYPE ( size -- ) 
: STRUCTURES ( -- ) 
\ print a list of all available structures
: TATTR-ALLOT ( itypeinfo -- typeattr ) 
\ allocates a typeattr structure from tinfo
: TATTR-FREE ( itypeinfo typeattr -- ) 
\ frees a typeattr struct
CREATE TBUF 
CREATE TFIND 
: TINFO>KIND ( itypeinfo -- typekind ) 
\ returns a typekind constant
: TINFO>NFUNC ( itypeinfo -- typekind ) 
\ returns number of functions
: TINFO>NVARS ( itypeinfo -- typekind ) 
\ returns number of variables
: TINFO>SIZE ( itypeinfo -- size ) 
\ returns structure size
CONSTANT TKIND_ALIAS 
CONSTANT TKIND_COCLASS 
CONSTANT TKIND_DISPATCH 
CONSTANT TKIND_ENUM 
CONSTANT TKIND_INTERFACE 
CONSTANT TKIND_MAX \ VarKind enumeration
CONSTANT TKIND_MODULE 
CONSTANT TKIND_RECORD 
CONSTANT TKIND_UNION 
STRUCTTYPE TYPEATTR 
STRUCTTYPE TYPEDESC 
: TYPEDESC>N ( typedesc -- vt n  ) 
\ returns type and how many times its "pointed"
: TYPEDESC>TYPE ( typedesc -- ) 
\ prints a typedesc var to the screen
: TYPELIB ( major minor | guid -- ) 
\ load a type library into the list
: TYPELIBFILE ( ustr len -- ) 
\ load a type library from a file
CREATE TYPELIBHEAD 
VARIABLE TYPELIBRARIES 
: UCOM ( pointer -- ) 
\ call using an interface
: USESTRUCT ( addr |structtype -- addr ) 
\ works like "using"
: UUID ( |guid -- ) 
: VARBIND ( vardesc tinfo -- n ) 
\ both structures and constants
STRUCTTYPE VARDESC 
VALUE VARGS 
STRUCTTYPE VARIANT 
: VARINST ( vardesc -- n ) 
\ returns constant or (if its a structure) an offset
CONSTANT VAR_CONST 
CONSTANT VAR_DISPATCH \ Invoke Kind
CONSTANT VAR_PERINSTANCE 
CONSTANT VAR_STATIC 
: VT! ( n VT addr -- ) 
: VT> ( -- n VT ) 
\ pop virtual type off stack
: VT>STR ( vt -- str len ) 
\ for type to string conversion
: VT@ ( addr -- n VT ) 
CREATE VTNSTACK 
CREATE VTSTACK 
CONSTANT VT_ARRAY \ pointer to safearray
CONSTANT VT_BLOB \ 32-bit count of bytes followed by that number of bytes
CONSTANT VT_BLOBOBJECT \ a blob containing a serialize object
CONSTANT VT_BOOL \ boolean value
CONSTANT VT_BSTR \ pointer to Null-terminated unicode string--see unicode notes above
CONSTANT VT_BYREF \ value is a reference
CONSTANT VT_CARRAY \ normal array type
CONSTANT VT_CF \ pointer to a clip structure
CONSTANT VT_CLSID \ pointer to guid (or a clsid, or what-have-you)
CONSTANT VT_CY \ 8 byte two's complement integer (scaled by 10000, used for currency)
CONSTANT VT_DATE \ 64-bit floating-point number representing the days since Dec. 31, 1899
CONSTANT VT_DECIMAL \ a decimal structure
CONSTANT VT_DISPATCH \ pointer to a IDispatch interface
CONSTANT VT_EMPTY \ no data associated with this
CONSTANT VT_ERROR \ 32-bit number containing status code
CONSTANT VT_FILETIME \ 64-bit FileTime structure (see win32 api)
CONSTANT VT_HRESULT \ standard return code
CONSTANT VT_I1 \ 1 byte signed integer
CONSTANT VT_I2 \ 2 bytes signed integer
CONSTANT VT_I4 \ 4 bytes signed integer
CONSTANT VT_I8 \ 8 bytes signed integer
CONSTANT VT_ILLEGAL \ illigal variant
CONSTANT VT_ILLEGALMASK \ Illegal variant mask.
CONSTANT VT_INT \ same as VT_I4 but with a different code (?? what on earth are these people thinking!!?!)
CONSTANT VT_LPSTR \ pointer to Null-terminated ansi string
CONSTANT VT_LPWSTR \ pointer to Null-terminated unicode string
CONSTANT VT_NULL \ same as a regular NULL
CONSTANT VT_PTR \ pointer to something
CONSTANT VT_R4 \ IEEE 32-bit floating-point number
CONSTANT VT_R8 \ IEEE 64-bit floating-point number
CONSTANT VT_RESERVED \ reserved type
CONSTANT VT_SAFEARRAY \ safearray
CONSTANT VT_STORAGE \ pointer to an IStorage interface
CONSTANT VT_STORED_OBJECT \ same as storage, but contains an object
CONSTANT VT_STREAM \ pointer to an IStream interface
CONSTANT VT_STREAMED_OBJECT \ same as stream, but contains an object
CONSTANT VT_TYPEMASK \ used as a mask for vt_vector, array and what-not
CONSTANT VT_UI1 \ 1 byte unsigned integer
CONSTANT VT_UI2 \ 2 bytes unsigned integer
CONSTANT VT_UI4 \ 4 bytes unsigned integer
CONSTANT VT_UI8 \ 8 bytes unsigned integer
CONSTANT VT_UINT \ same as VT_UI4 but with a different code (I can only suppose for clarity....)
CONSTANT VT_UNKNOWN \ pointer to a IUnknown interface
CONSTANT VT_USERDEFINED \ user defined type
CONSTANT VT_VARIANT \ type indicator followed by corresponding value
CONSTANT VT_VECTOR \ array of types, pointer to count, then pointer to the array
CONSTANT VT_VOID \ void (results I suppose)
INT #BYTESREAD 
ANEW -FILE.F 
: ?FILEERROR { \ msg$ -- } 
:M ALLOCBUFFER: ( len -- ) 
\ Allocate memory for the file-buffer
:M APPEND: ( -- ) 
\ Set append mode
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLEARNAME: ( -- ) 
\ Clear the file name
:M CLOSE: ( -- ) 
\ Close the file.
:M CREATE: ( -- f ) 
\ Create the file.
:M DELETE: ( -- ) 
\ Delete the file
INT DOERROR? 
INT ERRORCODE 
:M ERRORCODE: ( -- n ) 
\ Get the error code of the previous file I/O
:M EXIST?: ( -- f ) 
\ Check if the file exist
:CLASS FILE 
:CLASS FILE 
INT FILEBUFFER 
BYTES FILENAME 
:M FILESIZE: ( -- ud ) 
\ Get the size of the file
:M FLUSH: ( -- ) 
\ Flush the file
:M GETBUFFER: ( -- addr len ) 
\ Fet the address and len of the file-buffer
:M GETLENGTH: ( -- len ) 
\ Get the length of the file-buffer
:M GETNAME: ( -- addr ) 
\ Get the file name
:M GETPOSITION: ( -- ud ) 
\ Get the position of the file pointer
INT HFILE \ file handle
: ISMSGTEXT ( addr cnt -- ) 
:M LOADFILE: ( addr len -- f ) 
\ load a file into the file-buffer, f=true on success
INT MODE \ file access mode
BYTES MSGTEXT 
:M OPEN: ( -- f ) 
\ Open the file
:M READ: { addr cnt -- f } 
\ Read cnt bytes from the file into memory
:CLASS READFILE 
:CLASS READFILE 
:M READLINE: ( addr len -- len eof ) 
\ Read a line from the file.
:M RELEASEBUFFER: ( -- ) 
\ Free the memory of the file-buffer
:M RENAME: { addr cnt -- } 
\ Rename the file.
:M REPOSITION: ( ud -- ) 
\ Set the position of the file pointer
:M RESIZE: ( ud -- ) 
\ Resize the file
:M SAVEFILE: ( -- ) 
\ Save the file-buffer to the file
:M SETBUFFER: ( addr len -- ) 
\ Set the address and length of the file-buffer
:M SETLENGTH: ( len -- ) 
\ Set the length of the file-buffer.
\ NOTE: with this method you can set the length behind the
\ allocated memory of the file-buffer! So take care.
:M SETMODE: ( mode -- ) 
\ Set the I/O mode
:M SETNAME: ( addr cnt -- ) 
\ Set the file name
:M WRITE: { addr cnt -- f } 
\ Write cnt bytes from memory into the file.
:M WRITELINE: ( addr len -- ) 
\ Write a line to the file
:M ~: ( -- ) 
CREATE COMMANDLINE 
CREATE DEFAULTICON 
: DELETEASSOCIATION ( s" .ext"  s" App.exe" -- ) 
: DELETEEXTENSION ( -- ) 
\ if default value is empty, otherwise just delete previous key
: DELETEKEYVALUE ( hKey s" Value Name" -- ) 
\ deletes value HKEY_CLASSES_ROOT\<Key Name>\<Value Name>
: DELETETYPENAMESUBKEY ( s" SubKey" -- ) 
\ deletes key HKEY_CLASSES_ROOT\<TypeName>\<SubKey>
CREATE FILEEXTENSION 
CREATE FILETYPE 
CREATE OPTIONS 
CREATE PREVIOUSKEY 
: RESTOREDEFAULTVALUE ( -- ) 
\ if previous key exists
: RESTOREREGPATH ( -- ) 
: SAVEDEFAULTVALUE ( -- ) 
\ will be empty for a new extension
: SETASSOCIATION ( s" .ext"  s" Type"  s" App.exe </Options>" -- ) 
: SETHKCRPATH ( -- ) 
CREATE TYPENAME 
INT #DIRS \ number of directories found when updating
:M #DIRS: ( -- n ) 
:M #DIRS: ( -- n ) 
:M #FILES: ( -- n ) 
:M #FILES: ( -- n ) 
INT #FLS \ ditto files
ANEW -FILELISTER.F 
: .OR..? ( -- f ) 
\ is found file directories . or ..?
: .OR..? ( -- f ) 
\ is found file directories . or ..?
: ?HASFILES ( -- f ) 
\ does a directory have any files?
: ?ITEMIMAGE ( -- n ) 
: ?ROOTIMAGE ( -- n ) 
: ADD-FOLDERBMP { \ hbitmap -- } 
: ADD-ICONS { \ item -- } 
\ add icon for each file
: ADD-ITEMS ( -- ) 
\ actually add found files to tree
: ADDFILE ( str cnt -- ) 
:M ADDICON: ( -- ) 
: ADDIMAGES ( -- ) 
: ADDROOT ( -- ) 
:M ADDSTYLE: ( n -- ) 
: ADDTREEITEM ( -- ) 
\ add file or directory to tree
BYTES ALTERNATEFILENAME 
:M ASCEND: ( -- ) 
:M CHOOSEFOLDER: ( -- ) 
\ change folder programatically, also available by right clicking
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLOSE: ( -- ) 
:M CLOSE: ( -- ) 
: COMPARE-RECS ( n1 n2 -- f ) 
: CREATEIMAGELIST ( -- ) 
\ create image list for treeview control
: CREATETREE ( -- ) 
:M DELETEFILE: ( -- ) 
\ delete selected file after confirmation
:M DELETEFILE: ( -- ) 
:M DELETEITEM: { item \ flag -- } 
:M DESCEND: ( --) 
: DISPOSETHELIST ( -- ) 
: DOSORTORDER ( n -- f ) 
INT FILEATTRIBUTES 
INT FILECREATIONTIMEHIGH 
INT FILECREATIONTIMELOW 
:OBJECT FILEFINDER 
INT FILELASTACCESSTIMEHIGH 
INT FILELASTACCESSTIMELOW 
INT FILELASTWRITETIMEHIGH 
INT FILELASTWRITETIMELOW 
:M FILELIST: ( -- list ) 
:M FILELIST: ( -- list ) 
BYTES FILENAME 
INT FILESIZEHIGH 
INT FILESIZELOW 
:CLASS FILEWINDOW 
:CLASS FILEWINDOW 
: FINDALLFILES ( -- ) 
BYTES FINDPATH 
BYTES FINDSPECS 
LOAD-BITMAP FOLDERBMP 
:CLASS FOLDERITEM 
:CLASS FOLDERITEM 
INT FOLDERLIST 
:CLASS FOLDERTREE 
:CLASS FOLDERTREE 
: FREE-RECBUFFER ( -- ) 
:M GETDATA: ( -- addr cnt ) 
\ access for any additional information needed
:M GETENTRY: { n -- obj | 0 } 
:M GETFILEATTRIBUTES: ( -- n ) 
:M GETFILENAME: ( -- adr cnt ) 
:M GETFILESIZE: ( -- d ) 
:M GETNAME$: ( -- addr cnt ) 
:M GETNAME: ( -- namez ) 
:M GETNAME: ( -- addrz ) 
:M GETPATH: ( -- addr cnt ) 
:M GETPATH: ( -- addr cnt ) 
:M GETSPECS: ( -- addr cnt ) 
:M GETSPECS: ( -- addr cnt ) 
:M HANDLE: ( -- hwnd ) 
:M HANDLE: ( -- n ) 
:M HANDLE: ( -- hwndmain ) 
INT HWNDIMAGE \ handle to imagelist
INT HWNDITEM \ handle for item
INT HWNDLABEL \ handle to window to display path
\ number of files shown is limited only by available memory
\ however only first 4k will be sorted. Of course the buffer size could always be increased
INT HWNDLIST 
INT HWNDMAIN \ handle of root item in tree
INT ICONHANDLE 
:M ICONHANDLE: ( -- n ) 
BYTES INDEX \ save information for each individual file
:M INDEX: ( -- n ) 
:M ISDIRECTORY?: ( -- f ) 
\ exclude . and ..
:M ISFILE?: ( -- f ) 
:M ISHANDLE: ( hwnd -- ) 
:M ISHANDLE: ( n -- ) 
:M ISICONHANDLE: ( n -- ) 
:M ISINDEX: ( n -- ) 
:M ISITEMID: ( f -- ) 
:M ISITEMID: ( f -- ) 
:M ISLABELHANDLE: ( hwnd -- ) 
:M ISLABELHANDLE: ( hwnd -- ) 
\ handle of window that will display path name
:M ISON_UPDATE: ( cfa -- ) 
\ cfa to execute whenever the display is updated
:M ISON_UPDATE: ( cfa -- ) 
:M ISPARENTITEM: ( n -- ) 
:M ISPARENTTREE: ( n -- ) 
:M ISTREE-CLICK: ( cfa -- ) 
:M ISTREE-CLICK: ( cfa -- ) 
\ set cfa to be executed when item in tree is clicked
:M ISTREE-DBLCLICK: ( cfa -- ) 
\ set cfa to be executed when item in tree is double-clicked
SHORT ITEMFLAGS 
INT ITEMHANDLE \ parent handle
BITS ITEMID \ item id, 0 for child item
INT ITEMID 
:M ITEMID: ( -- f ) 
:M ITEMID: ( -- f ) 
RECORD: ITEMINFO 
BYTES ITEMNAME 
CONSTANT LISTMAX \ maximum length of list name
BYTES LISTNAME 
CONSTANT MAX-RECS \ about 4000 files and directories for sorting
: NULL-CHECK ( a1 -- a1 ) 
:M ON_INIT: ( -- ) 
:M ON_SELCHANGED: ( -- f ) 
\ 
:M ON_SIZE: ( -- ) 
INT ON_UPDATE \ called when folder tree is refreshed
INT PARENTITEM \ parent item in treeview control
:M PARENTITEM: ( -- n ) 
INT PARENTTREE \ parent treeview control
:M PARENTTREE: ( -- n ) 
: READRECBUFFER ( -- ) 
\ load temporary buffer with record pointers
INT RECBUFFER \ pointer to memory used for sorting
: RECBUFFER() ( n -- addr ) 
CONSTANT RECBUFFER-SIZE 
: REGISTERLIST ( -- ) 
\ register list with this treeview control
INT RESERVED0 
INT RESERVED1 
BITS RESERVEDFLAGS 
: ROOTDIR? { pathstr cnt -- f } 
\ f = true if path is at root
BYTES ROOTNAME 
INT SELECTEDITEM \ tree item object
:M SELECTEDITEM: ( -- n ) 
:M SELECTEDITEM: ( -- ) 
\ selected file or directory, itemid = 0 means it is a file
:M SETHANDLE: ( hwnd -- ) 
:M SETNAME: ( addr cnt -- ) 
\ assumes name is set for FindFirstFile, FindNextFile etc.
:M SETNAME: ( addr cnt  -- ) 
:M SETPATH: { addr cnt -- } 
\ check for valid path
:M SETPATH: ( addr cnt -- ) 
\ set for valid path
:M SETROOTNAME: ( addr cnt -- ) 
:M SETSPECS: ( addr cnt -- ) 
:M SETSPECS: ( addr cnt -- ) 
\ e.g s" *.f;*.seq;*.frm;*.txt"
INT SHOW-FILES? \ do we want to display files as well as directories?
: SHOW-PATH ( -- ) 
:M SHOWFILES: ( f -- ) 
:M SHOWFILES: ( f -- ) 
\ allow or disallow display of files in tree
;RECORDSIZE: SIZEOF(ITEMINFO) 
;RECORDSIZE: SIZEOF(WIN32_FIND_DATA) 
:M SORTASCENDING: ( -- ) 
:M SORTASCENDING: ( -- ) 
:M SORTDESCENDING: ( -- ) 
:M SORTDESCENDING: ( -- ) 
: SORTFILES ( -- ) 
INT SORTORDER 
:M START: ( parent -- ) 
:M THEFOLDERTREE: ( -- obj ) 
\ direct access to the tree
BYTES THESPECS 
FOLDERTREE THISFOLDER 
INT THISITEM \ temp pointer to new item
:M TOTAL: ( -- n ) 
\ sum of files and directories
:M TOTAL: ( -- n ) 
INT TREE-CLICK \ called when an item is clicked
INT TREE-DBLCLICK 
:CLASS TREELIST 
:CLASS TREELIST 
BYTES TREEPATH \ path: thespecs
:M UPDATEFILES: ( -- ) 
:M UPDATEFILES: ( -- ) 
\ update the display
: UPDATELIST ( addr cnt -- ) 
\ save file info
RECORD: WIN32_FIND_DATA 
:M WINDOWSTYLE: ( -- style ) 
:M WINDOWSTYLE: ( -- style ) 
:M WM_NOTIFY ( h m w l -- f ) 
: WRITERECBUFFER ( -- ) 
\ rewrite sorted records to database
INT WSTYLE \ additional window style e.g WS_BORDER
:M ~: ( -- ) 
ANEW -FLASHCONTROL 
:M BACK: ( -- ) 
:M BGCOLOR: ( -- color ) 
:M CURRENTFRAME: ( -- n ) 
BYTES FLASH \ pointer to IShockwaveFlash interface
:CLASS FLASHCONTROL 
:CLASS FLASHCONTROL 
:M FORWARD: ( -- ) 
:M GETMOVIE: ( -- str len ) 
:M GOTOFRAME: ( n -- ) 
:M LOADED%: ( -- percent ) 
:M LOOP: ( flag -- ) 
:M LOOP?: ( -- flag ) 
:M ON_DONE: ( -- ) 
:M PAN: ( n n n -- ) 
:M PLAY: ( -- ) 
:M PLAYING?: ( -- flag ) 
:M PUTMOVIE: ( str len -- f ) 
:M REWIND: ( -- ) 
:M SETBGCOLOR: ( color -- ) 
:M SETZOOMRECT: ( n n n n -- ) 
:M START: ( Parent -- ) 
:M STOP: ( -- ) 
:M STOPPLAY: ( -- ) 
:M TOTALFRAMES: ( -- n ) 
BYTES XTRA \ xtra space for api calls
:M ZOOM: ( n -- ) 
ANEW -GETWINDOWPLACMENT.F 
LONG BOTTOM 
UINT FLAGS 
: GETWINDOWPLACMENT ( hWnd -- wp ) 
\ get window placement
LONG LEFT 
UINT LENGTH 
}STRUCT POINT 
POINT PTMAXPOSITION 
POINT PTMINPOSITION 
RECT RCNORMALPOSITION 
}STRUCT RECT 
LONG RIGHT 
UINT SHOWCMD 
LONG TOP 
}STRUCT WINDOWPLACEMENT 
MKSTRUCT: WP 
LONG X 
LONG Y 
ANEW -HTMLCONTROL.F 
:M BUSY?: ( -- flag ) 
\ Retrieves a boolean value that indicates whether the browser is engaged in a
\ downloading operation or other activity.
:M GETLOCATIONNAME: ( -- str len ) 
\ Retrieves the name of the resource that the browser is currently displaying.
:M GETLOCATIONURL: ( -- str len ) 
\ Retrieves the URL of the resource that the browser is currently displaying.
:M GETTYPE: ( -- str len ) 
\ Retrieves the type name of the contained document object.
:M GOBACK: ( -- ) 
\ Navigates backward one item in the history list.
:M GOFORWARD: ( -- ) 
\ Navigates forward one item in the history list.
:M GOHOME: ( -- ) 
\ Navigates to the current home or start page.
:M GOSEARCH: ( -- ) 
\ Navigates to the current search page.
:M GOURL: ( str len -- ) 
\ Navigates to a resource identified by a Uniform Resource
\ Locator (URL) or to the file identified by a full path.
:CLASS HTMLCONTROL 
:CLASS HTMLCONTROL 
:M OFFLINE?: ( -- flag ) 
\ Retrieves a Boolean value indicating whether the browser is currently operating
\ in offline mode.
:M ON_DONE: ( -- ) 
:M REFRESH: ( -- ) 
\ Reloads the file that the browser is currently displaying.
:M SETURL: ( zUrl -- ) 
\ Navigates to a resource identified by a Uniform Resource
\ Locator (URL) or to the file identified by a full path.
:M START: ( Parent -- ) 
\ Start the control
:M STOP: ( -- ) 
\ Cancels any pending navigation or download operation and
\ stops any dynamic page elements, such as background sounds
\ and animations.
BYTES WEB \ pointer to IWebBrowser2 interface
BYTES XTRA \ xtra space for api calls
CONSTANT #BUTTONS 
ANEW -HTMLDISPLAYWINDOW.F 
: ADD-TOOLBAR ( -- ) 
: ADJUSTWINDOWSIZE { width height win -- } 
INT BUTTONTEXT? 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLOSE: ( -- ) 
INT FLATTOOLBAR? 
:M GOBACK: ( -- ) 
:M GOFORWARD: ( -- ) 
:M GOHOME: ( -- ) 
:M GOSEARCH: ( -- ) 
:M HANDLE_NOTIFY: ( ) 
INT HBITMAP 
 HTMLCONTROL 
LOAD-BITMAP HTMLDISPLAYBITMAPS 
:CLASS HTMLDISPLAYREBAR 
:CLASS HTMLDISPLAYREBAR 
:TOOLBARTABLE HTMLDISPLAYTABLE \ Bitmap index id                 Initial state    Initial style      tool string index
:CLASS HTMLDISPLAYTOOLBAR 
:CLASS HTMLDISPLAYTOOLBAR 
:TOOLSTRINGS HTMLDISPLAYTOOLSTRINGS 
:TOOLSTRINGS HTMLDISPLAYTOOLTIPS 
:CLASS HTMLDISPLAYWINDOW 
:CLASS HTMLDISPLAYWINDOW 
HTMLDISPLAYREBAR HTMLREBAR 
HTMLDISPLAYTOOLBAR HTMLTOOLBAR 
CONSTANT IDM_HTML_BACK 
CONSTANT IDM_HTML_FORWARD 
CONSTANT LARGEBUTTONHEIGHT 
CONSTANT LARGEBUTTONWIDTH \ for buttons with text
:M ONWMCOMMAND: ( hwnd msg wparam lparam -- hwnd msg wparam lparam ) 
:M ON_DONE: ( -- ) 
:M ON_INIT: ( -- ) 
:M ON_SIZE: ( -- ) 
:M ON_TOOLBARCHANGE: ( -- f ) 
\ User has changed toolbar
:M REFRESH: ( -- ) 
:M SETURL: ( zUrl -- ) 
:M SHOW: ( f -- ) 
INT SHOWTOOLBAR? 
CONSTANT SMALLBUTTONHEIGHT 
CONSTANT SMALLBUTTONWIDTH \ a little bigger than Windows default
:M START: ( parent -- ) 
:M START: ( parent -- ) 
:M STOP: ( -- ) 
:M WINDOWSTYLE: ( -- style ) 
:M WINDOWSTYLE: ( -- style ) 
:M WM_NOTIFY ( h m w l -- res ) 
: "HYPER { adr len adr1 len1 -- #line adr2 len2 true } 
( -- false ) 
\ adr  len  => the Word
\ adr1 len1 => the Index-File
\ first try to find the word in the dictionary
: "HYPER-DICT ( adr len -- #line adr1 len1 true ) 
( adr len -- false ) 
: "HYPER-INDEX ( adr len adr1 len1 -- #line adr2 len2 true ) 
( -- false ) 
NAMED-NEW$ HYPER-BUF 
MAP-HANDLE HYPER-HNDL \ Look in the dictionary for the Word adr/len
\ return Line and Filename if found
VALUE HYPER-START 
NAMED-NEW$ HYPER-STRING 
NAMED-NEW$ PREV-HYPER-STRING 
INT &BITMAP 
INT >&BITMAP 
: ?VERSION3+ ( -- f ) 
:M ADJUSTBRIGHTNESS: ( fs: percentage -- ) 
\ float
:M ADJUSTCONTRAST: ( fs: percentage -- ) 
\ float
:M ADJUSTGAMMA: ( fs: gamma -- ) 
\ float
INT BACKGROUNDCOLOR 
 BEST_FIT 
:M BITSPERPIXEL: ( -- n ) 
#DEFINE BMP_DEFAULT 
#DEFINE BMP_SAVE_RLE 
: CALCIMAGESIZE { \ cxDib cyDib - wDib hDib } 
: CHECK-BITS ( -- ) 
: CHECK-MODE ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLONE: ( -- fibitmap ) 
:M CONVERTTO16BITS: ( -- ) 
:M CONVERTTO24BITS: ( -- ) 
:M CONVERTTO32BITS: ( -- ) 
:M CONVERTTO8BITS: ( -- ) 
#DEFINE CUT_DEFAULT 
CONSTANT DDF_SAME_HDC 
:M DISABLEPOPUP: ( -- ) 
: DISPLAYIMAGE ( -- ) 
INT DOPOPUP? 
INT DRAWDIBDC 
:M ENABLEPOPUP: ( -- ) 
: ERASEPARTOFWINDOW ( left top right bottom ) 
AS FIADJUSTBRIGHTNESS 
AS FIADJUSTCONTRAST 
AS FIADJUSTGAMMA 
INT FIBITMAP \ pointer to FreeImage bitmap structure
AS FIBITSPERPIXEL 
 FICC_ALPHA \ Use alpha channel
 FICC_BLACK \ Use black channel
 FICC_BLUE \ Use blue channel
 FICC_GREEN \ Use green channel
 FICC_IMAG \ Complex images: use imaginary part
 FICC_MAG \ Complex images: use magnitude
 FICC_PHASE \ Complex images: use phase
 FICC_REAL \ Complex images: use real part
 FICC_RED \ Use red channel
 FICC_RGB \ Use red, green and blue channels
AS FICLONE 
AS FICONVERTFROMRAWBITS 
AS FICONVERTTO16BITS 
AS FICONVERTTO24BITS 
AS FICONVERTTO32BITS 
AS FICONVERTTO8BITS 
 FIC_CMYK \ CMYK color model
 FIC_MINISBLACK \ min value is black
 FIC_MINISWHITE \ min value is white
 FIC_PALETTE \ color map indexed
 FIC_RGB \ RGB color model
 FIC_RGBALPHA \ RGB color model with alpha channel
 FID_BAYER4X4 \ Bayer ordered dispersed dot dithering (order 2 dithering matrix)
 FID_BAYER8X8 \ Bayer ordered dispersed dot dithering (order 3 dithering matrix)
 FID_CLUSTER16X16 \ Ordered clustered dot dithering (order 8 - 16x16 matrix)
 FID_CLUSTER6X6 \ Ordered clustered dot dithering (order 3 - 6x6 matrix)
 FID_CLUSTER8X8 \ Ordered clustered dot dithering (order 4 - 8x8 matrix)
 FID_FS \ Floyd & Steinberg error diffusion
AS FIFLIPHORIZONTAL 
AS FIFLIPVERTICAL 
 FIF_BMP 
 FIF_CUT 
 FIF_GIF 
 FIF_ICO 
CONSTANT FIF_IFF \ Image type used in FreeImage.
 FIF_JNG 
 FIF_JPEG 
 FIF_KOALA 
 FIF_LBM 
 FIF_MNG 
 FIF_PBM 
 FIF_PBMRAW 
 FIF_PCD 
 FIF_PCX 
 FIF_PGM 
 FIF_PGMRAW 
 FIF_PNG 
 FIF_PPM 
 FIF_PPMRAW 
 FIF_PSD 
 FIF_RAS 
 FIF_TARGA 
 FIF_TIFF 
ENUM: FIF_UNKNOWN 
 FIF_WBMP 
 FIF_XBM 
 FIF_XPM 
AS FIGETBITS 
AS FIGETFILETYPE 
AS FIGETHEIGHT 
AS FIGETINFO 
AS FIGETINFOFROMFILENAME 
AS FIGETVERSION 
AS FIGETWIDTH 
AS FIINVERT 
AS FILOAD 
AS FILOADFROMHANDLE 
 FILTER_BICUBIC \ Mitchell & Netravali's two-param cubic filter
 FILTER_BILINEAR \ Bilinear filter
 FILTER_BOX \ Box, pulse, Fourier window, 1st order (constant) b-spline
 FILTER_BSPLINE \ 4th order (cubic) b-spline
 FILTER_CATMULLROM \ Catmull-Rom spline, Overhauser spline
 FILTER_LANCZOS3 \ Lanczos3 filter
 FIQ_NNQUANT \ NeuQuant neural-net quantization algorithm by Anthony Dekker
 FIQ_WUQUANT \ Xiaolin Wu color quantization algorithm
CALLBACK: FIREADPROC { &buffer size cnt fihandle -- cnt } 
AS FIRESCALE 
AS FIROTATE 
AS FISAVE 
CALLBACK: FISEEKPROC { fihandle offset origin -- 0 } 
CALLBACK: FITELLPROC { fihandle -- res } 
 FIT_BITMAP \ standard image           : 1-, 4-, 8-, 16-, 24-, 32-bit
 FIT_COMPLEX \ array of FICOMPLEX       : 2 x 64-bit IEEE floating point
 FIT_DOUBLE \ array of double          : 64-bit IEEE floating point
 FIT_FLOAT \ array of float           : 32-bit IEEE floating point
 FIT_INT16 \ array of short           : signed 16-bit
 FIT_INT32 \ array of long            : signed 32-bit
 FIT_SIZE 
 FIT_UINT16 \ array of unsigned short  : unsigned 16-bit
 FIT_UINT32 \ array of unsigned long   : unsigned 32-bit
 FIT_UNKNOWN \ unknown type
AS FIUNLOAD 
CALLBACK: FIWRITEPROC { &buffer size cnt fihandle -- size } 
:M FLIPHORIZONTAL: ( -- ) 
:M FLIPVERTICAL: ( -- ) 
:CLASS FREEIMAGEWINDOW 
:CLASS FREEIMAGEWINDOW 
: GEN-ID ( -- id ) 
FILEOPENDIALOG GETIMAGEFILE 
#DEFINE ICO_DEFAULT 
#DEFINE ICO_FIRST 
#DEFINE ICO_SECOND 
#DEFINE ICO_THIRD 
#DEFINE IFF_DEFAULT 
VALUE IMAGE-ID 
WINDC IMAGEDC 
BYTES IMAGEFILENAME 
:M IMAGEFILENAME: ( -- addr cnt ) 
\ return name of image file
:M IMAGEHANDLE: ( -- fibitmap ) 
:M IMAGEHEIGHT: ( -- h ) 
POPUPBAR IMAGEPOPUPBAR 
:M IMAGEWIDTH: ( -- w ) 
:M INVERTIMAGE: ( -- ) 
CREATE IOPROCS 
#DEFINE JPEG_ACCURATE 
#DEFINE JPEG_DEFAULT 
#DEFINE JPEG_FAST 
#DEFINE JPEG_QUALITYAVERAGE 
#DEFINE JPEG_QUALITYBAD 
#DEFINE JPEG_QUALITYGOOD 
#DEFINE JPEG_QUALITYNORMAL 
#DEFINE JPEG_QUALITYSUPERB 
#DEFINE KOALA_DEFAULT 
#DEFINE LBM_DEFAULT 
:M LOADFROMHANDLE: { FIF_FORMAT addr -- FIBITMP } 
: LOADIMAGE ( -- ) 
:M LOADMEMORYBITMAP: ( &bitmap -- ) 
#DEFINE MNG_DEFAULT 
:MENUITEM MNU16 
:MENUITEM MNU24 
:MENUITEM MNU32 
:MENUITEM MNU8 
:MENUITEM MNUBLACK 
:MENUITEM MNUFIT 
:MENUITEM MNUNORM 
:MENUITEM MNUSCALE 
:MENUITEM MNUWHITE 
ENUM: NORMAL_FIT 
:M ON_DONE: ( -- ) 
:M ON_INIT: ( -- ) 
:M ON_PAINT: ( -- ) 
: OPEN-IMAGE ( -- ) 
:M OPENIMAGEFILE: ( -- ) 
#DEFINE PCD_BASE 
#DEFINE PCD_BASEDIV16 
#DEFINE PCD_BASEDIV4 
#DEFINE PCD_DEFAULT 
#DEFINE PCX_DEFAULT 
#DEFINE PNG_DEFAULT 
#DEFINE PNG_IGNOREGAMMA 
#DEFINE PNM_DEFAULT 
#DEFINE PNM_SAVE_ASCII 
#DEFINE PNM_SAVE_RAW 
#DEFINE PSD_DEFAULT 
#DEFINE RAS_DEFAULT 
:M REFRESH: ( -- ) 
:M RELOAD: ( -- ) 
\ redraw using earlier set image
:M ROTATEIMAGE: ( fs: degrees -- ) 
\ float
FILESAVEDIALOG SAVEASBITMAPDLG 
:M SAVEASBMP: ( -- ) 
:M SAVEASJPEG: ( -- ) 
:M SAVEASPNG: ( -- ) 
:M SAVEIMAGE: { imgtype imgparam -- } 
\ At the same size
:M SETBACKGROUNDCOLOR: ( color_object -- ) 
:M SETIMAGEFILE: ( addr cnt -- ) 
\ filename for image
:M SETIMAGEFROMMEMORY: ( flag blue green red depth pitch height width lpvbits -- ) 
:M SETIMAGEHANDLE: ( fibitmap -- ) 
:M SETVIEWMODE: ( f -- ) 
: SHOWIMAGE ( -- ) 
\ load and draw Image; keep Image size
: SHOWIMAGEINFIXEDWINDOW ( -- ) 
\ load and draw Image; fit to window
: SHOWSCALEDIMAGE ( --) 
\ load and draw Image; keep aspect ratio
#DEFINE TARGA_DEFAULT 
#DEFINE TARGA_LOAD_RGB555 
#DEFINE TARGA_LOAD_RGB888 
VALUE THISIMAGE \ allow forward referencing for right click
#DEFINE TIFF_ADOBE_DEFLATE 
#DEFINE TIFF_CMYK 
#DEFINE TIFF_DEFAULT 
#DEFINE TIFF_DEFLATE 
#DEFINE TIFF_NONE 
#DEFINE TIFF_PACKBITS 
:M UNLOADIMAGE: ( -- ) 
: VALIDIMAGE? ( -- f ) 
INT VIEWMODE 
#DEFINE WBMP_DEFAULT 
VALUE WINCNT \ count of open image windows
: WIPE-WINDOW ( -- ) 
:M WIPE: ( -- ) 
\ clear any image from window
:M WM_LBUTTONDBLCLK ( h w m l -- ) 
:M WM_RBUTTONDOWN ( h m w l -- ) 
#DEFINE XBM_DEFAULT 
#DEFINE XPM_DEFAULT 
:M ZOOM: { w h -- } 
ANEW -LABEL.F 
:M BLACKFRAME: ( -- ) 
\ Frame in the window frame color (default is black).
:M BLACKRECT: ( -- ) 
\ Rectangle in the window frame color (default is black).
:M ETCHEDFRAME: ( -- ) 
\ draws an etched frame (frame appears lower than background)
:M GETIMAGE: ( -- hImage ) 
\ Retrieve a handle to the image associated with the control.
:M GRAYFRAME: ( -- ) 
\ Frame in the screen background color (default is gray).
:M GRAYRECT: ( -- ) 
\ Rectangle in the screen background color (default is gray).
:M IMAGETYPE: ( -- ImageType ) 
\ Get the image type of the control.  ImageType  is IMAGE_ICON.
:M IMAGETYPE: ( -- ImageType ) 
\ Get the image type of the control.  ImageType  is IMAGE_ENHMETAFILE.
:M IMAGETYPE: ( -- ImageType ) 
\ Get the image type of the control.  ImageType  is IMAGE_BITMAP.
:CLASS LABEL 
:CLASS LABEL 
:M SETFONT: ( fhndl -- ) 
\ Set the font in the control.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETIMAGE: ( hImage -- ) 
\ Associate a new image (icon or bitmap) with the control.
:CLASS STATICBITMAP 
:CLASS STATICBITMAP 
:CLASS STATICFRAME 
:CLASS STATICFRAME 
:CLASS STATICICON 
:CLASS STATICICON 
|CLASS STATICIMAGE 
|CLASS STATICIMAGE 
:CLASS STATICMETAFILE 
:CLASS STATICMETAFILE 
:M SUNKENFRAME: ( -- ) 
\ Draws frame with half-sunken border.
:M WHITEFRAME: ( -- ) 
\ Frame in the window background color (default is white).
:M WHITERECT: ( -- ) 
\ Rectangle in the window background color (default is white).
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: SS_ENHMETAFILE.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: SS_BITMAP.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: SS_ICON.
:M #LINKS: ( -- n ) 
ANEW -LINKLIST.F 
:M >FIRSTLINK: ( --  ) 
:M >LASTLINK: ( --  ) 
:M >LINK#: ( n --  ) 
:M >NEXTLINK: ( --  ) 
:M >PREVLINK: ( --  ) 
:M ADDLINK: ( --  ) 
\ --- Add line at end of document and makes it current
:M CLASSINIT: ( --  ) 
:M CLASSINIT: ( --  ) 
INT CURRENTLINK \ address of active link
:M CURRLINK@: ( -- n ) 
INT DATA \ pointer to data object
:M DATA!: ( n --  ) 
\ set data/pointer
:M DATA@: ( -- n ) 
\ get data/pointer
: DELETEFIRST ( --  ) 
\ --- Delete first link in the list
: DELETELAST ( --  ) 
\ --- Delete last link in the list
: DELETELINK ( --  ) 
\ --- Delete current link and position on next
:M DELETELINK: ( --  ) 
\ --- delete current line
: DISPOSELIST { list \ -- } 
INT FIRSTLINK \ address of first link
:M FIRSTLINK?: ( -- f ) 
:M GETDATA: ( -- addr ) 
:M GETNEXT: ( -- n ) 
:M GETPREV: ( -- n ) 
:M INSERTLINK: ( --  ) 
\ --- Insert link just before current link
:M LASTLINK?: ( -- f ) 
:CLASS LINK 
:CLASS LINK 
:M LINK#: ( -- n ) 
\ --- return # of current link
:CLASS LINKED-LIST 
:CLASS LINKED-LIST 
RECORD: LINKSTUFF 
INT NEXTLINK 
:M NEXTLINK: ( -- n ) 
INT PREVLINK 
:M PREVLINK: ( -- n ) 
:M PURGELIST: ( --  ) 
:M SETDATA: ( addr --  ) 
:M SETNEXT: ( n --  ) 
:M SETPREV: ( n --  ) 
INT TEMPLINK \ temp storage for switching links
INT TEMPNEXT \ 
INT TEMPPREV \ 
:M ~: ( --  ) 
\ --- class destructor
ANEW -LISTBOX.F 
:M ADDSTRING: ( lpszString -- ) 
\ Add a string to a list box. If the list box does not have the LBS_SORT style,
\ the string is added to the end of the list. Otherwise, the string is inserted
\ into the list and the list is sorted.
\ Note: This method ABORT's on error.
:M ADDSTRINGTO: ( z"string" -- ) 
\ Add a string to a list box. If the list box does not have the LBS_SORT style,
\ the string is added to the end of the list. Otherwise, the string is inserted
\ into the list and the list is sorted.
:M ADDSTRINGTO: ( z"string" -- ) 
\ Add a string to the list box of a combo box. If the combo box does not have the
\ CBS_SORT style, the string is added to the end of the list. Otherwise, the string
\ is inserted into the list, and the list is sorted.
:M CLEAR: ( -- ) 
\ Remove all items from the list box.
:M CLEAR: ( -- ) 
\ Remove all strings from the combo box
:CLASS COMBOBOX 
:CLASS COMBOBOX 
:CLASS COMBOLISTBOX 
:CLASS COMBOLISTBOX 
:M DELETESTRING: ( index -- ) 
\ Delete a string.
\  index  specifies the zero-based index of the string to delete.
:M DELETESTRING: ( index -- ) 
\ Delete a string from the list box.
\  index  specifies the zero-based index of the string to be deleted.
\ Windows 95/98: The  index  parameter is limited to 16-bit values. This means list boxes
\ cannot contain more than 32,767 items. Although the number of items is restricted, the total
\ size in bytes of the items in a list box is limited only by available memory.
:M DISABLE: ( -- ) 
\ Disable the control.
:M DISABLE: ( -- ) 
\ Disable the control.
:CLASS DRAGLISTBOX 
:CLASS DRAGLISTBOX 
:M ENABLE: ( f -- ) 
\ Enable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M FIND: ( lpszString -- index ) 
\ Find the first string in the list box that begins with the specified string.
\ The entire list box is searched from the beginning.
\ The search is case independent, so the string ( lpszString ) can contain any combination of
\ uppercase and lowercase letters.
\ The return value is the zero-based index of the matching item, or LB_ERR if the search was unsuccessful.
:M FIND: ( lpszString -- index ) 
\ Search the list for an item beginning with the string (case-insensitive)
:M FINDEXACT: ( lpszString -- index ) 
\ Find the first item that matches the string exactly (case-insensitive)
:M FINDEXACT: ( lpszString -- index ) 
\ Find the first list box string that exactly matches the specified string, except that the search
\ is not case sensitive.
\ The entire list box is searched from the beginning.
\ The return value is the zero-based index of the matching item, or LB_ERR if the search was unsuccessful.
:M GETCOUNT: ( -- n ) 
\ Return count of items in list
:M GETCOUNT: ( -- n ) 
\ Retrieve the number of items in the list box.
:M GETCURRENT: ( -- index ) 
\ Retrieve the index of the currently selected item, if any.
\ The return value is the zero-based index of the currently selected item. If there is no
\ selection, the return value is LB_ERR.
:M GETCURRENT: ( -- index ) 
\ return current selection item
:M GETSELCOUNT: ( -- n ) 
\ Retrieve the total number of selected items in the list box.
:M GETSELECTEDITEMS: ( array cnt -- count ) 
\ Fill a buffer with an array of integers that specify the item numbers of selected
\ items in the list box.
\  array  is a pointer to a buffer large enough for the number of integers specified
\ by the  cnt  parameter.
\  cnt  specifies the maximum number of selected items whose item numbers are to be placed
\ in the buffer. Windows 95/98: The  cnt  parameter is limited to 16-bit values. This means
\ list boxes cannot contain more than 32,767 items. Although the number of items is restricted,
\ the total size in bytes of the items in a list box is limited only by available memory.
:M GETSELECTEDSTRING: ( -- addr cnt ) 
\ Retrieve the currently selected string from the list box.
\ Note: The string is returned in a dynamicly allocated buffer of medium persistance. If a
\ permenant copy is needed it should be moved.
:M GETSELECTEDSTRING: ( -- addr cnt ) 
\ Retrieve the currently selected string from the combo box.
\ Note: The string is returned in a dynamicly allocated buffer of medium persistance. If a
\ permenant copy is needed it should be moved.
:M GETSELECTION: ( -- n ) 
\ Retrieve the index of the currently selected item, if any.
\ The return value is the zero-based index of the currently selected item. If there is no
\ selection, the return value is LB_ERR.
:M GETSELECTION: ( -- n ) 
\ Retrieve the index of the currently selected item, if any.
\ The return value is the zero-based index of the currently selected item. If there is no
\ selection, the return value is CB_ERR.
:M GETSTATE: ( index -- f ) 
\ Retrieve the selection state of an item.
\ If an item is selected, the return value is true; otherwise, it is false.
\ Note: This method ABORT's on error.
:M GETSTRING: ( index -- addr n ) 
\ Retrieve a string from the combo box.
\ The return value is the address and length of the string.
\ If  n  does not specify a valid index, the length is CB_ERR.
:M GETSTRING: ( index -- addr n ) 
\ Retrieve a string from the list box.
\ The return value is the address and length of the string.
\ If  n  does not specify a valid index, the length is LB_ERR.
:M GETSTRINGAT: ( index -- a n ) 
\ Return string of specified item.
\ TODO: Don't use HERE here !!!
:M INSERTSTRING: ( lpszString index -- ) 
\ Insert a string into the list box. Unlike the AddString: method, the InsertString: method
\ does not cause a list with the LBS_SORT style to be sorted.
\ Note: This method ABORT's on error.
\  index  specifies the zero-based index of the position at which to insert
\ the string. If this parameter is -1, the string is added to the end of the list.
\ Windows 95/98: The  index  parameter is limited to 16-bit values. This means list
\ boxes cannot contain more than 32,767 items. Although the number of items is restricted,
\ the total size in bytes of the items in a list box is limited only by available memory.
:M INSERTSTRINGAT: ( lpszString posn -- ) 
\ Insert string at the specified position.
\  posn  specifies the zero-based index of the position at which to insert
\ the string. If this parameter is -1, the string is added to the end of the list.
\  lpszString  is a null-terminated string to be inserted.
:CLASS LISTBOX 
:CLASS LISTBOX 
:CLASS MULTIEXLISTBOX 
:CLASS MULTIEXLISTBOX 
:CLASS MULTILISTBOX 
:CLASS MULTILISTBOX 
:M SELECT: ( index -- ) 
\ Select a string in the list box.
\  index  specifies the zero-based index of the string to set. If this parameter
\ is -1, the selection is added to all strings.
\ Note: This method ABORT's on error.
:M SELECTSTRING: ( lpszString -- index ) 
\ Search the list box for an item that begins with the characters in a specified string.
\ If a matching item is found, the item is selected.
\ The entire list box is searched from the beginning.
\ If the search is successful, the return value is the index of the selected item. If the
\ search is unsuccessful, the return value is LB_ERR and the current selection is not changed.
:M SELECTSTRING: ( lpszString -- index ) 
\ Select item beginning with string
:M SETDIR: ( dirz$ attrib -- ) 
\ Add the names of directories and files that match a specified string and
\ set of file attributes. SetDir: can also add mapped drive letters to the list.
\  attrib  Specifies the attributes of the files or directories to be added to
\ the combo box. This parameter can be one or more of the following values:
\ 
\ DDL_ARCHIVE    | Includes archived files. |
\ DDL_DIRECTORY  | Includes subdirectories, which are enclosed in square brackets ([ ]). |
\ DDL_DRIVES All | mapped drives are added to the list. Drives are listed in the form [-x-], where x is the drive letter. |
\ DDL_EXCLUSIVE  | Includes only files with the specified attributes. By default, read-write files are listed even if DDL_READWRITE is not specified. |
\ DDL_HIDDEN     | Includes hidden files. |
\ DDL_READONLY   | Includes read-only files. |
\ DDL_READWRITE  | Includes read-write files with no additional attributes. This is the default. |
\ DDL_SYSTEM     | Includes system files. |
\  dirz$  specifies an absolute path, relative path, or file name. An absolute path
\ can begin with a drive letter (for example, d:\) or a UNC name (for example, \\machinename\sharename).
\ If the string specifies a file name or directory that has the attributes specified by
\ the wParam parameter, the file name or directory is added to the list. If the file name
\ or directory name contains wildcard characters (? or *), all files or directories that
\ match the wildcard expression and have the attributes specified by the wParam parameter
\ are added to the list displayed in the combo box.
:M SETDIR: ( dirz$ attrib -- ) 
\ Add the names of directories and files that match a specified string and
\ set of file attributes. SetDir: can also add mapped drive letters to the list.
\  attrib  Specifies the attributes of the files or directories to be added to
\ the combo box. This parameter can be one or more of the following values:
\ 
\ DDL_ARCHIVE    | Includes archived files. |
\ DDL_DIRECTORY  | Includes subdirectories, which are enclosed in square brackets ([ ]). |
\ DDL_DRIVES All | mapped drives are added to the list. Drives are listed in the form [-x-], where x is the drive letter. |
\ DDL_EXCLUSIVE  | Includes only files with the specified attributes. By default, read-write files are listed even if DDL_READWRITE is not specified. |
\ DDL_HIDDEN     | Includes hidden files. |
\ DDL_READONLY   | Includes read-only files. |
\ DDL_READWRITE  | Includes read-write files with no additional attributes. This is the default. |
\ DDL_SYSTEM     | Includes system files. |
\  dirz$  specifies an absolute path, relative path, or file name. An absolute path
\ can begin with a drive letter (for example, d:\) or a UNC name (for example, \\machinename\sharename).
\ If the string specifies a file name or directory that has the attributes specified by
\ the wParam parameter, the file name or directory is added to the list. If the file name
\ or directory name contains wildcard characters (? or *), all files or directories that
\ match the wildcard expression and have the attributes specified by the wParam parameter
\ are added to the list displayed in the combo box.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETSELECTION: ( n -- ) 
\ Select a string in the list of a combo box.
:M SETSELECTION: ( n -- ) 
\ Select a string and scroll it into view, if necessary. When the new string is
\ selected, the list box removes the highlight from the previously selected string.
\  n  specifies the zero-based index of the string that is selected. If this parameter
\ is -1, the list box is set to have no selection.
\ Windows 95/98: The  n  parameter is limited to 16-bit values. This means list boxes
\ cannot contain more than 32,767 items. Although the number of items is restricted, the
\ total size in bytes of the items in a list box is limited only by available memory.
:M SETTABSTOPS: ( addr cnt -- ) 
\ Set the tab-stop positions in the list box.
\  cnt  Specifies the number of tab stops in the list box.
\  addr  is a pointer to the first member of an array of integers containing the tab
\ stops. The integers represent the number of quarters of the average character width for
\ the font that is selected into the list box. For example, a tab stop of 4 is placed at
\ 1.0 character units, and a tab stop of 6 is placed at 1.5 average character units. However,
\ if the list box is part of a dialog box, the integers are in dialog template units. The tab
\ stops must be sorted in ascending order; backward tabs are not allowed.
\ The list box must have been created with the LBS_USETABSTOPS style.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
\ We don't want the editcontrol in this control to be subclassed as with
\ super class. It shows the ibeam cursor so we override the start method.
:M UNSELECT: ( index -- ) 
\ Deselect a string in the list box.
\  index  specifies the zero-based index of the string to set. If this parameter
\ is -1, the selection is removed from all strings.
\ Note: This method ABORT's on error.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: LBS_EXTENDEDSEL
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: LBS_EXTENDEDSEL
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: CBS_DROPDOWNLIST
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is: LBS_MULTIPLESEL
ANEW -LISTVIEW.F 
;RECORDSIZE: /LV_COLUMN 
;RECORDSIZE: /LV_DISPINFO 
;RECORDSIZE: /LV_FINDINFO 
;RECORDSIZE: /LV_HITTESTINFO 
;RECORDSIZE: /LV_ITEM 
;RECORDSIZE: /LV_KEYDOWN 
;RECORDSIZE: /NMHDR 
;RECORDSIZE: /NM_LISTVIEW 
;RECORDSIZE: /POINT 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ADDR: ( -- a ) 
:M ARRANGE: ( code -- f ) 
INT CCHTEXTMAX 
INT CCHTEXTMAX 
INT CCHTEXTMAX 
INT CODE 
:M CREATEDRAGIMAGE: ( lpptUpLeft iItem -- hndl|NULL ) 
INT CX 
:M DELETEALLITEMS: ( -- f ) 
:M DELETECOLUMN: ( icol -- f ) 
:M DELETEITEM: ( iitem -- f ) 
:M EDITLABEL: ( iItem -- hndl|NULL ) 
:M ENSUREVISIBLE: ( fPartialOK i -- f ) 
:M FINDITEM: ( plvfi iStart -- index|-1 ) 
INT FLAGS 
INT FLAGS 
INT FLAGS 
INT FMT 
:M GETBKCOLOR: ( -- col ) 
:M GETCALLBACKMASK: ( -- mask ) 
:M GETCCHTEXTMAX: ( -- cchTextMax ) 
:M GETCCHTEXTMAX: ( -- cchTextMax ) 
:M GETCCHTEXTMAX: ( -- cchTextMax ) 
:M GETCODE: ( -- code ) 
:M GETCOLUMN: ( pcol icol -- f ) 
:M GETCOLUMNWIDTH: ( icol -- width|0 ) 
:M GETCOUNTPERPAGE: ( -- n ) 
:M GETCX: ( -- cx ) 
:M GETEDITCONTROL: ( -- ) 
:M GETFLAGS: ( -- flags ) 
:M GETFLAGS: ( -- flags ) 
:M GETFLAGS: ( -- flags ) 
:M GETFMT: ( -- fmt ) 
:M GETHWNDFROM: ( -- hwndFrom ) 
:M GETIDFROM: ( -- idFrom ) 
:M GETIIMAGE: ( -- iImage ) 
:M GETIIMAGE: ( -- iImage ) 
:M GETIITEM: ( -- iItem ) 
:M GETIITEM: ( -- iItem ) 
:M GETIITEM: ( -- iItem  ) 
:M GETIITEM: ( -- iItem ) 
:M GETIMAGELIST: ( iImageList -- hndl|NULL ) 
:M GETISUBITEM: ( -- iSubItem ) 
:M GETISUBITEM: ( -- iSubItem ) 
:M GETISUBITEM: ( -- iSubItem ) 
:M GETISUBITEM: ( -- iSubItem ) 
:M GETITEM: ( ptem -- f ) 
:M GETITEMCOUNT: ( -- n ) 
:M GETITEMPOSITION: ( ppt i -- f ) 
:M GETITEMRECT: ( prc i -- f ) 
:M GETITEMSPACING: ( fsmall -- f ) 
:M GETITEMSTATE: ( mask i -- f ) 
:M GETITEMTEXT: ( pitem iItem -- adr count ) 
:M GETLPARAM: ( -- lParam ) 
:M GETLPARAM: ( -- lparam ) 
:M GETLPARAM: ( -- lParam ) 
:M GETLPARAM: ( -- lParam) 
:M GETMASK: ( -- mask ) 
:M GETMASK: ( -- mask ) 
:M GETMASK: ( -- mask ) 
:M GETNEXTITEM: ( flags iStart -- index|-1 ) 
:M GETORIGIN: ( lpptOrg -- f ) 
:M GETPSZ: ( -- psz ) 
:M GETPSZTEXT: ( -- pszText ) 
:M GETPSZTEXT: ( -- pszText ) 
:M GETPSZTEXT: ( -- pszText ) 
:M GETPT: ( -- x y ) 
:M GETPT: ( -- x y ) 
:M GETPT: ( -- x y ) 
:M GETPT: ( -- x y ) 
:M GETSELECTEDCOUNT: ( -- n ) 
:M GETSTATE: ( -- state ) 
:M GETSTATE: ( -- state ) 
:M GETSTATEMASK: ( -- stateMask ) 
:M GETSTATEMASK: ( -- stateMask ) 
:M GETSTRINGWIDTH: ( psz -- width|0 ) 
:M GETTEXTBKCOLOR: ( -- col ) 
:M GETTEXTCOLOR: ( -- col ) 
:M GETTOPINDEX: ( -- index|0 ) 
:M GETUCHANGED: ( -- uChanged ) 
:M GETUNEWSTATE: ( -- uNewState ) 
:M GETUOLDSTATE: ( -- uOldState ) 
:M GETVIEWRECT: ( prc -- f ) 
:M GETVKDIRECTION: ( -- vkDirection ) 
:M GETWVKEY: ( -- wVKey ) 
:M HITTEST: ( pinfo -- index|-1 ) 
INT HWNDFROM 
INT IDFROM 
INT IIMAGE 
INT IIMAGE 
INT IITEM 
INT IITEM 
INT IITEM 
INT IITEM 
:M INSERTCOLUMN: ( pcol icol -- index|-1 ) 
:M INSERTITEM: ( pitem -- index | -1 ) 
INT ISUBITEM 
INT ISUBITEM 
INT ISUBITEM 
INT ISUBITEM 
:CLASS LISTVIEW 
:CLASS LISTVIEW 
INT LPARAM 
INT LPARAM 
INT LPARAM 
INT LPARAM 
: LVN_GETNOTIFYCHANGED ( addr -- Changed ) 
: LVN_GETNOTIFYITEM ( addr -- Item ) 
: LVN_GETNOTIFYNEWSTATE ( addr -- NewState ) 
: LVN_GETNOTIFYOLDSTATE ( addr -- OldState ) 
: LVN_GETNOTIFYPARAM ( addr -- lParam ) 
: LVN_GETNOTIFYSUBITEM ( addr -- SubItem ) 
:CLASS LV_COLUMN 
:CLASS LV_COLUMN 
:CLASS LV_DISPINFO 
:CLASS LV_DISPINFO 
:CLASS LV_FINDINFO 
:CLASS LV_FINDINFO 
:CLASS LV_HITTESTINFO 
:CLASS LV_HITTESTINFO 
:CLASS LV_ITEM 
:CLASS LV_ITEM 
:CLASS LV_KEYDOWN 
:CLASS LV_KEYDOWN 
INT MASK 
INT MASK 
INT MASK 
:CLASS NMHDR 
:CLASS NMHDR 
:CLASS NM_LISTVIEW 
:CLASS NM_LISTVIEW 
:CLASS POINT 
:CLASS POINT 
INT PSZ 
INT PSZTEXT 
INT PSZTEXT 
INT PSZTEXT 
:M REDRAWITEMS: ( iLast iFirst -- f ) 
:M SCROLL: ( dy dx -- f ) 
:M SETBKCOLOR: ( clrBk -- f ) 
:M SETCALLBACKMASK: ( mask -- f ) 
:M SETCCHTEXTMAX: ( cchTextMax -- ) 
:M SETCCHTEXTMAX: ( cchTextMax -- ) 
:M SETCCHTEXTMAX: ( cchTextMax -- ) 
:M SETCODE: ( code -- ) 
:M SETCOLUMN: ( pcol icol -- f ) 
:M SETCOLUMNWIDTH: ( cx icol -- ) 
:M SETCX: ( cx -- ) 
:M SETEXTENDEDSTYLE: ( fl lvs_ex_style - ) 
:M SETFLAGS: ( flags -- ) 
:M SETFLAGS: ( -- ) 
:M SETFLAGS: ( flags -- ) 
:M SETFMT: ( fmt -- ) 
:M SETHWNDFROM: ( hwndFrom -- ) 
:M SETIDFROM: ( idFrom -- ) 
:M SETIIMAGE: ( iImage -- ) 
:M SETIIMAGE: ( iImage -- ) 
:M SETIITEM: ( iItem -- ) 
:M SETIITEM: ( iItem -- ) 
:M SETIITEM: ( iItem -- ) 
:M SETIITEM: ( iItem -- ) 
:M SETIMAGELIST: ( himl iImageList -- hndl|NULL ) 
:M SETISUBITEM: ( iSubItem -- ) 
:M SETISUBITEM: ( iSubItem -- ) 
:M SETISUBITEM: ( iSubItem -- ) 
:M SETISUBITEM: ( iSubItem -- ) 
:M SETITEM: ( pitem -- index | -1 ) 
:M SETITEMCOUNT: ( cItems -- ) 
:M SETITEMPOSITION32: ( lpptNewPos iItem -- f ) 
:M SETITEMPOSITION: ( x y i -- f ) 
:M SETITEMSTATE: ( pitem i -- f ) 
:M SETITEMTEXT: ( pitem i -- f ) 
:M SETLPARAM: ( lParam-- ) 
:M SETLPARAM: ( lParam -- ) 
:M SETLPARAM: ( lParam -- ) 
:M SETLPARAM: ( lparam -- ) 
:M SETMASK: ( mask -- ) 
:M SETMASK: ( mask -- ) 
:M SETMASK: ( mask -- ) 
:M SETPSZ: ( psz -- ) 
:M SETPSZTEXT: ( pszText -- ) 
:M SETPSZTEXT: ( pszText -- ) 
:M SETPSZTEXT: ( pszText -- ) 
:M SETPT: ( x y -- ) 
:M SETPT: ( x y -- ) 
:M SETPT: ( x y -- ) 
:M SETPT: ( x y -- ) 
:M SETSTATE: ( state -- ) 
:M SETSTATE: ( state -- ) 
:M SETSTATEMASK: ( stateMask -- ) 
:M SETSTATEMASK: ( stateMask -- ) 
:M SETTEXTBKCOLOR: ( clrText -- f ) 
:M SETTEXTCOLOR: ( clrText -- f ) 
:M SETUCHANGED: ( uChanged -- ) 
:M SETUNEWSTATE: ( uNewState -- ) 
:M SETUOLDSTATE: ( uOldState -- ) 
:M SETVKDIRECTION: ( vkDirection -- ) 
:M SETWVKEY: ( -- ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SIZEOF: ( -- n ) 
:M SORTITEMS: ( pfnCompare lParamsort -- f ) 
:M START: ( Parent -- ) 
INT STATE 
INT STATE 
INT STATEMASK 
INT STATEMASK 
INT UCHANGED 
INT UNEWSTATE 
INT UOLDSTATE 
:M UPDATE: ( iItem -- f ) 
INT VKDIRECTION 
INT WVKEY 
INT X 
INT X 
INT X 
INT X 
INT Y 
INT Y 
INT Y 
INT Y 
RECORD: _LV_COLUMN 
RECORD: _LV_DISPINFO 
RECORD: _LV_FINDINFO 
RECORD: _LV_HITTESTINFO 
RECORD: _LV_ITEM 
RECORD: _LV_KEYDOWN 
RECORD: _NMHDR 
RECORD: _NM_LISTVIEW 
RECORD: _POINT 
: (MDICHILDPROC) ( hwnd msg wparam lparam -- res ) 
:M ACTIVATE: ( hWnd -- ) 
\ Activate a MDI child window.
:M ARRANGE: ( -- ) 
\ Arrange all minimized child windows. It does not affect child
\ windows that are not minimized.
:M CASCADE: ( -- ) 
\ Arrange all child windows in a cascade format.
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
RECORD: CLIENTCREATESTRUCT 
:M CLOSEALL: ( -- ) 
\ Close all MDI child windows.
CALLBACK: CLOSEALLCHILDREN { hChild lparam -- f } 
:M CLOSECHILD: ( hWnd -- ) 
\ Close an MDI child window.
:M CREATESTRUCT: ( -- CreateStrucPointer ) 
\ Get the address of CLIENTCREATESTRUCT structure. It contains information about
\ the menu and first multiple document interface (MDI) child window of an MDI
\ client window. An application passes a pointer to this structure as the
\ lpvParam parameter of the CreateWindow function when creating an MDI client window.
: DEFFRAMEPROC ( h m w l -- f ) 
: DEFMDICHILDPROC ( h m w l -- res ) 
:M DESTROY: ( hWnd -- ) 
\ Destroy an MDI child window.
:M DRAWMENUBAR: ( -- ) 
\ Redraws the menu bar of the window. If the menu bar changes after the system
\ has created the window, this function must be called to draw the changed menu bar.
:M ENUMCHILDWINDOWS: ( lparam pCallBack -- f ) 
\ Enumerate the MDI child windows
:M EXWINDOWSTYLE: ( -- exstyle) 
:M EXWINDOWSTYLE: ( -- exstyle ) 
:M GETACTIVE: ( -- Maximized handle ) 
\ Retrieve the handle to the active MDI child window.
:M GETFIRSTCHILD: ( -- hWndChild ) 
\ Get handle of the first child window
:M GETNEXTCHILD: ( -- hWndChild ) 
\ Get handle of the next child window.       
\ NOTE: you must call GetFirstChild: first.
INT HCHILD 
INT HWINDOWMENU 
INT IDFIRSTCHILD 
:M MAXIMIZE: ( hWnd -- ) 
\ M maximize an MDI child window. The system resizes the child window to make its
\ client area fill the client window. The system places the child window's window
\ menu icon in the rightmost position of the frame window's menu bar, and places
\ the child window's restore icon in the leftmost position. The system also appends
\ the title bar text of the child window to that of the frame window.
: MDI-CHILD-CLASS ( -- ) 
\ fill in the defaults for the window class
CALLBACK MDICHILDPROC 
:CLASS MDICHILDWINDOW 
:CLASS MDICHILDWINDOW 
MDICLIENTWINDOW MDICLIENT 
:M MDICLIENT: ( -- handle of MDICLient window ) 
:CLASS MDICLIENTWINDOW 
:CLASS MDICLIENTWINDOW 
:M MDICLIENTWINDOW: ( -- MDICLient window ) 
:CLASS MDIFRAMEWINDOW 
:CLASS MDIFRAMEWINDOW 
:M MDISETMENU: ( hmenuWindow hmenuFrame -- ) 
\ Replace the entire menu of an MDI frame window, replace the window menu
\ of the frame window, or both.
:M NEXT: ( f hWnd -- ) 
\ Activate the next or previous child window.
VALUE NOTCANCELLED \ set to False in child's WM_CLOSE to cancel during CloseAll
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ <a name="MDIClientWindow"></a>
\ MDI client control class
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
:M ON_CHILDACTIVATE: ( -- ) 
\ Handle the WM_CHILDACTIVATE message. This message is sent to a child window
\ when the user clicks the window's title bar or when the window is activated,
\ moved, or sized.
:M ON_CLOSE: ( -- f ) 
\ This method is called when the user chooses to close the MDI child window.
\ If it returns FALSE the window will not be closed.
\ Override the method to check if the document within the child window
\ need's to be saved.
\ The default method returns TRUE, so that the window will be closed.
:M ON_COMMAND: ( h m w l -- h m w l f ) 
\ Handle the WM_COMMAND message. This message is sent when the user selects a command item
\ from a menu, when a control sends a notification message to its parent window, or when an
\ accelerator keystroke is translated.
:M ON_GETMINMAXINFO: ( pMinMaxInfo -- pMinMaxInfo ) 
\ Handle the WM_GETMINMAXINFO message. This message is sent to a window when the size
\ or position of the window is about to change. An application can use this message
\ to override the window's default maximized size and position, or its default minimum
\ or maximum tracking size.
\  pMinMaxInfo  Pointer to a MINMAXINFO structure that contains the default maximized
\ position and dimensions, and the default minimum and maximum tracking sizes. An application
\ can override the defaults by setting the members of this structure.
:M ON_INIT: ( -- ) 
:M ON_MENUCHAR: ( w l -- w l ) 
\ Handle the WM_MENUCHAR message. This message is sent when a menu is active and the user
\ presses a key that does not correspond to any mnemonic or accelerator key. This message
\ is sent to the window that owns the menu.
:M ON_MOVE: ( l -- l ) 
\ Handle the WM_MOVE message. This message is sent after a window has been moved.
:M ON_QUERYEND: ( -- f ) 
\ This method is called when the user chooses to end the session or when an
\ application calls the ExitWindows function. If any application returns zero,
\ the session is not ended.
\ The default method returns TRUE, so that the session will be ended.
:M ON_SYSCOMMAND: ( h m w l -- h m w l f ) 
\ Handle the WM_SYSCOMMAND message. A window receives this message when the user chooses
\ a command from the window menu or when the user chooses the maximize button, minimize
\ button, restore button, or close button.
:M PARENTWINDOW: ( -- hParent ) 
\ Teturn the handle of parent, 0 = no parent
:M POSTMESSAGETOALLCHILDREN: { wParam lParam msg -- } 
\ Post a message to all child windows
:M REFRESHMENU: ( -- ) 
\ Refresh the window menu of the MDI frame window.
:M RESTORE: ( hWnd -- ) 
\ Restore an MDI child window from maximized or minimized size.
: SENDMDIMESSAGE ( l w message -- result ) 
: SENDMDIMESSAGEDROP ( lParam wParam message -- ) 
:M SENDMESSAGETOALLCHILDREN: { wParam lParam msg -- } 
\ Send a message to all child windows
:M SETREDRAW: ( f -- ) 
\ Set the redraw state of the window.
\  f  Specifies the redraw state. If this parameter is TRUE, the
\ content can be redrawn after a change. If this parameter is FALSE,
\ the content cannot be redrawn after a change.
:M START: ( hWindowMenu Parent -- ) 
\ Start the control.
:M START: ( Parent -- ) 
\ Create a new MDI child window object
:M STARTPOS: ( -- x y ) 
:M STARTSIZE: ( -- w h ) 
:M TILE: ( f -- ) 
\ Arrange all child windows in a tile format.
\  f  can be one of the following values optionally combined with
\ MDITILE_SKIPDISABLED to prevent disabled MDI child windows from being
\ tiled.
\ 
\ MDITILE_HORIZONTAL | Tiles windows horizontally. |
\ MDITILE_VERTICAL | Tiles windows vertically. |
:M WINDOWHASMENU: ( -- f ) 
:M WINDOWHASMENU: ( -- f ) 
:M WINDOWMENUNO: ( -- n ) 
\ Override this method to set the menu number in whitch all
\ child windows should be displayed.
:M WINDOWSTYLE: ( -- style ) 
:M WINDOWSTYLE: ( -- style ) 
:M WINDOWTITLE: ( -- z" ) 
\ Get the title text for the frame window.
:M WINDOWTITLE: ( -- z" ) 
\ Get the title text for the MDI child window.
:M WM_CHILDACTIVATE ( h m w l -- f ) 
:M WM_CLOSE ( h m w l -- f ) 
:M WM_COMMAND ( h m w l -- f ) 
:M WM_COMMAND ( h m w l -- f ) 
:M WM_GETMINMAXINFO ( h m w l -- f ) 
:M WM_MENUCHAR ( h m w l -- f ) 
:M WM_MENUCHAR ( h m w l -- f ) 
:M WM_MOVE ( h m w l -- f ) 
:M WM_NCACTIVATE ( h m w l -- f ) 
:M WM_QUERYENDSESSION ( h m w l -- f ) 
:M WM_SETFOCUS ( h m w l -- f ) 
:M WM_SETFOCUS ( h m w l -- f ) 
:M WM_SIZE ( h m w l -- f ) 
:M WM_SYSCOMMAND ( h m w l -- f ) 
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:CLASS MDIDIALOGWINDOW 
:CLASS MDIDIALOGWINDOW 
:M ~: ( -- ) 
\ Destructor method called when a dynamic object is freed by DISPOSE.
: #SELECTED ( -- n ) 
:M #SELECTEDFILES: ( -- n ) 
ANEW -MULTIOPEN.F 
CONSTANT /SZFILE \ Was 2048
:M CLASSINIT: ( -- ) 
INT FCNT \ number of selected files
INT FILTERNDX 
:M GETDIR: ( -- a1 n1 ) 
\ get the current dialog directory string
:M GETFILE: { ndx -- addr cnt } 
\ ndx = 0 to fcnt-1
:M GETFILTER: ( -- a1 n1 ) 
\ return current file filter string
: MFDLG-BUILD ( filename diraddr titleaddr specaddr owner -- ) 
: MFDLG-CALL ( -- filename ) 
\ call GetxxxxFileName
: MOPEN-DIALOG ( filterndx filename diraddr titleaddr specaddr owner -- filename ) 
:CLASS MULTIFILEOPENDIALOG 
:CLASS MULTIFILEOPENDIALOG 
: RUN-DIALOG ( owner_handle dialog-func-cfa -- a1 ) 
:M SETDIR: ( a1 n1 -- ) 
\ set the dialog directory string
:M SETFILTER: ( a1 n1 -- ) 
\ set new file filter spec
:M SETFILTERINDEX: ( n -- ) 
:M SETTITLE: ( a1 n1 -- ) 
:M START: ( owner_handle -- a1 ) 
BYTES SZDIR 
BYTES SZFILE 
INT SZFILTER 
INT SZTITLE 
:M #ACTIVETHREADS: { \ lpExitCode } 
( - #ActiveThreads ) 
\ Returns the number active threads in the object.
: #DO \ Compiletime: ( <name> -- )  Runtime: ( limit start - )
\ To construct:     do  i  cfa   loop 
\ EG: 
\ : test  10 0   #do . ; 
\ Will be compiled as: 
\ : TEST  10 0    DO  I . LOOP    ; 
: #HARDWARE-THREADS ( - #Hardware-threads ) 
\  Returns the number of hardware threads found in the CPU.
( sizeof system_info) 
:M #INCOMPLETEJOBS1THREAD: ( index -- #jobs ) 
\ Returns the number of incomplete jobs of one 1 thread given its ID.
:M #INCOMPLETEJOBS: ( -- #Totaljobs ) 
\ Returns the total number of incomplete jobs in the object.
VALUE #JOBPARMS 
INT #JOBS \ Number of entries in the JobBlock
:M #JOBSSUBMITTED: ( -- #TotalSubmittedjobs ) 
\ Returns the total number of submitted jobs in the object.
INT #THREADS \ The maximum number of threads in use in the object.
INT &JOBBLOCK \ Start of the JobBlock when it has been allocated
INT &THREADBLOCKS \ The taskblock array.
BYTES &TMPSTK \ A tmp stack to pass parameters to a range
\ Each range will get the same stack
INT 'CALLBACK \ callback function for QueueUserAPC (PAPCFUNC)
: *CANCELED* ( ?? - ) 
\ Resets the stack. *Canceled* is used for reporting.
: .AVERAGETIME ( F: AverageTime ActTime - ) 
\ Calculates and displays the relative difference between the average time and actual time of a job.
: .DIFCYCLES ( startL startH endL endH - ) 
\ Calculates and displays the difference between a start time and end time in cycles.
: .ELAPSEDJOB ( start-time-buf end-time-buf -- ) 
\ Displays the time that has been elapsed betweeen 2 time buffers
:M .JOBANALYSIS: ( -- ) 
\ Displays a Job analysis of an object that include elapsed times status and the name of the executed CFA.
\ Note: Job entries can be recycled!
:M .JOBBLOCK: ( -- ) 
\ Produces a primitive dump of a jobblock.
: .JOBSTATUS ( &JobEntry - ) 
\ Displays the jobstatus of a job given its &JobEntry address.
:M .QUEFULL: ( -- ) 
\ Displays the count of QueFull.
: .RANGE ( IDindex - ) 
\ Show the assigned range of a job using the entry index of the job.
:M .RANGES: \ Show the ranges of the jobs used by the object.
\ Note: Job entries can be overwritten when they are complete.
:M .THREADBLOCK: ( - ) 
\ Displays the number of submitted jobs and the number of completed jobs for each thread of an object.
: .TIMESTAMP ( &entry - ) 
\ Displays the time when a job was started.
VALUE /JOBENTRY \ The size of 1 Job entry
CONSTANT /STKPARAMS \ The maximum number of parameters to pass to a job
\ Parameters for 1 job entry in a jobblock:
\ 
\ Name:        | Use: |
\  --| -- Note: Parameters starting wih a '>' use the &JobEntry address to get to their adress. |
\ &JobEntry    | -- The start adress of one job entry.|
\ >JobCFA      | -- Contains the CFA to be executed by a job.|
\ >JobStkDepth | -- The number of stack items for a job.|
\ >JobStkLast  | -- A stack for a job to be executed.|
\ >StartTic    | -- A double containing the StartTic when a job was started.|
\ >EndTic      | -- A double containing the >EndTic when a job became complete.|
\ >CfaDone     | -- Contains the previous Cfa of a job entry.|
\ >StartTime   | -- A structrure containing the StartTime when a job was started.|
\ >EndTime     | -- A structrure containing the EndTime when a job became complete.|
\ >Schedule    | -- Reserved to hold a Schedule.|
\ >range       | -- 2 cells to hold the start- end-index for a do...loop. used by the class iTasks.|
\ /StkParams   | -- The maximum number of parameters to pass to a job. Default is 8.|
\ /JobEntry    | -- The size of 1 Job entry.|
\ MinimumSizeJobBlock | -- Minimum size of one job entry.|
\ #JobParms    | -- Number of parameters in one job entry.|
\ /TimeParams  | -- Partial size of job entry to be used to erase statistics.|
INT /THREADBLOCK \ The size of one Thread-block.
CONSTANT /TIMEPARAMS 
: 5.R ( n - ) 
\ Display n right justified using 5 positions followed by a space.
FIELD+ >CFADONE ( &JobEntry - >CfaDone ) 
FIELD+ >ENDTIC ( &JobEntry - >EndTic ) 
FIELD+ >ENDTIME ( &JobEntry - >EndTime ) 
: >JOBCFA 
:M >JOBENTRY: ( index - adr ) 
\ Returns the address of a jobentry given its index.
OFFSET >JOBSTKLAST \ After which the stack follows
FIELD+ >RANGE ( &JobEntry - >range ) 
\ For iTasks
FIELD+ >SCHEDULE ( &JobEntry - >Schedule ) 
FIELD+ >STARTTIC ( &JobEntry - >StartTic ) 
FIELD+ >STARTTIME ( &JobEntry - >StartTime ) 
: ALERTABLESTATE ( - ) 
\ Puts a thread in a alertable state. So it can receive and handle submitted jobs (APC's).
:M ANALYZE: \ Starts the analyzer for .JobAnalysis:
:M ANALYZEROFF: ( -- ) 
\ Puts the analyzer for .JobAnalysis: off. This is default. This will be a bit faster.
: AVERAGEELAPSED \ : ( -- F:AverageInCycles )
\ Calculates the average time In cycles of all jobs in an object.
: BELOW ( -- ) 
\ Lowers the priority of the thread in order to keep the main thread responsive to the mouse etc.
: CANCELWAITINGJOB ( index - ) 
\ Cancel the entry of a job. When a job is running it will continue.
:M CANCELWAITINGJOBS: ( -- ) 
\ Cancel waiting and pending jobs of the object.
\ Running Jobs will continue
\ This might give confusing results a job analysis.
CODE CELLS+! ( n a1 n1 -- ) 
\ Multiply n1 by the cell size and add the result to address a1
\ then store the value n to that address.
CODE CELLS+@ ( a1 n1 -- n ) 
\ 
\ Multiply n1 by the cell size and add the result to address a1
\ then fetch the value from that address.
: CHECKTASBOBJECT ( - ) 
\ To check if a TasbObject has been started.
:M CLASSINIT: ( -- ) 
\ Initializes the object. Happens automaticly when Forth or a turnkey starts.
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLOSESEMAPHORE: \ Closes the semaphore.
:M CLOSESEMAPHORES: ( -- ) 
\ Close the semaphores on use by the object.
: CREATERUNTHREAD ( IDindex -- ) 
\ Creates and runs the thread for windows given the ID and use the parameters of a filled entry in the threadblock.
:M CREATESEMAPHORE: ( lpName lMaximumCount lInitialCount lpSemaphoreAttributes --  ) 
\ Creates a semaphore. Parameters:
\ lpSemaphoreAttributes: Pointer to security attributes can be NULL.
\ lInitialCount: Specifies an initial count for the semaphore object.
\ This value must be greater than or equal to zero and less than.
\ lMaximumCount: Maximum count 
\ lpName: Pointer to a null-terminated string specifying the name of the semaphore object.
\ Can be NULL.
:M DECREASEWAIT: ( ms -- ) 
\ DECREASES the count of the semaphore by one.
:M ERASESTATS: ( -- ) 
\ Erase statistics fome the thread block and Job block of an object.
:CLASS EXCLEXECUTE 
:CLASS EXCLEXECUTE 
CALLBACK: EXECUTEANALIZEJOB { \ #bytes } 
( JobEntry -- res ) 
\ Also defines &ExecuteAnalizeJob
\ Callback fuction for all jobs that are submitted and need to be analyzed.
: EXECUTEINTHREAD ( -- ) 
\ Will run first in any thread.
CALLBACK: EXECUTEJOB { \ #bytes } 
( JobEntry -- res ) 
\ Also defines &ExecuteJob
\ Callback fuction for all jobs that are submitted and need no analyzing.
INT EXECUTING? \ Is true when executing
INT FASTJOBS \ If true the elapsed times are diplayed in cycles
FVALUE FAVERAGE 
:M FINDTHREAD: { \ cand least } 
( -- i ) 
\ Finds a thread to be used for a job.   
\ This is done by looking for a waiting thread.  
\ When there is no thread waiting the thread with the least jobs is returned.
\ Some threads are not as often used as others, since it is faster to find a waiting thread.
INT FOUNDJOBID \ Keeps the last found free jobID
:M GET#JOBS: ( -- n ) 
\ Get the maximum number of jobs.
:M GETFREEJOBID: ( -- Index|-1 ) 
\ Return an index for a free JobEntry or -1 when it fails.
\ The result is also stored in FoundJobId.
:M GETHANDLE: ( -- hndl ) 
:M GETLOCKEDJOBID: ( -- n ) 
\ Retuns the JobID that is locked
:M GETQUEFULL: ( -- n ) 
\ Returns the number of times that all job entries are used.
:M GETRANGE: ( -- High Low ) 
\ Returns the range to be used before a do...loop of the running job.
: GETTHREADBLOCK ( IDindex - ThreadBlock ) 
\ Returns the address of the threadblock array for its index.
:M GETTHREADBLOCKSIZE: ( - Size ) 
\ Returns the threadblock size.
:M GETTHREADCOUNT: ( -- #threads ) 
\ Returns the maximum number of simultaneously threads in use.
: GETTHREADINDEX ( - IDindex ) 
\ Each thread gets an index. GetThreadIndex returns that index.
\ GetThreadIndex in a job can be used to target a value in an array
\ for one thread.
: GETVALUESPMAINTHREAD ( - UpMainThread ) 
\ Get sp0 of the main thread. Even when a secondary thread is running.
INT HNDLSEMAPHORE 
:M INCREASE: { \ lpPreviousCount -- } 
( -- PreviousCount ) 
\ Releases the semaphore by one.
:CLASS ITASKS 
:CLASS ITASKS 
NEWUSER JOBENTRYID \ Index pointer to the job entry that is executing in a thread
: JOBENTRYID> ( JobEntryAdr - Index ) 
\ Returns the index of a JobEntry given its address.
VALUE JOBSCOUNTED 
INT LASTUSEDJOBID \ Used to find a next free jobID.
INT LASTUSEDTHREADID \ Used to a next free thread.
:M LOCKEXECUTE: ( cfa - ) 
\ Locks, executes and unlocks the specified cfa.
\ When more than 1 job try to use LockExecute: at nearly the same time of the same object
\ the second job will be executed after the previous job is ready.
:M LOCKJOBENTRY[: ( - ) 
\ Locks a job entry so it can receive parameters.
: MAINTHREAD? ( - flag ) 
\ Detects if a definition is running in the main thread.
\ MainThread? returns true when a definition runs in the main thread.
: MALLOCJOBBLOCK ( -- ) 
\ Allocate the needed arrays.
:M MALLOCTHREADARRAYS: ( -- ) 
\ Allocates and initializes the ThreadBlock and JobBlock.
:M MAX#THREADS: ( -- #threads ) 
\ Returns the number of hardware threads. 
\ It returns 2 for older cpu's.
CONSTANT MAXCOUNTSEMAPHORE \ The maximum count of a Semaphore
\ Semaphore class
CONSTANT MINIMUMSIZEJOBBLOCK \ Minimum size of one entry in the &JobBlock
CONSTANT MINIMUMSIZETHREADBLOCK \  Minimum size of a thread block
: MS@TB ( time-buf -- ms ) 
\ Returns the content of a timebuffer into milli-seconds on the stack.
ANEW MULTITASKINGCLASS.F \ For XP or better. See the demos at the end for its use.
\ doc\classes\
\ MultiTaskingClass
\ MultiTaskingClass -- For clustered tasks in objects.
\ Abstract
\ CPU's with multiple cores can execute a program faster than cpu's with a single core. 
\ This is done by breaking up a program in smaller pieces and than execute all pieces simultaneously. 
\ In multiTaskingClass.f this idea is supported as follows: 
\ Breaking up is possible at the definition level or at the program level by the 2 classes iTask and wTask. 
\ Then the pieces are submitted and simultaneously executed in a number of tasks. 
\ Tasks are coverted to jobs and clustered in an object for easy access.
\ Objects defined with iTask can be used as soon as ONE definition should be executed in a parallel way
\ and the definition uses a do...loop. 
\ The method Parallel:  divides, distributes and submits for execution the specified cfa over a number of jobs. 
\ A started job can pickup its range for the do...loop part by using the method GetRange:. 
\ It is possible to change the number of simultaneous jobs before they run.
\ Objects defined with wTask can be used to execute concurrently one or more different definitions. 
\ Use the method Submit: for executing a definition in a job. 
\ When a new job is submitted and the maximum number of jobs has been reached the following will happen at the next job: 
\ 1) The system will wait till all the jobs in one que of one thread are complete. 
\ 2) Then it will allow the submitting more jobs. 
\ Tasks of both classes will get their parameters at the start on the stack
\ as soon as the method ToStack: is used just before the job is submitted. 
\ MultiTaskingClass.f uses the preemptive multitasking system of windows. No need to use pause. 
\ Typical passing of parameters to a Job: 
\ LockJobEntry[: myTasks 10 20 30 3 ToStack: myTasks  ['] TestTask ]Submit: myTasks 
\ Explanation:
\  LockJobEntry[: Locks the entrypoint to protect it against overwriting.
\  ToStack: Passes the 3 stack items to the stack of the job.
\  ]Submit: Submits the task and unlocks the entrypoint just before it returns.
\ History:
\ To handle tasks in an object.
\ 16-07-2011 Released the first version. In the old version each task started a new thread
\ When a task was complete the thread was terminated
\ For waiting was a complex WaitForMultipleObjects used.
\ The number of threads was limited to 63.
\ 1-5-2014 Most important changes:
\ Now each thread gets a que in which jobs are placed to execute a definition.
\ Submitting a job is now about 1000 times faster than the initial version.
\ The total number of jobs depends on #jobs in each used object.
\ Semaphores are used to simplify waiting instead of critical sections.
\ The number of threads is no longer limited to 63.
\ 1500 threads seems to be the limit under W7.
\ All objects need now to be started with the method start: which takes NO parameters from the stack.
\ Exceptions with #IncompleteJobs1Thread: etc happens when an object has not been started.
\ All task-classes have now high resolution timers to determine elapsed times in cycles or seconds.
\ Use .JobAnalysis: to see them.
\ Important renamed methods:
\ old                  ->  new:
\ To&Task:             ->  ToStack:
\ SubmitTask:          ->  Submit:
\ GetTaskRange:        ->  GetRange:
\ GetTaskParam         ->  GetThreadIndex
\ Objectname.taskwaits ->  #IncompleteJobs:
\ SuspendTasks:        ->  SuspendThreads:
\ ResumeTasks:         ->  ResumeThreads:
\ REMOVED &StkParams Waitobject
\ 22-10-2015 Most important change:
\ Now SubmitRanges: gives a better distribution.
\ That may often result in a faster program.
\ Thanks to Herbert.
INT ONLYONETHREAD \ A flag used to force to use 1 thread only for testing
: OPENSEMAPHORE ( dwDesiredAccess bInheritHandle lpName -- hdnl ) 
\ Returns a handle of an existing named semaphore object.
:M PARALLEL: ( limit IndexLow cfa -- ) 
\ 1
\ Nearly the same as ]Parallel:. Parallel: also uses a lock to prevent nesting while still busy.
\ To be used when no other parameters are passed other than limit IndexLow cfa
:M PREPAIRTHREAD: ( cfa IDindex -- ) 
\ Prepairs a threadblock with various parameters.
:M PUTRANGE: ( High Low IDindex -- ) 
\ Saves the range of a job.
INT QUEFULL \ Increments when the que is full.
:M READY?: ( -- flag ) 
\ Returns true when all jobs are ready.
:M READY?: ( -- Flag ) 
\ Returns true when LockExecute: is ready.
:M RELEASEARRAYS: ( -- ) 
\ Release the allocated arrays.
:M RELEASESEMAPHORE: ( lpPreviousCount lReleaseCount -- PreviousCount ) 
\ Increases the count of the specified semaphore.
\ Parameters:
\ lReleaseCount: Specifies the amount by which the semaphore object's current count is to be INCREASED.
\ The value must be greater than zero. If the specified amount would cause the semaphore's
\ count to exceed the maximum count that was specified when the semaphore was created,
\ the count is not changed and the function returns FALSE.
\ lpPreviousCount: Pointer to receive the previous count for the semaphore.
\ Can be NULL if the previous count is not required
: RESETJOB-THREADID ( - ) 
\ Set LastUsedJobId and LastUsedThreadId to -1 to reset various ID's
:M RESETQUEFULL: ( -- ) 
\ Set the count of QueFull to 0.
:M RESUMETHREAD: ( IDindex -- ) 
\ Resumes the thread with the specified ID.
:M RESUMETHREADS: ( -- ) 
\ Resume all threads in use in the object by the object.
:CLASS SEMAPHORE 
:CLASS SEMAPHORE 
SEMAPHORE SEMAPHOREALLJOBSREADY \ To detect that all jobs of ONE thread are ready.
SEMAPHORE SEMAPHOREENTRYPOINT \ A Semaphore used to lock or unlock an entry point.
\ That will protect definitions that are not able to be executed simultanously
\ It will also protect data against overwriting by another thread while a previous thread still needs that data.
: SERIALIZE ( -- ) 
:M SET#JOBS: ( n -- ) 
\ Specify the maximum number of jobs. Set it before starting the object when needed.
:M SETPARALLELITEMS: ( cfa limit IndexLow #threads - ) 
\ 2
\ Initilizes the ranges and submits them.
: SETPRIORITY ( Prio - ) 
\ Changes the priority of the thread.
:M SETTHREADBLOCKSIZE: ( NewSize - ) 
\ Sets a new size for the thread block.
:M SETTHREADCOUNT: ( #threads -- ) 
\ Sets the maximum number of simultaneously threads in use.
: SETVALUESPMAINTHREAD ( - ) 
\ Sets the sp0 value of the main thread. This is done at the start of Forth or at the start
\ of a turnkey
: SIGNALOBJECTANDWAIT ( bAlertable  dwMilliseconds hObjectToWaitOn hObjectToSignal -- res ) 
\ Allows the caller to atomically signal an object and wait on another object.
:M SINGLE: ( cfa -- ) 
\ Locks and execute the specified cfa and return after that job is submitted.
\ To be used when a CFA needs no parameters.
:M SINGLE: ( limit IndexLow cfa -- ) 
\ Executes the definition of the specified cfa in the main thread.
\ The executed definition can get its range by using GetRange:.
\ Made for debugging while running in the MainThread.
VALUE STACKSIZE 
:M START: ( -- ) 
\ Used to initialize the object.
:M START: ( -- ) 
\ Used to initialize the object. Must be used before jobs can be submitted
:M STARTQUEUE: ( cfa IDindex -- ) 
\ Submits the specified cfa in a new thread and returns.
:M STARTQUEUES: \ Start all queues and threads in an object.
\ All started threads will get in an alertable state and will
\ be ready to receive APC's that use an entry a JobBlock of an object.
:CLASS STASK 
:CLASS STASK 
:M STOPANALYZING: \ Stops the analyzer.
:M SUBMIT: ( cfa -- ) 
\ Locks and Submits the specified cfa to a new job and return after that job is submitted.
\ To be used when a job needs no parameters.
:M SUBMITRANGE: { High low cfa  -- } 
\ Submits the specified cfa in a new job and return after that job is submitted.
\ Range and parameters from ToStack: are also passed to the job.
:M SUBMITRANGES: { cfa High low _#threads -- } 
\ 3
\ Distributes and submits all the ranges to various jobs.
:M SUSPENDTHREAD: ( IDindex -- ) 
\ Suspend a thread with the specified ID.
:M SUSPENDTHREADS: ( -- ) 
\ Suspend all threads in use by the object.
:CLASS TASKPRIMITIVES 
:CLASS TASKPRIMITIVES 
FIELD+ TCB>#JOBSDONE \ Returns the address of the number of complete jobs in the thread.
OFFSET TCB>#JOBSSUBMITTED 
: TCB>CFA ( tcb - tcb>cfa ) 
\ Returns the address of the CFA to be executed from the threadblock.
FIELD+ TCB>OP \ Returns the address of the object pointer in the thread.
SYNONYM TCB>STOP task>stop \ The difference is that it is extended with 4 new parameteres as follows:
SYNONYM TCB>STOP task>stop \ The difference is that it is extended with 4 new parameteres as follows:
FIELD+ TCB>USERAREA \ Returns the address of the user area of the thread.
:M TERMINATEALLJOBS: ( -- ) 
\ Closes all semaphores and terminate all jobs and threads of one object.
\ All waiting jobs will be gone.
\ Use Start: to restart mulitasking again.
:M TERMINATETHREAD: ( IDindex -- ) 
\ To terminate a thread with the specified ID. 
\ This will also terminate all running jobs of the thread.
:M TERMINATETHREADS: ( IDindex -- ) 
\ Terminates all threads in use in the object by the object.
\ This will also terminate all running jobs in the object.
: THREADINDEX ( - #threads 0 ) 
\ Returns 0 and the maximum number of simultaneously threads in use by the object.
:M TIMECYCLES: ( -- ) 
\ Displays the time in cycles in .JobAnalysis:.
:M TIMESECONDS: ( -- ) 
\ Displays the time in seconds in .JobAnalysis:.
:M TOSTACK: ( ni...n0  n --  ) 
:M TOSTACK: ( ni...n0  n --  ) 
\ To pass n (maximal 8) parameters to the stack of a job.
BYTES TOTALRANGE \ 2 cells containing the total of all ranges in the object. |
:M USEALLTHREADS: ( -- ) 
\ To overwrite UseOneThreadOnly:. This is default.
:M USEONETHREADONLY: ( -- ) 
\ Overwrite the number of simultaneously threads in use by the object.
\ Use it before submitting a job.
VALUE VALUESPMAINTHREAD \ Only to be used to see if a word is running in the mainthread
:M WAITFORALL: ( - ) 
\ Wait till LockExecute and all Jobs in the object are complete.
\ The definition AlertableState will increase the semaphore when ready.
:M WAITFORFREEJOBENTRY: ( - addr ) 
\ Waits for a free job entry. When found it will return the addres of the found entry.
:CLASS WTASKS 
:CLASS WTASKS 
:M ]PARALLEL: \ { limit IndexLow cfa -- }   \ 1
\ Submits the specified cfa in a number of jobs. 
\ Use LockJobEntry[: to lock the entrypoint.
\ The number of jobs depend on the number of hardware threads and
\ the specified range in limit and IndexLow. 
\ Parallel: returns when all the jobs in the object are complete. 
\ Each job can get its range by using GetRange:.
\ Each range can be passed to a do..loop or #do 
\ The debugger can not be used in a job. 
\ See Single: for debugging.
:M ]SINGLE: ( cfa -- ) 
\ Executes the definition of the specified cfa in the main task.
\ Made for debugging while running in the MainThread.
:M ]SUBMIT: ( cfa -- ) 
\ Submits the specified cfa to a locked JobEntry and return after that job is submitted.
ANEW -PDFCONTROL.F 
:M ABOUTBOX: ( -- ) 
:M GOBACK: ( -- ) 
:M GOFORWARD: ( -- ) 
:M GOTOFIRSTPAGE: ( -- ) 
:M GOTOLASTPAGE: ( -- ) 
:M GOTONEXTPAGE: ( -- ) 
:M GOTOPREVIOUSPAGE: ( -- ) 
:M LOADFILE: ( str len -- flag ) 
\ flag is true on error
:M ON_DONE: ( -- ) 
BYTES PDF \ pointer to Dispatch Interface
:CLASS PDFCONTROL 
:CLASS PDFCONTROL 
:M PRINT: ( -- ) 
:M PRINTALL: ( -- ) 
:M PRINTALLFIT: ( bool -- ) 
:M PRINTPAGES: ( n n -- ) 
:M PRINTPAGESFIT: ( flag n n -- ) 
:M PRINTWITHDIALOG: ( -- ) 
:M SETLAYOUTMODE: ( str len -- ) 
:M SETNAMEDDEST: ( str len -- ) 
:M SETPAGE: ( n -- ) 
:M SETPAGEMODE: ( str len -- ) 
:M SETSHOWSCROLLBARS: ( flag -- ) 
:M SETSHOWTOOLBAR: ( flag -- ) 
:M SETVIEWRECT: ( float float float float -- ) 
:M SETZOOM: ( float -- ) 
\ 100e0 is 100%
:M SETZOOMSCROLL: ( float float float -- ) 
:M START: ( Parent -- ) 
BYTES XTRA \ xtra space for api calls
:M +VALUE: ( n -- ) 
\ Advances the current position of the progress bar by a specified increment
\ and redraws the bar to reflect the new position.
ANEW -PROGRESSBAR.F 
:M GETSTEP: ( -- n ) 
\ Returns the current step increment for the progress bar.
:M GETVALUE: ( -- n ) 
\ Returns the current position of the progress bar.
:CLASS PROGRESSBAR 
:CLASS PROGRESSBAR 
:M SETRANGE: ( min max -- ) 
\ Sets the minimum and maximum values for the progress bar and redraws the
\ bar to reflect the new range.
\  min  is the minimum range value. By default, the minimum value is zero.
\  max  is the maximum range value. By default, the maximum value is 100.
: SETSTEP ( n -- n1 ) 
:M SETSTEP: ( n -- ) 
\ Specifies the step increment for the progress bar. The step increment is
\ the amount by which the progress bar increases its current position whenever
\ the StepIt: method is used. By default, the step increment is set to 10.
:M SETVALUE: ( n -- ) 
\ Sets the current position for the progress bar and redraws the bar to
\ reflect the new position.
:CLASS SMOOTHPROGRESSBAR 
:CLASS SMOOTHPROGRESSBAR 
:M START: ( Parent -- ) 
\ Create the control.
:M STEPIT: ( -- ) 
\ Advances the current position for the progress bar by the step increment
\ and redraws the bar to reflect the new position.
\ When the position exceeds the maximum range value, this method resets the current
\ position so that the progress indicator starts over again from the beginning.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: PBS_SMOOTH.
:M AUTOSIZE: ( -- ) 
INT BFMASK 
INT BINFOSIZE 
INT CCH 
:M CLASSINIT: ( -- ) 
INT CLRBACK 
INT CLRFORE 
INT CX 
INT CXHEADER 
INT CXIDEAL 
INT CXMINCHILD 
INT CYCHILD 
INT CYINTEGRAL 
INT CYMAXCHILD 
INT CYMINCHILD 
:M DELETEBAND: ( uBand -- ) 
:M ENDDRAG: ( -- ) 
: ERASEBAND-INFO ( -- ) 
:M EXWINDOWSTYLE: ( -- style ) 
INT FLAGS 
INT FSTYLE 
:M GETBARHEIGHT: ( -- h ) 
INT HBMBACK 
:M HEIGHT: ( -- h ) 
:M HITTEST: ( -- uBand ) 
INT HWNDCHILD 
INT IB 
:M IDTOINDEX: ( uBandID -- uBand ) 
INT IIMAGE 
:M INSERTBAND: ( -- ) 
:M INSERTBANDAT: ( uBand -- ) 
INT LPARAM 
INT LPTEXT 
:M MAXIMIZEBAND: ( fIdeal uBand -- ) 
:M MINIMIZEBAND: ( uBand -- ) 
RECORD: RBHITTESTINFO 
RECORD: REBARBANDINFO 
:CLASS REBARCONTROL 
:CLASS REBARCONTROL 
:M SETBARINFO: ( himl fmask -- ) 
:M SHOWBAND: ( f uBand -- ) 
;RECORDSIZE: SIZEOF(REBARBANDINFO) 
:M START: ( Parent -- ) 
INT WID 
:M WINDOWSTYLE: ( -- style ) 
INT X 
INT Y 
INT ALLOCATEDFILES \ Maximum number of recent files allocated for
:M CLASSINIT: ( n -- ) 
\ allot n menu IDs to recent files
:M DOMENU: { ID \ Text$ -- } 
INT FIRSTPOS \ Pos of first recent file on file menu
:M GETRECENTFILE: { Index -- FileName$ } 
INT ID 
:M INSERT: { FileName$  \ MenuText$ Text$ -- } 
:M LOADMENU: ( pid parent -- ) 
\ don't add anything to menu
INT MAXFILES \ Largest number of recent files saved on file menu
INT MFUNC \ the menu function
INT NUMBEROFFILES \ Menu separator is removed if no recent files
INT POS 
:CLASS RECENTFILES 
:CLASS RECENTFILES 
:M RESET: { \ Text$ -- } 
\ Numbers recent files and deletes any more than allowed
:M SETNUMBER: ( n -- ) 
: WITHOUTFILENUMBER ( text$ -- text$ ) 
: ADDRESS ( -- a ) 
VALUE CURRENTREGENTRY \ index of registry entry in registry table
VALUE CURRENTSET \ address of data in current registry entries set
: DEFAULTADDRESS ( -- a ) 
: DEFAULTLENGTH ( -- n ) 
: DEFAULTSETTINGS ( -- ) 
: DELETEKEY ( -- ) 
\ deletes key HKEY_CURRENT_USER\Software\<progreg>
: ENDENTRIES ( -- ) 
: ENTRIES ( -- ) 
: GETREGISTRYVALUE ( a1 n1 RegType -- a2 n2 ) 
\ a1,n1=key string, a2,n2=value string
: LENGTH ( -- n ) 
VALUE MAXLENGTH \ the maximum length of a ValueName incl null (clipped if longer)
\ 50 makes a reg entry 64 bytes long ( 50 + count + 13 )
VALUE REGENTRIES \ number of registry entries in current set
: REGENTRY ( Address a [n]  Default a [n]  RegistryType n  <"RegValueName"> -- ) 
: REGISTRYSET ( a n <name> -- ) 
\ creates a new named registry entries set
VALUE REGISTRYTABLE \ address of current registry table in dictionary
: REGISTRYTABLEENTRY ( n -- a ) 
: REGISTRYTYPE ( -- n ) 
: RESTORESETTINGS ( -- ) 
: SAVESETTINGS ( -- ) 
: SETCURRENTREGSET ( a -- ) 
: SETREGISTRYVALUE { a1 n1 a2 n2 RegType \ khdl -- } 
\ a1,n1=value string, a2,n2=key string
: UPDATEADDRESS ( a n -- ) 
: VALUENAME ( -- a n ) 
: "GETDEFAULT ( a1 n1 -- a2 n2 ) 
: "GETDEFAULTVALUE ( addr n -- n1 flag ) 
\ read a value from registry
: "SETDEFAULT ( a1 n1 a2 n2 -- ) 
ANEW -REGISTRYWINDOWPOS.F 
: GETWINDOWRECT ( hWnd -- x y w h ) 
: LOADWINDOWPOS ( regpath$ -- x y w h ) 
CREATE PROGREG$ 
: RESTOREREGISTRYPATH ( -- ) 
: SAVEREGISTRYPATH ( -- ) 
: SAVEWINDOWPOS ( hWnd regpath$ \ -- ) 
: SETREGISTRYPATH ( a1 -- ) 
VALUE (NEXTRESID) \ first resource ID will be 1 unless otherwise set
ANEW -RESOURCES.F 
: .LANGUAGE ( n -- ) 
: .RESOURCENAME ( n -- ) 
: .RESOURCETYPE ( n -- ) 
: ADDAPPICON ( s" filename1" s" filename2" -- ) 
: ADDAPPICON? ( addr len -- f ) 
: ADDBITMAP ( ID s" filename" -- ) 
: ADDCURSOR ( ID s" filename" -- ) 
: ADDICON ( ID s" filename" -- ) 
: ADDRESOURCE ( ID ResourceType s" filename" -- ) 
: ADDTOFILE ( s" Filename" -- ) 
CREATE APPICON 
: BEGINUPDATE ( s" UpdateFileName" flag -- ) 
\ TRUE=existing resources are deleted,
: CLOSESOURCEFILE ( -- ) 
: COPYBITMAP ( ID -- ) 
: COPYCURSOR ( ID -- ) 
: COPYICON ( ID -- ) 
: COPYRESOURCE ( ID ResourceType -- ) 
: CURSORFILEDATA>RESDATA ( -- ) 
\ move group directory data truncating to 14 bytes per entry rather than 16
: DIRENTRIES ( -- a ) 
: ENDUPDATE ( f -- ) 
\ TRUE=no changes are made to the executable file, FALSE=the changes are made
: ENTRIES ( -- n ) 
CALLBACK: ENUMRESLANG { hExe ResourceType ResourceName Language l  -- f } 
CALLBACK: ENUMRESNAME { hExe ResourceType ResourceName l  -- f } 
: ENUMRESOURCELANGUAGES ( ResourceName ResourceType -- ) 
: ENUMRESOURCENAMES ( ResourceType -- ) 
: ENUMRESOURCES ( -- ) 
CALLBACK: ENUMRESTYPE { hExe ResourceType l  -- f } 
VALUE FILEDATA 
VALUE FILESIZE 
CALLBACK: GETRESLANG { hExe ResourceType ResourceName Language l  -- f } 
VALUE GROUPRESDATA \ pointer to resource data for GroupIcon or GroupCursor
: GROUPRESSIZE ( -- n ) 
VALUE HEXE \ handle of file to copy resources from
VALUE HUPDATE \ handle of file to update resources in
: ICONFILEDATA>RESDATA ( -- ) 
\ move group directory data truncating to 14 bytes per entry rather than 16
VALUE LANGUAGEID \ Language identifier
: LISTRESOURCES ( s" Filename" -- ) 
: LOADAPPICON ( -- hIcon ) 
: LOADRESOURCE ( ID ResourceType -- ) 
: LOADRESOURCEERROR ( ID -- ) 
: NBYTESINRES ( i -- a ) 
: NDIRENTRY ( i -- a ) 
: NEXTRESID ( -- n ) 
: NHOTSPOT ( i -- n ) 
: NID ( i -- ID ) 
: NIMAGEADDRESS ( i -- a ) 
: NIMAGEOFFSET ( i -- a ) 
: NPLANES ( i -- a ) 
: NSIZE ( i -- n ) 
: READRESFILE ( s" filename" -- ) 
: REPLACEFILE ( s" Filename" -- ) 
VALUE RESDATA \ pointer to resource data
: RESOURCEFILEERROR ( File$ -- ) 
CREATE RESOURCEFILENAME 
: RESOURCELANGUAGE ( ResourceName ResourceType -- ) 
VALUE RESOURCENUMBER 
: RESOURCESTRING ( n -- a n ) 
VALUE RESSIZE \ size of resource
: SOURCEFILE ( s" Filename" -- ) 
: SOURCEFILEERROR ( File$ -- ) 
CREATE SOURCEFILENAME 
: UPDATEFILE ( -- ) 
\ ask whether to update resources
: UPDATEFILEERROR ( File$" -- ) 
CREATE UPDATEFILENAME 
: UPDATEMESSAGE ( File$ -- n ) 
\ IDYES or IDNO
: UPDATERESOURCE ( ID ResourceType -- ) 
: UPDATERESOURCEERROR ( ID -- ) 
ANEW -SCROLLBAR.F 
INT CBSIZE 
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
INT FMASK 
:M GETPAGE: ( -- page ) 
:M GETPOSITION: ( -- n ) 
:M GETRANGE: ( -- min val ) 
: GETSCROLLINFO ( -- n ) 
:CLASS HORIZSCROLL 
:CLASS HORIZSCROLL 
INT NMAX 
INT NMIN 
INT NPAGE 
INT NPOS 
INT NTRACKPOS 
|CLASS SCROLLBAR 
|CLASS SCROLLBAR 
RECORD: SCROLLINFO 
:M SETFONT: ( hndl -- ) 
\ Set the font in the control.
\ Note that this is a dummy method in this class.
:M SETPAGE: ( page -- ) 
:M SETPOSITION: ( n -- prev ) 
:M SETRANGE: ( min max -- ) 
: SETSCROLLINFO ( -- n ) 
:CLASS SIZEBOX 
:CLASS SIZEBOX 
;RECORDSIZE: SIZEOF(SCROLLINFO) 
:M START: ( Parent -- ) 
\ Create the control.
:CLASS VERTSCROLL 
:CLASS VERTSCROLL 
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: SBS_VERT.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: SBS_SIZEGRIP.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: SBS_HORZ.
MKSTRUCT: &TOKEN_PRIVILEGE 
: .ATTRIBUTE ( attribute - ) 
: .LUID ( luid-h luid-l - ) 
\ size of string  lpName,       lpLuid        pSystemName
: .PRIVS \ Uses the buffer for storage of the privileges
CONSTANT /LARGE$ 
DWORD ATTRIBUTES 
: COMPUTERNAME$! ( adr - ) 
\ March 30th, 2002 was GetComputerName
: DEFAULT-SYSTEM ( - ) 
: DOWN ( - ) 
\ 5
DWORD DWBUILDNUMBER 
DWORD DWMAJORVERSION 
DWORD DWMINORVERSION 
DWORD DWOSVERSIONINFOSIZE 
DWORD DWPLATFORMID 
: GET-TOKEN ( DesiredAccess - TokenHandle ) 
: GETTOKENINFORMATION ( type TokenHandle - buffer-with-info buffer-size ) 
CREATE LARGE$ 
OFFSET LUAA 
DOUBLE LUID 
: LUID? ( z"priv" - luid-h luid-l ) 
}STRUCT LUID_AND_ATTRIBUTES 
: NT-OR-BETTER? ( - flag ) 
: OS! ( adr - ) 
\ 5
}STRUCT OSVERSIONINFO 
DWORD PRIVILEGECOUNT 
: RESET_LAST_ERROR ( - ) 
ANEW SECURITY.F \ Is also able to shutdown a PC
: SETPRIV ( z"Privilege" Attribute - flag ) 
\ for the current process
: SHUTDOWN ( type - ) 
STRING: SYSTEMNAME 
ADD-STRUCT SZCSDVERSION 
CONSTANT TOKENDEFAULTDACL 
CONSTANT TOKENGROUPS 
CONSTANT TOKENIMPERSONATIONLEVEL 
CONSTANT TOKENOWNER 
CONSTANT TOKENPRIMARYGROUP 
CONSTANT TOKENPRIVILEGES 
CONSTANT TOKENRESTRICTEDSIDS 
CONSTANT TOKENSESSIONID 
CONSTANT TOKENSOURCE 
CONSTANT TOKENSTATISTICS 
CONSTANT TOKENTYPE 
CONSTANT TOKENUSER 
}STRUCT TOKEN_PRIVILEGE 
CONSTANT FIONASYNC \ Import WinSock2 Dll
CONSTANT FIONIO 
CONSTANT FIONREAD 
: HOST>IADDR ( str len -- iaddr ) 
\ This function converts a host string to an ip address 
\ The host string could be anything from a domain name to ip address. 
\ Returns 0 if the host is unable to be looked up.
: IADDR>STR ( iaddr -- str len ) 
\ This converts an ip address to a readable string.  
\ It does not look up the host name, the string is in the "255.255.255.255" format
NEWUSER SADDR \ socket address structure
\ Main Socket Words
\ These words represent the core of the socket library.
\ They have been written to be thread-safe.
: SOCK-ACCEPT ( sock -- sock iaddr ) 
\ This will accept a socket that is in the listening queue. 
\ 'iaddr' is the ip address of the connecting socket and can be converted
\ into an easy-to-read number through the 'iaddr>str' word. 
\ If no sockets are in queue to be accepted, this function will block
\ until one tries to connect. 
\ If the socket is a non-blocking socket, then the function will fail
\ and return immediately if the queue has no sockets to accept. 
\ If the function fails, it will return '0' as the iaddr and '-1' 
\ (or INVALID_SOCKET) as the socket.
: SOCK-ACCEPT? ( sock -- flag ) 
\ This function returns true if the socket has other sockets in queue that 
\ want to be connected.  It is to be used in conjunction with 'sock-accept'
\ so you can call sock-accept without blocking.
: SOCK-BLOCKED ( flag sock -- ) 
\ This function sets a socket to blocked or unblocked mode.
\ If the flag is false, the socket will be set to 'unblocked'.
\ If the flag is true, the socket will be set to 'blocked'.
: SOCK-CLOSE ( sock -- ior ) 
\ Closes socket - very similar to close-file
\ ior is 0 if the close was successful
: SOCK-CLOSED? ( sock -- flag ) 
\ This function tests to see if the socket has been closed at the other end
\ or broken at any point.
: SOCK-CREATE ( p -- sock ) 
\ Make a new socket for listening on port 'p'
\ Used only for server-side sockets
: SOCK-ERR? ( sock -- n ) 
\ This function tests to see if there are any errors on the socket.
: SOCK-LISTEN ( n sock -- ) 
\ This tells a socket to start queuing sockets that want to connect.
\ 'n' is the size of the queue that should be created to listen.
\ after 'n' sockets have tried to connect and have yet to be accepted, 
\ further sockets will be refused until waiting sockets are accepted.
\ (standard queue size is 5)
: SOCK-OPEN ( addr len port -- sock ) 
\ This opens up a new socket to a host name on a given port number 
\ the host name will be looked up and the port number is converted implicitly 
\ If the socket cannot be opened, a exception will be thrown. 
: SOCK-READ ( addr len sock -- len ) 
\ Reads data from the socket to a buffer. 
\ It works very similarly to 'read-file', but has different return parameters 
\ a returned 'len' of -1 means there was a socket error (SOCKET_ERROR) 
\ If the provided 'len' is larger than the amount of data ready to be read from the socket, 
\ the socket will block until it has revceived the full amount of data.
\ If the socket is a non-blocking socket, it will read what it can and return 
\ right away.
: SOCK-READ? ( sock -- n ) 
\ This function returns the amount of data that the socket can read 
\ without blocking.  It is useful for working with socket asyncronously.
\ It will return -1 if the socket has no data to read (will block, or socket closed).
: SOCK-WRITE ( addr len sock -- len ) 
\ Write data from a buffer to the socket. 
\ It works very similarly to 'write-file' 
\ a returned 'len' of -1 means there was a socket error (SOCKET_ERROR) 
\ If the socket is currently unable to take any data,
\ the socket will block until it has room in it's internal buffer to send the data.
\ If the socket is a non-blocking socket, it will write what it can and return 
\ right away. (amount actually written is returned as 'len')
: SOCK-WRITE? ( sock -- flag ) 
\ This function returns true if the socket can write data without blocking.
\ You can send 0-1024 bytes to the socket asyncronously without blocking if 
\ the flag is true.
: WSOCKET2-CLEANUP ( -- ) 
\ Initializes the windows socket dll 
\ called in initialization-chain
: WSOCKET2-INIT ( -- ) 
\ Initializes the windows socket dll 
\ called in initialization-chain
ANEW -SOUNDVOLUME.F 
: SOUND? ( -- f ) 
\ W32F  sound
\ Check if sound is on.
: SOUNDOFF ( -- ) 
\ W32F  sound
\ Turn sound off.
: SOUNDON ( -- ) 
\ W32F  sound
\ Turn the sound back on after turning it off.
: SOUNDONOFF ( -- ) 
\ W32F  sound
\ Toggle sound
: VOLUME! ( left-sound-volume right-sound-volume -- ) 
\ W32F  sound
\ Set the volume level of the waveform-audio output device.
VALUE VOLUME-LEFT 
VALUE VOLUME-RIGHT 
: VOLUME@ ( -- left-sound-volume right-sound-volume ) 
\ W32F  sound
\ Retrieves the current volume level of the waveform-audio output device.
\ If a device does not support both left and right volume control,
\ the low-order word of dwVolume specifies the volume level,
\ and the high-order word is ignored.
\ Then the right-sound-volume will be 0.
{ \ sound-volume --  } 
INT #ARGS 
:M (BIND): ( -- ) 
:M (EXECUTE): ( str len -- ) 
:M (STEP): ( -- n ) 
ANEW -SQLITE.F 
:M BINDBLOB: ( str len i -- ) 
\ Binds a '?' in the query string to a blob (binary buffer object, or in simpler
\ terms, a bunch of bytes).  If there are no more question
\ marks in the query string, the query will execute.
:M BINDDOUBLE: ( d i -- ) 
\ Binds a '?' in the query string to a double int.  If there are no more question
\ marks in the query string, the query will execute.
:M BINDFLOAT: ( f i -- ) 
\ Binds a '?' in the query string to a floating point number.
\ If there are no more question
\ marks in the query string, the query will execute.
:M BINDINT: ( n i -- ) 
\ Binds a '?' in the query string to a integer.  If there are no more question
\ marks in the query string, the query will execute.
:M BINDSTR: ( str len i -- ) 
\ Binds a '?' in the query string to a string.  If there are no more question
\ marks in the query string, the query will execute.
:M CLASSINIT: ( -- ) 
:M CLOSE: ( -- flag ) 
\ Closes the database.  You can still open another database with
\ the same object after closing, if desired.
BYTES DBHNDL 
CFA-CODE DOCALL64 ( [ n ] -- r ) 
\ like DOCALL, but with a double returned
:M ERR: ( -- ) 
\ thows an error on any problem
\ Displays any error that might have occured.
:M EXECUTE: ( str len -- ) 
\ Execute a SQL query on the cursor.  Any returned data will be in the cursor.
:M FIELDCNT: ( -- n ) 
\ Returns the number of columns in the current record.
:M FIELDNAME: ( field -- str len ) 
\ Returns the column name of the given column number.
:M FIELDTYPE: ( field -- DataTypeEnum ) 
\ Returns the data type constant of the given column. Possible data types are:
\ 
\ SQLITE_INTEGER |
\ SQLITE_FLOAT |
\ SQLITE_TEXT |
\ SQLITE_BLOB |
\ SQLITE_NULL |
: FINALIZE ( -- ) 
:M GETBLOB: ( field -- addr len ) 
\ Returns the Binary Buffer of the given column on the current row.
\ This binary data may be anything.
:M GETDOUBLE: ( field -- d ) 
\ Returns the double of the given column on the current row.
:M GETFLOAT: ( field -- float ) 
\ Returns the floating point value of the given column on the current row.
:M GETINT: ( field -- int ) 
\ Returns an integer value of the given column on the current row.
:M GETSTR: ( field -- str len ) 
\ Returns the string of the given column on the current row.  May be much longer than 255
:M ISNULL?: ( field -- flag ) 
\ Returns true if the given field for the given flag is null
INT LASTERR 
: MAKE-PROC64 
:M NEXTROW: ( -- flag ) 
\ Goes to the next row of the query result.  If there are no more rows,
\ it will return true
:M OPEN: ( str len -- ) 
\ Opens a database file so we can execute operations on it.
\ If the string is ":memory:" the database is actually created
\ in memory instead of on disk, and should be faster.
:M REQUERY: ( -- ) 
\ Rerun the last query.
CODE RETF 
:CLASS SQLITEDB 
:CLASS SQLITEDB 
CONSTANT SQLITE_BLOB 
CONSTANT SQLITE_FLOAT 
CONSTANT SQLITE_INTEGER 
CONSTANT SQLITE_NULL 
CONSTANT SQLITE_STATIC 
CONSTANT SQLITE_TEXT 
CONSTANT SQLITE_TRANSIENT 
:M SQLOK: ( n -- ) 
\ checks return argument for errors
BYTES STMT 
BYTES TSTR 
:M VERSION: ( -- str len ) 
\ Returns the version of SQLite being used
:M ~: ( --  ) 
ANEW -STATUSBAR.F 
INT AWIDTHS \ address of widths table
INT BORDERSTYLE \ style of border to use
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLEAR: ( -- ) 
\ clears text in the status window.
:M GETBORDERS: ( -- hWidth vWidth divWidth ) 
\ Retrieves the current widths of the horizontal and vertical borders of
\ the status window.
\  hWidth  is the width of the horizontal border.
\  vWidth  is the width of the vertical border.
\  divWidth  is the width of the border between rectangles.
\ TODO: Don't use HERE here !!!
:M GETPARTS: ( -- aWidths nParts ) 
\ Gets the number of parts in the status window and the coordinate of the right
\ edge of each part.
:M HEIGHT: ( -- height ) 
\ Get the height of the status window.
:M MINHEIGHT: ( #pixels -- ) 
\ Sets the minimum height of the status window's drawing area.
\ The minimum height is the sum of #pixels and twice the width, in pixels,
\ of the vertical border of the status window.
\ An application must use the Redraw: method to redraw the window.
:CLASS MULTISTATUSBAR 
:CLASS MULTISTATUSBAR 
:M NOBORDER: ( -- ) 
\ The text is drawn without borders.
INT NPARTS \ number of parts in statusbar
:M RAISEDBORDER: ( -- ) 
\ The text is drawn with a border to appear lower than the plane of the
\ window (default).
:M REDRAW: ( -- ) 
\ Redraw the statusbar after changes (e.g. size).
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETMULTI: ( -- ) 
\ Set the status bar to show all parts set with  SetParts:  before.
:M SETPARTS: ( aWidths nParts -- ) 
\ Sets the number of parts in the status window and the coordinate of the right
\ edge of each part.
\  nParts  Number of parts to set (cannot be greater than 256).
\  aWidths  is a pointer to an integer array. The number of elements is
\ specified in nParts. Each element specifies the position, in client coordinates,
\ of the right edge of the corresponding part. If an element is -1, the right edge
\ of the corresponding part extends to the border of the window.
\ Note:  aWidths  must be valid until SetParts: is used again!
:M SETSIMPLE: ( -- ) 
\ Reset the status bar to show only one part.
:M SETTEXT: ( szText -- ) 
\ Sets the text in the status window.
\ Use  RaisedBorder: ,  NoBorder:  or  SunkenBorder:  to set
\ the the style how the text is drawn.
:M SETTEXT: ( szText n -- ) 
\ Sets the text in the  n'th  part of status window.
\ Use  RaisedBorder: ,  NoBorder:  or  SunkenBorder:  to set
\ the the style how the text is drawn.
:M START: ( Parent -- ) 
\ Create the control.
:M START: ( Parent -- ) 
\ Create the control.
:CLASS STATUSBAR 
:CLASS STATUSBAR 
:M SUNKENBORDER: ( -- ) 
\ The text is drawn with a border to appear higher than the plane of the window.
: (}STRUCT) 
ANEW -STRUCT.F \ for Win32Forth
: >STRUCT ( -<name-struct>- -<member>- -  ) 
: STRUCT{ ( -- ) 
: }STRUCT 
: "FIRST-SUB-DIR" { adr len -- sub-adr sub-len } 
: "PROCESS-DIRECTORY { adr len  \ buf1 buf2 -- } 
: "PROCESS-MASK-DIRECTORY { adr1 len1 adr2 len2  -- } 
VALUE #MHNDL 
: (DO-FILES-PROCESS ( path -- ) 
ANEW -SUB_DIRS.F \ For scanning and processing files of 1 directory or a whole tree.
\ Extracted from WinView and changed by J.v.d.Ven.
\ May 31st, 2003 Now it uses one big heap so that it does not have
\ to re-allocate memory again.
\ Now sdir will also need a flag on the stack for handling of subdirectorys
\ July 4th, 2003 - 17:28 Changed for use in WinEd 2.21.00 - dbu
\ September 9th, 2011 Added sub_dir_access.
\ Using FILE_READ_ATTRIBUTES in it is faster and can be used when you do not need to open a file.
\ R/O is needed for the IDE or WinEd
CREATE BUF 
: DELETE-HEAP ( - ) 
: DO-FILES-PROCESS ( -- ) 
\ In the Forth-part
: FIRST-MASK" ( -- a1 n1 ) 
\ get the first forth directory path
VALUE HEAPBUFFER 
: INIT-HEAP-BUFFER 
: LIST-FILE ( -- ) 
CREATE MASK-BUF 
VALUE MASK-PTR 
2VARIABLE MASK-SOURCE 
VALUE MHNDL 
CREATE NAME-BUF 
: NEW-BUFFER ( - adr ) 
: NEXT-MASK" ( -- a1 n1 ) 
\ get the next path from dir list
: NEXT-SUB-DIR" ( -- sub-dir sub-len ) 
\ "first-sub-dir" must be called first
VALUE OPEN-FILE? \ do we want the file opened?
DEFER PROCESS-1FILE 
: PROCESS-AFILE ( adrd adr len -- ) 
\ search this file for find string
: SDIR ( path count file-spec count flag-subdir - ) 
PATH: SDIR-PATH 
VALUE SEARCH-ABORTED? 
VALUE SEARCH-HNDL \ handle of file we are searching
: SUB-DIR-CLOSE ( -- ior ) 
\ close the _hdl-dir handle
VALUE SUB-DIRS? 
VALUE SUB_DIR_ACCESS 
VARIABLE _HDL-DIR \ hold the find directory handle
: (.SWITCH) ( xt -- ) 
\ Print Switch.
: (SWITCH) 
ANEW -SWITCH.F 
: .CONDITION ( link -- ) 
\ Print out a condition.
: .CONDITIONS ( link -- ) 
\ Print out all conditions.
: .DEFAULT ( xt f -- ) 
\ Print default.
: .SWITCH ( xt -- ) 
\ FORTH            SYSTEM
\ Print out all the conditions defined for this switch.Using SEE -< name >- on a switch has the same effect.
\ Conditions are listed default first followed by the others with in the order they are found i.e. the later
\ they are defined the earlier they are in the list.
: .SWITCHES \ FORTH            SYSTEM
\ Print out all the defined switches.The more recently a switch has been defined the earlier it comes in the
\ list.
: .WORD-TYPE-SWITCH ( xt false | true -- xt false | true ) 
\ Print this is a switch.
: :SWITCH ( xt "name" -- head ) 
\ FORTH            SYSTEM
\ Define a switch "name" that executes the procedure whose xt is on the stack ( with the input argument on top
\ of the stack ) if no matching condition has been added to the switch and open it for adding conditions.
VALUE CURRENT-SWITCH \ gah 9mar03 Address of switch currently being
\ defined or null if not defining switch
: DBG-NEST-SWITCH ( xt false | true -- xt false | true ) 
\ Nest into switch when debugging.
CFA-CODE DOSWITCH 
: NOT-LINK ( head n -- head n ) 
\ Error if not link.
: RUN-ERROR ( -- ) 
\ Check for errors.
: RUN: ( head n -<words ;>- -- head ) 
\ FORTH            SYSTEM
\ Add a condition to the currently open switch structure that runs the following forth words up to ; if the
\ value n is passed to the switch. An error occurs if head is not the head of the currently open switch, or no
\ switch is open.
: RUNS ( head n -<word>- -- head ) 
\ FORTH            SYSTEM
\ Add a condition to the currently open switch structure that runs -<word>- if the value n is passed to the
\ switch. An error occurs if head is not the head of the currently open switch, or no switch is open.
VARIABLE SWITCH-LINK \ For forgetting
: SWITCH-OPEN ( -- ) 
\ Error if switch not open for additional conditions.
: SWITCH: ( "name" "<code to perform> ;" -- head ) 
\ FORTH            SYSTEM
\ Define a new switch "name" whose default action is the following inline
\ forth code (up to the terminating ;). The forth words must call the switch
\ "name" as a recursive call with "name" to perform recursion, since
\ RECURSE merely runs the inline code again.
: SWITCH] ( head -- ) 
\ FORTH            SYSTEM
\ Close SWITCH structure. An error occurs if head is not the head of the currently open switch.
: TRIM-SWITCHES ( nfa -- nfa ) 
\ trim down the switch linked list.
: UNKNOWN? ( xt -- f ) 
\ Return true if xt is an unnamed definition.
: [+SWITCH ( "name" -- head ) 
\ FORTH            SYSTEM
\ Open existing SWITCH "name" for additional conditions.
: [SWITCH ( "name" "default" -- head ) 
\ FORTH            SYSTEM
\ Define a new switch "name" whose default action is "default" and open
\ it for adding conditions.
: _.SWITCH ( xt -- xt|0) 
\ Used by SEE.
ANEW -TABCONTROL.F 
;RECORDSIZE: /TC_ITEM 
:M ADJUSTRECT: ( rect flag -- ) 
\ Calculates a tab control's display area given a window rectangle, or
\ calculates the window rectangle that would correspond to a specified
\ display area.
\  rect  is the address of a RECT structure that specifies the given rectangle
\ and receives the calculated rectangle.
\  flag  If this parameter is TRUE, prc specifies a display rectangle and receives
\ the corresponding window rectangle. If this parameter is FALSE, prc specifies a window
\ rectangle and receives the corresponding display area.
INT CCHTEXTMAX \ size of buffer pointed to by the pszText member
:M CCHTEXTMAX: ( -- n ) 
\ Get the  cchTextmax  member of the TCITEM struct.
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLIENTSIZE: ( -- l t r b ) 
\ Return size of display area of the tab control.
: DEFAULT-FUNC ( lParam obj -- false ) 
\ The default  change(-ing) function .
\  lParam  is the adress of the Address of an NMHDR structure.
\  obj  is the address of the TabControl object that has send the
\ notification message.
:M DELETEALLTABS: ( -- ) 
\ Removes all items from the tab control.
:M DELETETAB: ( index -- ) 
\ Removes an item from the tab control.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M GETROWCOUNT: ( -- n ) 
\ Retrieves the current number of rows of tabs in a tab control.
:M GETSELECTEDTAB: ( -- index ) 
\ Determines the currently selected tab in the tab control.
:M GETTABCOUNT: ( -- n ) 
\ Retrieves the number of tabs in the tab control.
:M GETTABINFO: ( index -- ) 
\ Retrieves information about a tab in the tab control.
:M HANDLE_NOTIFY: { w l \ ncode tabid -- f } 
\ Handle the notification messages of the tab control. This method must
\ be called within the WM_NOTIFY handler of the parent window.
\ Currently only these notification messages are handled:
\ 
\ TCN_SELCHANGE | Notifies a tab control's parent window that the currently selected tab has changed. |
\ TCN_SELCHANGING | Notifies a tab control's parent window that the currently selected tab is about to change. |
INT IIMAGE \ index to tab control's image
:M IIMAGE: ( -- n ) 
\ Get the  iImage  member of the TCITEM struct.
:M INSERTTAB: ( index -- ) 
\ Inserts a new tab into the tab control.
\  mask  and other members of the TCITEM struct must be set.
:M ISCCHTEXTMAX: ( n -- ) 
\ Set the  pszText  member of the TCITEM struct.
:M ISCHANGEFUNC: ( cfa -- ) 
\ Set the  change function . This function es executed when
\ the currently selected tab has changed.
:M ISCHANGINGFUNC: ( cfa -- ) 
\ Set the  changeing function . This function es executed when
\ the currently selected tab is about to change.
:M ISIIMAGE: ( n -- ) 
\ Set the  iImage  member of the TCITEM struct.
:M ISLPARAM: ( n -- ) 
\ Set the  lparam  member of the TCITEM struct.
:M ISMASK: ( n -- ) 
\ Set the  mask  member of the TCITEM struct. Possible values are:
\ 
\ TCIF_TEXT       | The pszText member is valid. |
\ TCIF_IMAGE      | The iImage member is valid. |
\ TCIF_PARAM      | The lParam member is valid. |
\ TCIF_RTLREADING | Displays the text of pszText using right-to-left reading order on Hebrew or Arabic systems. |
:M ISPSZTEXT: ( addr -- ) 
\ Set the  mask  member of the TCITEM struct.
INT LPARAM \ application-defined data associated with tab
:M LPARAM: ( -- n ) 
\ Get the  lparam  member of the TCITEM struct.
INT LPRESERVED1 \ reserved; do not use
INT LPRESERVED2 \ reserved; do not use
INT MASK \ value specifying which members to retrieve or set
:M MASK: ( -- n ) 
\ Get the  mask  member of the TCITEM struct.
:CLASS MULTILINETABCONTROL 
:CLASS MULTILINETABCONTROL 
:M ON_SELCHANGED: ( l -- f ) 
\ Handle the TCN_SELCHANGE notification message.
\ Default calls the  change function  set with the  IsChangeFunc:  method.
:M ON_SELCHANGING: ( l -- f ) 
\ Handle the TCN_SELCHANGING notification message.
\ Default calls the  changeing function  set with the  IsChangingFunc:  method.
INT PSZTEXT \ pointer to string containing tab text
:M PSZTEXT: ( -- n ) 
\ Get the  pszText  member of the TCITEM struct.
INT SELCHANGE-FUNC \ selection change function
INT SELCHANGING-FUNC \ selection changing function
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETSELECTEDTAB: ( index --  ) 
\ Selects a tab in the tab control.
\ Note: A tab control does not send a TCN_SELCHANGING or TCN_SELCHANGE
\ notification message when a tab is selected using this message.
:M SETTABINFO: ( index -- ) 
\ Sets some or all of a tab's attributes.
\  mask  and other members of the TCITEM struct must be set.
:M START: ( Parent -- ) 
:M START: ( Parent -- ) 
\ Create the control.
:CLASS TABCONTROL 
:CLASS TABCONTROL 
RECORD: TC_ITEM \ The TCITEM struct.
:M TC_ITEM: ( -- addr ) 
\ Get the address of the TCITEM struct.
:M WINDOWSIZE: ( l t r t -- l t r b ) 
\ Given display area return window size required.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: TCS_FOCUSONBUTTONDOWN.
:M WINDOWTITLE: ( -- null$ ) 
\ SintillaControl asks for window title of parent
: (CREATE-TASK) ( thread state -- flag ) 
\ create a task
: (MAKE-LOCK) ( -- lock ) 
\ W32F    Lock
\ Make a new lock, and return it's identifier.
: (TASK) ( parm cfa -- ) 
\ helper routine
: (TASK-BLOCK) ( parm cfa-task addr -- len ) 
\ W32F    Task
\ Build a task block at the supplied address, initialise the parameter and xt and
\ return the size of the task block.
CFA-CODE BEGIN-TASK ( -- ) 
\ thread management. init a new thread/task
MAKE-LOCK CLASSNAME-LOCK \ to make unique window class naming thread safe
MAKE-LOCK CONTROL-LOCK \ to make control subclassing thread safe
: CREATE-TASK ( task-block -- flag ) 
\ W32F    Task
\ Create a new task which is suspended. Flag is true if successful.
: DELETE-LOCKS ( nfa link -- nfa ) 
\ delete lock if created after nfa
MAKE-LOCK DIALOG-LOCK \ to make linking dialogs thread safe
: DISPOSEUSEROBJECTS ( addr -- ) 
MAKE-LOCK DYN-LOCK \ to make new$ thread safe
: EXIT-TASK ( n -- ) 
\ W32F    Task
\ Exit the current task returning the value n to the operating system, which can be retrieved
\ by calling GetExitCodeThread. The stacks and user area for the thread are freed and
\ DLLs are detatched. If the thread is the last active thread of the process then the
\ process is terminated.
MAKE-LOCK GDI-LOCK \ to make linking gdi objects thread safe
: INIT-LOCK ( lock -- ) 
\ Initialise a lock
: INIT-LOCK-FROM-LIST ( addr -- ) 
\ Initialise a lock given address of link
: INIT-LOCKS ( -- ) 
\ Initialise all the locks
: INIT-SYSTEM-LOCKS ( -- ) 
\ initialize system locks for multitasking
: LOCK ( lock -- ) 
\ W32F     Lock
\ If another thread owns the lock wait until it's free,
\ then if the lock is free claim it for this thread,
\ then increment the lock count.
VARIABLE LOCK-LIST 
CONSTANT LOCK-SIZE 
: MAKE-LOCK ( compiling: "name"  --  runtime: -- lock ) 
\ W32F    Lock
\ Create a new lock. When executed the lock returns it's identifier.
MAKE-LOCK MEM-LOCK \ to make memory allocation thread safe
MAKE-LOCK POINTER-LOCK \ to make allocating pointers thread safe
: RESUME-TASK ( task-block -- flag ) 
\ W32F    Task
\ Resume a task. Flag is true if successful.
: RUN-TASK ( task-block -- flag ) 
\ W32F    Task
\ Create a new task and run it. Flag is true if successful.
: STOP-TASK ( task-block -- ) 
\ W32F    Task
\ Set the stop flag of the task block to true.
: SUSPEND-TASK ( task-block -- flag ) 
\ W32F    Task
\ Suspend a task. Flag is true if successful.
: TASK-BLOCK ( parm cfa-task -- addr ) 
\ W32F    Task
\ Build a task block in the dictionary, initialise the parameter and xt and return
\ the address of the block.
: TASK-STOP? ( task-block -- flag ) 
\ W32F    Task
\ Flag is true if stop-task has been set by another task. In this case the task should
\ do any necessary clean-up and exit.
FIELD+ TASK>HANDLE ( task-block -- addr ) 
\ W32F    Task
\ Convert the task-block address into the address of the thread handle
FIELD+ TASK>HANDLE ( task-block -- addr ) 
\ W32F    Task
\ Convert the task-block address into the address of the thread handle
FIELD+ TASK>ID ( task-block -- addr ) 
\ W32F    Task
\ Convert the task-block address into the address of the thread id
FIELD+ TASK>PARM ( task-block -- addr ) 
\ W32F    Task
\ Convert the task-block address into the address of the thread parameter
FIELD+ TASK>PARM ( task-block -- addr ) 
\ W32F    Task
\ Convert the task-block address into the address of the thread parameter
: TASK>PARM@ ( task-block -- parm ) 
\ W32F    Task
\ Fetch the parameter from the task-block.
: TRIM-LOCKS ( nfa -- nfa ) 
: TRYLOCK ( lock -- fl ) 
\ W32F    Lock
\  For NT4, w2k and XP; 
\ If the lock is owned by another thread return false. 
\ If the lock is free claim it for this thread,
\ then increment the lock count and return true. 
\  For Win9x, and NT<4; 
\ Perform the action of LOCK and return true.
: UNLOCK ( lock -- ) 
\ W32F     Lock
\ Decrement the lock count and free the lock if the resultant count is zero.
: _CLASSNAMELOCK ( -- ) 
: _CLASSNAMEUNLOCK ( -- ) 
: _CONTROLLOCK ( -- ) 
: _CONTROLUNLOCK ( -- ) 
: _DIALOGLOCK ( -- ) 
: _DIALOGUNLOCK ( -- ) 
: _DYNLOCK ( -- ) 
: _DYNUNLOCK ( -- ) 
: _GDILOCK ( -- ) 
: _GDIUNLOCK ( -- ) 
: _MEMLOCK ( -- ) 
: _MEMUNLOCK ( -- ) 
: _POINTERLOCK ( -- ) 
: _POINTERUNLOCK ( -- ) 
CREATE 'TABS 
ANEW -TEXTBOX.F 
:M CLASSINIT: ( -- ) 
\ Initialise the class.
:M CLEAR: ( -- ) 
\ Delete selected text.
:M COPY: ( -- ) 
\ Copy the current selection to the clipboard in CF_TEXT format.
:M CUT: ( -- ) 
\ Delete (cut) the current selection, if any, in the edit control and
\ copy the deleted text to the clipboard in CF_TEXT format.
:M DEFAULTTABS: ( -- ) 
\ Set the default tab stops in the multiline edit control (16 dialog template units).
: GETCLIPBOARDTEXT ( addr -- n ) 
\ get text from clipboard
:M GETCURSOR: ( -- n ) 
\ Get location of cursor (chars from start)
:M GETLINE: ( -- n ) 
\ Return location of the cursor (lines from start).
:M GETLINECOUNT: ( -- n ) 
\ Retrieves the number of lines in the multiline edit control.
\ The return value is an integer specifying the total number of
\ text lines in the multiline edit control. If the control has no text,
\ the return value is 1. The return value will never be less than 1.
:M GETLINES: ( -- nr ) 
\ Depreacted method. Use  GetLineCount:  instead.
:M GETSELECTION: ( -- nEnd nStart ) 
\ Get the starting and ending character positions of the current selection in the edit control
:M GETSELTEXT: ( addr -- n ) 
\ Retrieves the currently selected text from the edit control.
\  addr  is the address of the a buffer that receives the selected text.
\ The calling application must ensure that the buffer is large enough to hold
\ the selected text.
:M GETSELTEXT: ( addr -- n ) 
\ Retrieves the currently selected text from the edit control.
\  addr  is the address of the a buffer that receives the selected text.
\ The calling application must ensure that the buffer is large enough to hold
\ the selected text.
\ Note: The text is copyied to the clipboard, too!
:M GETTEXTEX: \ { buffer$ maxlen -- buffer$ len }
\ Copies the text of the edit control into a buffer.
\  buffer$  is the address of the buffer that will receive the text.
\  maxlen  Specifies the maximum number of characters to copy to the
\ buffer, including the NULL character. If the text exceeds this limit, it
\ is truncated.
\ If the method succeeds,  len  is the length, in characters, of the copied
\ string, not including the terminating null character.
\ maxlen buffer$ hwnd Call GetWindowText buffer$ swap ;M
:M ISMODIFIED?: ( -- f ) 
\ Get the state of an edit control's modification flag. The flag indicates whether
\ the contents of the edit control have been modified.
:M LINESCROLL: ( n -- ) 
\ scroll n lines
:CLASS MULTILINETEXTBOX 
:CLASS MULTILINETEXTBOX 
:M NOTMODIFIED: ( -- ) 
\ Depreacted method. Use  SetModify:  instead.
:CLASS PASSWORDBOX 
:CLASS PASSWORDBOX 
:M PASTE: ( -- ) 
\ Copy the current content of the clipboard to the edit control at the current
\ caret position. Data is inserted only if the clipboard contains data in CF_TEXT
\ format.
INT PWMSETFOCUS \ pointer to WM_SETFOCUS handler
:M READONLY: ( f -- ) 
\ Set or remove the read-only style of the edit control.
\ A value of TRUE sets the read-only style; a value of FALSE removes it.
:M REDO: ( -- ) 
\ Redoes the last edit control operation in the control's redo queue.
:M REDO?: ( -- f ) 
\ Check is there is an operation in the control's redo queue.
:M REMOVESELECTION: ( -- ) 
\ Remove any selection.
:CLASS RICHEDITCONTROL 
:CLASS RICHEDITCONTROL 
:M SELECTALL: ( -- ) 
\ Select all the text in the multiline edit control.
:M SELECTALL: ( -- ) 
\ Set the focus to the edit control and select all the text in the control.
:M SETFONT: ( handle -- ) 
\ Set the font in the control.
:M SETMARGINS: ( left right -- ) 
\ Sets the widths of the left and right margins for an edit control.
:M SETMODIFY: ( f -- ) 
\ Sets or clears the modification flag for an edit control. The modification flag
\ indicates whether the text within the edit control has been modified.
:M SETSELECTION: ( nEnd nStart -- ) 
\ Selects a range of characters in the edit control.  nEnd  specifies the
\ ending character position of the selection.  nStart  specifies the
\ starting character position of the selection.
\ The start value can be greater than the end value. The lower of the two values
\ specifies the character position of the first character in the selection. The
\ higher value specifies the position of the first character beyond the selection.
\ The start value is the anchor point of the selection, and the end value is the
\ active end. If the user uses the SHIFT key to adjust the size of the selection,
\ the active end can move but the anchor point remains the same.
\ The control displays a flashing caret at the end position regardless of the relative
\ values of start and end.
:M SETTABSTOPS: ( tabarray #tabs -- ) 
\ Sets the tab stops in the multiline edit control. When text is copied to
\ the control, any tab character in the text causes space to be generated up
\ to the next tab stop.
\  #tabs  Specifies the number of tab stops contained in the array. If this
\ parameter is zero, the lParam parameter is ignored and default tab stops are
\ set at every 32 dialog template units. If this parameter is 1, tab stops are
\ set at every n dialog template units, where n is the distance pointed to by
\ the  tabarray  parameter. If this parameter is greater than 1,  tabarray 
\ is a pointer to an array of tab stops.
\  tabarray  Pointer to an array of unsigned integers specifying the tab stops,
\ in dialog template units. If the  #tabs  parameter is 1, this parameter is a pointer
\ to an unsigned integer containing the distance between all tab stops, in dialog template
\ units.
:M SETTEXTLIMIT: ( n -- ) 
\ Set the text limit of an edit control.
\  n  Specifies the maximum number of characters the user can enter. This number does
\ not include the null terminator. 
\ Edit controls on Windows NT/ 2000: If this parameter is zero, the text length is set
\ to 0x7FFFFFFE characters for single-line edit controls or -1 for multiline edit controls. 
\ Edit controls on Windows 95/98: If this parameter is zero, the text length is set to 0x7FFE
\ characters for single-line edit controls or 0xFFFF for multiline edit controls.
\ The SetTextLimit: method limits only the text the user can enter. It does not affect any text
\ already in the edit control when the message is sent, nor does it affect the length of the text
\ copied to the edit control by the SetText: method. If an application uses the SetText: method
\ to place more text into an edit control than is specified in the SetTextLimit: method, the user can
\ edit the entire contents of the edit control.
\ Before the SetTextLimit: method is called, the default limit for the amount of text a user can enter
\ in an edit control is 32,767 characters.
\ Edit controls on Windows NT/ 2000: For single-line edit controls, the text limit is either 0x7FFFFFFE bytes
\ or the value of  n , whichever is smaller. For multiline edit controls, this value is either
\ -1 bytes or the value of  n , whichever is smaller.
\ Edit controls on Windows 95/98: For single-line edit controls, the text limit is either 0x7FFE bytes or
\ the value of  n , whichever is smaller. For multiline edit controls, this value is either 0xFFFF bytes
\ or the value of  n , whichever is smaller.
:M SETTEXTZ: ( addrz -- ) 
\ Copy the text from the 0 terminated string  addrz  into the edit control.
:M SETWMSETFOCUS: ( xt -- ) 
\ Set handler for WM_SETFOCUS messages.
:M START: ( Parent -- ) 
\ Create the control.
:CLASS TEXTBOX 
:CLASS TEXTBOX 
:M UNDO: ( -- ) 
\ Undoes the last edit control operation in the control's undo queue.
:M UNDO?: ( -- f ) 
\ Check is there is an operation in the control's undo queue.
:M UNWRAP: ( -- ) 
\ Set control to scroll instead of wrap text.
\ Note this method does nothing!
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is:
\ ES_AUTOVSCROLL, ES_MULTILINE, ES_WANTRETURN and ES_NOHIDESEL.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. The default style is ES_PASSWORD.
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control.
:M WM_SETFOCUS ( h m w l -- res ) 
:M WRAP: ( -- ) 
\ Set control to wrap text.
\ Note this method does nothing!
:M CLASSINIT: ( -- ) 
\ Init the class
:M CREATETIMER: ( ms -- ) 
\ Create the timer for this window.
:M KILLTIMER: ( -- ) 
\ Destroy the timer for this window.
:M ON_DONE: ( -- ) 
\ Things to do before program termination
:M ON_TIMER: ( -- ) 
\ Thing's to do when the window recives a timer event. Default does nothing.
INT TIMER 
:CLASS TIMER-WINDOW 
:CLASS TIMER-WINDOW 
:M WM_TIMER ( -- ) 
\ handle the WM_TIMER events
: #DEFAULTBUTTONS ( addr -- n ) 
ANEW -TOOLBAR.F 
;RECORDSIZE: /TBB 
: :TOOLBARTABLE ( -- addr1 addr2 12 ) 
: :TOOLSTRINGS ( -- addr 13 ) 
: ;TOOLBARTABLE ( addr1 addr2 12 -- ) 
: ;TOOLSTRINGS ( addr 13 -- ) 
:M ADDBITMAPS: ( hInst nID n -- n' ) 
:M ADDBUTTONS: ( 'button_table noButtons -- n ) 
:M ADDBUTTONSTRINGS: ( z" -- n ) 
:M AUTOSIZE: ( -- ) 
RECTANGLE BUTTONRECT 
INT BUTTONSTRINGS 
INT BUTTONTABLE 
:M CHECKBUTTON: ( f id -- ) 
\ f=true, check;  f=false, uncheck
:M CLASSINIT: ( -- ) 
:M COMMANDTOINDEX: ( id -- buttonindex ) 
:M CUSTOMIZE: ( -- ) 
\ Programmatically force customization
INT DWDATA 
:M ENABLEBUTTON: ( f id -- ) 
\ f=true, enable;  f=false, disable
BYTE FSSTATE 
BYTE FSSTYLE 
:M GETBUTTONCOUNT: ( -- n ) 
: GETBUTTONDATA ( buttontable buttonindex  -- addr ) 
:M GETBUTTONRECT: ( buttonindex -- left top right bottom ) 
:M GETROWS: ( -- n ) 
: GETTEXT { bid \ ndx -- addr } 
:M GETTEXT: ( id -- addr ) 
:M GETTOOLTIPS: ( -- hToolTip ) 
:M HANDLE_NOTIFY: { w l \ code id index -- f } 
:M HIDEBUTTON: ( f id -- ) 
\ f=true, hide;  f=false, show
INT HINST 
INT HKR 
INT IBITMAP 
INT IDCOMMAND 
:M INDETERMINATEBUTTON: ( f id -- ) 
\ f=true, indeterminate;  f=false, don't
:M ISBUTTONCHECKED: ( id -- f ) 
\ f=true, checked;  f=false, unchecked
:M ISBUTTONENABLED: ( id -- f ) 
\ f=true, enabled;  f=false, disabled
:M ISBUTTONHIDDEN: ( id -- f ) 
\ f=true, hidden;  f=false, shown
:M ISBUTTONINDETERMINATE: ( id -- f ) 
\ f=true, indeterminate;  f=false, no
:M ISBUTTONPRESSED: ( id -- f ) 
\ f=true, pressed;  f=false, not pressed
:M ISBUTTONSTRINGS: ( texttable -- ) 
:M ISBUTTONTABLE: ( buttontable -- ) 
:M ISTOOLTIPS: ( texttable -- ) 
INT ISTRING 
: N->'TOOLSTRING ( stringtable stringindex  -- addr | NULL ) 
INT NID 
:M ON_BEGINADJUST: ( -- f ) 
\ Beginning customization
:M ON_BEGINDRAG: ( buttonindex -- f ) 
\ User starts dragging button
:M ON_CUSTHELP: ( -- f ) 
\ Request for customization help
:M ON_ENDADJUST: ( -- f ) 
\ User done with customization
:M ON_ENDDRAG: ( buttonindex -- f ) 
\ Button dragging is complete
:M ON_GETBUTTONINFO: ( addr buttonindex -- f ) 
\ f = true, tbb at addr has been
:M ON_NEEDTEXT: ( addr id -- ) 
\ Request for tool-tip text...
:M ON_QUERYDELETE: ( buttonindex -- f ) 
\ f = true, ok to remove button
:M ON_QUERYINSERT: ( buttonindex -- f ) 
\ f = true, ok to insert to the
:M ON_RESET: ( -- f ) 
\ User regrets (current) customization
:M ON_TOOLBARCHANGE: ( -- f ) 
\ User has changed toolbar
:M PRESSBUTTON: ( f id -- ) 
\ f=true, press;  f=false, don't press
INT PSZSUBKEY 
INT PSZVALUENAME 
: REGISTER-STRUCT-SIZE ( -- ) 
\ Register tbb structure size
BYTES RESERVED 
:M SAVERESTORE: ( f -- ) 
\ f = true, Save,  f = false, Restore.
\ Perform operation if Registry keys have been
\ properly initialized.
: SEPARATORBUTTON, ( addr 12 -- addr 12 ) 
:M SETPARENT: ( hWndParent -- ) 
:M SETREGISTRYKEY: ( pszSubKey pszValueName -- ) 
: SSEPARATORBUTTON, ( addr 12 buttonwidth -- addr 12 ) 
\ added 2004-04-18, EAB
:M START: ( Parent -- ) 
RECORD: TBAB 
RECORD: TBB 
RECORD: TBSR 
: TOOLBARBUTTON, ( addr 12 bidx id state style txtno -- addr 12 ) 
: TOOLBARTABLEEXTRABUTTONS: ( addr 12 -- addr 12 ) 
:M TOOLTIPHANDLE: ( -- hwnd | 0 ) 
INT TOOLTIPS \ -------------------- Standard Tool-bar Structures --------------------
: TS," ( 13 -<string">- 13 ) 
:M VALIDID: ( id -- f ) 
\ return true if ButtonID is valid
:CLASS WIN32TOOLBAR 
:CLASS WIN32TOOLBAR 
:M WINDOWSTYLE: ( -- style ) 
ANEW -TRACKBAR.F 
:M CLEARSEL: ( f -- ) 
\ Clears the current selection range in the trackbar.
\ If the  f  is TRUE, the trackbar is redrawn after the selection is cleared.
:M CLEARTICKS: ( f -- ) 
\ Removes the current tick marks from a trackbar. This message does not remove
\ the first and last tick marks, which are created automatically by the trackbar.
\ If the  f  is TRUE, the trackbar is redrawn after the tick marks are cleared.
\ If this parameter is FALSE, the message clears the tick marks but does not redraw
\ the trackbar.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M GETCHANNELRECT: ( lpRect -- ) 
\ Retrieves the size and position of the bounding rectangle for the
\ trackbar's channel. (The channel is the area over which the slider
\ moves. It contains the highlight when a range is selected.)
:M GETLINESIZE: ( -- n ) 
\ Retrieves the number of logical positions the trackbar's slider moves in
\ response to keyboard input from the arrow keys, such as the RIGHT ARROW or
\ DOWN ARROW keys. The logical positions are the integer increments in the
\ trackbar's range of minimum to maximum slider positions.
:M GETNUMTICKS: ( -- n ) 
\ Retrieves the number of tick marks in the trackbar.
\ The GetNumTicks: method counts all of the tick marks, including the first and last tick
\ marks created by the trackbar.
:M GETPAGESIZE: ( -- n ) 
\ Retrieves the number of logical positions the trackbar's slider moves in
\ response to keyboard input, such as the PAGE UP or PAGE DOWN keys, or mouse
\ input, such as clicks in the trackbar's channel. The logical positions are the
\ integer increments in the trackbar's range of minimum to maximum slider positions.
:M GETRANGEMAX: ( -- n ) 
\ Retrieves the maximum position for the slider in the trackbar.
:M GETRANGEMIN: ( -- n ) 
\ Retrieves the minimum position for the slider in the trackbar.
:M GETSELEND: ( -- n ) 
\ Retrieves the ending position of the current selection range in the trackbar.
\ A trackbar can have a selection range only if you specified the TBS_ENABLESELRANGE
\ style when you created it.
:M GETSELSTART: ( -- n) 
\ Retrieves the starting position of the current selection range in the trackbar.
\ A trackbar can have a selection range only if you specified the TBS_ENABLESELRANGE
\ style when you created it.
:M GETTHUMBLENGTH: ( -- n ) 
\ Retrieves the length (in Pixel) of the slider in the trackbar.
:M GETTHUMBRECT: ( lpRect -- ) 
\ Retrieves the size and position of the bounding rectangle for the slider
\ in the trackbar.
:M GETTICK: ( iTic -- n ) 
\ Retrieves the logical position of a tick mark in a trackbar. The logical
\ position can be any of the integer values in the trackbar's range of minimum
\ to maximum slider positions.
:M GETTICKPOS: ( iTic -- n ) 
\ Retrieves the current physical position of a tick mark in a trackbar.
:M GETTICKSPTR: ( -- pointer ) 
\ Retrieves the address of an array that contains the positions of the tick marks
\ for a trackbar.
\ Returns the address of an array of DWORD values. The elements of the array specify
\ the logical positions of the trackbar's tick marks, not including the first and last
\ tick marks created by the trackbar. The logical positions can be any of the integer
\ values in the trackbar's range of minimum to maximum slider positions.
\ The number of elements in the array is two less than the tick count returned by the
\ GetNumTicks: method. Note that the values in the array may include duplicate positions
\ and may not be in sequential order. The returned pointer is valid until you change the
\ trackbar's tick marks.
:M GETVALUE: ( -- n) 
\ Retrieves the current logical position of the slider in the trackbar. The logical positions
\ are the integer values in the trackbar's range of minimum to maximum slider positions.
:M SETLINESIZE: ( n -- ) 
\ Sets the number of logical positions the trackbar's slider moves in
\ response to keyboard input from the arrow keys, such as the RIGHT ARROW or
\ DOWN ARROW keys. The logical positions are the integer increments in the
\ trackbar's range of minimum to maximum slider positions.
:M SETPAGESIZE: ( n -- ) 
\ Sets the number of logical positions the trackbar's slider moves in response to
\ keyboard input, such as the PAGE UP or PAGE DOWN keys, or mouse input, such as clicks
\ in the trackbar's channel. The logical positions are the integer increments in the
\ trackbar's range of minimum to maximum slider positions.
:M SETRANGE: ( min max f -- ) 
\ Sets the range of minimum and maximum logical positions for the slider in the trackbar.
\ If the  f  parameter is TRUE, the trackbar is redrawn after the range is set. If this
\ parameter is FALSE, the message sets the range but does not redraw the trackbar.
:M SETRANGEMAX: ( max f -- ) 
\ Sets the maximum logical position for the slider in the trackbar.
\ If the  f  is TRUE, the trackbar is redrawn after the range is set.
\ If this parameter is FALSE, the message sets the range but does not redraw
\ the trackbar.
:M SETRANGEMIN: ( min f -- ) 
\ Sets theminimum logical position for the slider in the trackbar.
\ If the  f  is TRUE, the trackbar is redrawn after the range is set.
\ If this parameter is FALSE, the message sets the range but does not redraw
\ the trackbar.
:M SETSEL: ( min max f -- ) 
\ Sets the starting and ending positions for the available selection range in the trackbar.
\ If the  f  is TRUE, the message redraws the trackbar after the selection range is set.
\ If this parameter is FALSE, the message sets the selection range but does not redraw the trackbar.
\ This method is ignored if the trackbar does not have the TBS_ENABLESELRANGE style.
:M SETSELEND: ( end f -- ) 
\ Sets the ending logical position of the current selection range in a trackbar.
\ This message is ignored if the trackbar does not have the TBS_ENABLESELRANGE style.
\ If the  f  is TRUE, the trackbar is redrawn after the range is set.
\ If this parameter is FALSE, the message sets the range but does not redraw
\ the trackbar.
:M SETSELSTART: ( start f -- ) 
\ Sets the starting logical position of the current selection range in the trackbar.
\ This message is ignored if the trackbar does not have the TBS_ENABLESELRANGE style.
\ If the  f  is TRUE, the trackbar is redrawn after the range is set.
\ If this parameter is FALSE, the message sets the range but does not redraw
\ the trackbar.
:M SETTHUMBLENGTH: ( n -- ) 
\ Set the length (in Pixel) of the slider in the trackbar.
:M SETTICK: ( pos -- ) 
\ Sets a tick mark in a trackbar at the specified logical position.
:M SETTICKFREQ: ( pos freq -- ) 
\ Sets the interval frequency for tick marks in a trackbar. For example, if the frequency
\ is set to two, a tick mark is displayed for every other increment in the trackbar's range.
\ The default setting for the frequency is one; that is, every increment in the range is
\ associated with a tick mark.
\ The trackbar must have the TBS_AUTOTICKS style to use this method.
:M SETVALUE: ( n -- ) 
\ Sets the current logical position of the slider in the trackbar.
:M START: ( Parent -- ) 
\ Create the control.
:CLASS TRACKBAR 
:CLASS TRACKBAR 
:CLASS VTRACKBAR 
:CLASS VTRACKBAR 
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is: TBS_VERT.
RECORD: &NOTIFYICONDATA 
ANEW -TRAYWINDOW.F 
:M ADDICON: ( -- ) 
\ Add our icon to the traybar
:M DELETEICON: ( -- ) 
\ Remove our icon from the traybar
:M GETFLAGS: ( -- uFlags ) 
:M GETID: ( -- uID ) 
:M GETTOOLTIP: ( -- addr len ) 
\ Get the tooltip text for the traybar icon. Default is to print the title of the window
\ s" Tooltip text" ;M
:M HIDEWINDOW: ( -- ) 
\ Hide the window and add the icon to the traybar.
INT NID_CBSIZE 
INT NID_HICON 
INT NID_HWND 
BYTES NID_SZTIP 
INT NID_UCALLBACKMESSAGE 
INT NID_UFLAGS 
INT NID_UID 
:M ON_DONE: ( -- ) 
:M ON_ICONNOTIFY: ( hWnd uMsg wParam lParam -- res ) 
\ Handle the messages from the traybar icon.
\ The default handler removes the icon for the traybar and shows the window,
\ when the user click's with the left mouse button on the tray icon.
\ If the right mouse button is used the popup menu of the window is shown.
\ Use the  SetPopupBar:  method to assign a popup menu to the window.
:M ON_INIT: ( -- ) 
: SHELLNOTIFYICON ( n -- ) 
AS SHELL_NOTIFYICON 
:M SHOWWINDOW: ( -- ) 
\ Show the window and remove the icon from the traybar.
;RECORDSIZE: SIZEOF(NOTIFYICONDATA) 
: TRACKPOPUP ( -- ) 
\ Open the popup menu of the window.
:CLASS TRAYWINDOW 
:CLASS TRAYWINDOW 
CONSTANT WM_CALLBACK_MESSAGE 
:M WM_CALLBACK_MESSAGE ( hWnd uMsg wParam lParam -- res ) 
:M WM_SIZE ( hWnd uMsg wParam lParam -- res ) 
\ Handle the WM_SIZE message. If the window is minimized
\ it will be hidden and the icon will be added to the traybar.
:M WM_SYSCOMMAND ( hWnd uMsg wParam lParam -- res ) 
\ Handle the WM_SYSCOMMAND message. If the window is minimized
\ it will be hidden and the icon will be added to the traybar.
;RECORDSIZE: /NMHDR 
;RECORDSIZE: /NMTV 
;RECORDSIZE: /TVINS 
CONSTANT /TVITEM \ Record:    tvdi
\ NMHDR     hdr
\ TV_ITEM     item
\ ;Record
;RECORDSIZE: /TVKD 
INT ACTION \ TV_ITEM     itemOld
INT CCHILDREN 
INT CCHILDRENNEW 
INT CCHILDRENOLD 
INT CCHTEXTMAX 
INT CCHTEXTMAXNEW 
INT CCHTEXTMAXOLD 
INT CODE 
:M COLLAPSE: ( hItem -- ) 
:M COLLAPSEITEM: ( hItem -- ) 
:M COLLAPSERESET: ( hItem -- ) 
:M DELETEITEM: ( hItem -- f ) 
\ Removes an item and all its children from the tree view control.
\ hItem is the handle of the item to delete. If hItem is set to TVI_ROOT,
\ all items are deleted.
:M EXPAND: ( hItem f -- ) 
:M EXPANDITEM: ( hItem -- ) 
: FILL-NMHDR ( l -- ) 
: FILL-NMTV ( addr -- ) 
: FILL-TVITEM ( l -- ) 
: FILL-TVKD ( l -- ) 
INT FLAGS 
:M GETCHILD: ( hItem -- hItem ) 
:M GETFIRSTVISIBLE: ( hItem -- hItem ) 
:M GETITEMRECT: ( hItem -- f ) 
:M GETLASTVISIBLE: ( hItem -- hItem ) 
:M GETMAXWIDTH: ( -- n ) 
:M GETNEXT: ( hItem -- hItem ) 
:M GETNEXTITEM: ( hItem flag -- h ) 
:M GETPARENTITEM: ( hItem -- hItem ) 
:M GETPREVIOUS: ( hItem -- hItem ) 
:M GETROOT: ( -- hItem ) 
:M HANDLE_NOTIFY: ( h m w l -- f ) 
INT HINSERTAFTER \ tvitem starts here
INT HITEM 
INT HITEMNEW 
INT HITEMOLD 
INT HPARENT 
INT HWNDFROM 
INT IDFROM 
INT IIMAGE 
INT IIMAGENEW 
INT IIMAGEOLD 
:M INSERTITEM: ( -- hItem ) 
INT ISELECTEDIMAGE 
INT ISELECTEDIMAGENEW 
INT ISELECTEDIMAGEOLD 
RECTANGLE ITEMRECT 
: ITEMWIDTHMAX ( hItem -- hItem ) 
INT LPARAM 
INT LPARAMNEW \ POINT     ptDrag
INT LPARAMOLD \ TV_ITEM     itemNew
INT MASK 
INT MASKNEW 
INT MASKOLD 
INT MAXWIDTH 
RECORD: NMHDR 
RECORD: NMTV \ NMHDR     hdr
:M ON_BEGINDRAG: ( -- f ) 
:M ON_BEGINLABELEDIT: ( -- f ) 
\ f=true, cancel edit,  f=false, ok edit
:M ON_BEGINRDRAG: ( -- f ) 
:M ON_DELETEITEM: ( -- f ) 
:M ON_ENDLABELEDIT: ( -- f ) 
:M ON_GETDISPINFO: ( -- f ) 
:M ON_ITEMEXPANDED: ( -- f ) 
:M ON_ITEMEXPANDING: ( -- f ) 
\ f=true, don't expand/collapse, f=false, ok go ahead
:M ON_KEYDOWN: ( -- f ) 
:M ON_RIGHTCLICK: ( -- f ) 
:M ON_SELCHANGED: ( -- f ) 
:M ON_SELCHANGING: ( -- f ) 
\ f=true, don't change, f=false, ok change
:M ON_SETDISPINFO: ( -- f ) 
INT PSZTEXT 
INT PSZTEXTNEW 
INT PSZTEXTOLD 
:M SELECTITEM: ( hItem flag -- ) 
:M SETIMAGELIST: ( himl iImage -- ) 
:M SETITEM: ( -- ) 
:M SORTCHILDREN: ( hItem -- ) 
:M START: ( Parent -- ) 
:M STARTSIZE: ( -- w h ) 
INT STATE 
INT STATEMASK 
INT STATEMASKNEW 
INT STATEMASKOLD 
INT STATENEW 
INT STATEOLD 
:M TOGGLEEXPANDITEM: ( hItem -- ) 
:CLASS TREEVIEWCONTROL 
:CLASS TREEVIEWCONTROL 
RECORD: TVINS 
: TVITEM ( - adr ) 
: TVITEM->TVINS ( -- ) 
RECORD: TVKD \ NMHDR     hdr
:M WINDOWSTYLE: ( -- style ) 
INT WVKEY 
INT X 
INT Y 
: (U") 
: +UNINULL ( destaddr -- ) 
\ Append a null to the unicode string at address.
: +UNIPLACE ( addr len destaddr -- ) 
\ Append a string to the end of an address
ANEW -UNICODE.F 
: >ASCII ( str len -- str len ) 
\ Convert unicode string to ascii (uses new$)
: >UNICODE ( str len -- str len ) 
\ Convert ascii string to unicode (uses Unew$)
: ASC>BSTR ( str len -- bstr ) 
\ Convert ascii string to unicode bstr.  bstr must be freed later with 'bstrfree'.
: ASC>UNI ( str len -- str len ) 
\ !!! MUST FREE STRING AFTER !!!
\ Convert a ascii string to unicode.
\ must free unicode string with 'free' when no longer needed.
: BSTRFREE ( bstr -- ) 
\ Free a bstr.
: BSTRLEN ( ustr -- len ) 
\ Returns the length of the bstr.  From this the bstr can be used with all the
\ other unicode functions.
: U" ( ... " -- str len ) 
\ Unicode string - same as s"
: UNEW$ ( -- addr ) 
\ Allocate 2X MAXSTRING bytes from the dynamic string buffer and return the address. This is
\ designed for 16bit Unicode strings which are twice as long as Ascii.
: UNI>ASC ( str len -- str len ) 
\ !!! MUST FREE STRING AFTER !!!
\ Convert a unicode string to ascii
\ must free ascii string afterwards when no longer needed.
: UNICOUNT ( addr -- addr len ) 
\ Fetch a unicode string from an address (stored with uniplace)
: UNIPLACE ( addr len destaddr -- ) 
\ Store a unicode string to an address
: UNITYPE ( addr len -- ) 
\ Type a unicode string to the console
: USTR, ( addr n -- ) 
\ Store a unicode string to the dictionary at HERE
: ZUNICOUNT ( addr -- addr len ) 
\ Fetch a null-terminated unicode string from an address (null is 16-bit)
ANEW -UPDOWNCONTROL.F 
:M CLOSE: ( -- ) 
\ Close the control.
:M DISABLE: ( -- ) 
\ Disable the control.
:M ENABLE: ( f -- ) 
\ Enable the control.
:M GETBASE: ( -- n ) 
\ Get the current radix base (that is, either base 10 or 16).
:M GETRANGE: ( -- lower upper ) 
\ Retrieves the minimum and maximum positions (range) for the control.
:M GETVALUE: ( -- n ) 
\ Retrieves the current position of the up-down control.
\ Note: This method ABORT's on error.
:M MOVE: ( x y w h -- ) 
\ Move the text box to the specified positon and the up-down control as well.
:M SELECT: ( -- ) 
\ Selects the text inside the spinner
:M SETBUDDY: ( hBuddy -- ) 
\ Sets the buddy window for the up-down control.
:M SETDECIMAL: ( -- ) 
\ Sets the radix base for the control to decimal.
\ Decimal numbers are signed.
:M SETFONT: ( hndl -- ) 
\ Set the font of the text box.
:M SETHEX: ( -- ) 
\ Sets the radix base for the control to hexadecimal.
\ Hexadecimal numbers are always unsigned.
:M SETRANGE: ( lower upper -- ) 
\ Sets the minimum and maximum positions (range) the control.
\ Neither position can be greater than the UD_MAXVAL value or less than
\ the UD_MINVAL value. In addition, the difference between the two positions
\ cannot exceed UD_MAXVAL.
:M SETVALUE: ( n -- ) 
\ Set the current position for the up-down control.
:CLASS SPINNERCONTROL 
:CLASS SPINNERCONTROL 
:M START: ( parent -- ) 
\ Start the control.
:M START: ( Parent -- ) 
\ Create the control.
:M STARTPOS: ( -- x y ) 
\ default window position
:M STARTSIZE: ( -- cx cy ) 
\ default window size
TEXTBOX THEBOX 
:M THEBOX: ( -- spinbox ) 
\ Object address of the text box for directly manipulating it (though it shouldn't really be done).
:CLASS UPDOWNCONTROL 
:CLASS UPDOWNCONTROL 
:M WINDOWSTYLE: ( -- style ) 
\ Get the window style of the control. Default style is:
\ WS_BORDER, UDS_ARROWKEYS, UDS_SETBUDDYINT and UDS_ALIGNRIGHT.
ANEW -VOLINFO.F 
: .VOLUME ( RootPath count - ) 
: DRIVETYPE$ ( DriveType - DriveType$ cnt ) 
VALUE FILESYSTEMFLAGS \ file system flags
STRING: FILESYSTEMNAMEBUFFER \ file system
\ 0 value nFileSystemNameSize   \ FileSystemNameBuffer
\ nFileSystemNameSize  nVolumeNameSize are not filled
: GETVOLUMEINFORMATION ( RootPath count - DriveType$ flag ) 
VALUE MAXIMUMCOMPONENTLENGTH \ maximum filename length
: RETRIEVEVOLUMEINFORMATION ( RootPath count - DriveType$  ) 
STRING: ROOTPATHNAME \ root directory of the file system
: VOLUMELABEL ( RootPath count - DriveType adr cnt  ) 
STRING: VOLUMENAMEBUFFER \ name of the volume
\ 0 value nVolumeNameSize       \ length of lpVolumeNameBuffer
VALUE VOLUMESERIALNUMBER \ serial number
: Y/N-BOX ( szText szTitle  - button ) 
: #HELP ( n1 -- ) 
\ help on a help context index number
: $HELP ( a1 -- ) 
\ help on a string
: $HELP-FILE ( a1 -- ) 
\ set the name of the current help file
ANEW -WIN32HELP.F 
: .HELP ( -- ) 
\ display the current help file string
: HELP ( -<word>- ) 
: HELP-FILE ( -<filename>- ) 
\ specify a new help filename
: HELP-INDEX ( -- ) 
: HELP-ON-HELP ( -- ) 
\ get help on windows help
CREATE HELP_FILE$ 
: SET-HELP \ synonym of HELP-FILE
: _HELP-RELEASE ( -- ) 
\ release our marker to help system
: "SETTOFOREGROUND ( adr cnt - hwnd|0 ) 
: #NUMBER-LINE> ( adr count which seperator - n flag ) 
CREATE *BUFFER 
: *SEARCH ( adr-spec /spec adr-search /search flag - adr len flag ) 
: +TRAILING ( addr count  char -- adr2 count2 ) 
\ remove leading char
: -DUP ( n1 n2    - n1 n1 n2 ) 
VALUE CASESENSITIVE? 
CODE COMPAREIA ( adr1 len1 adr2 len2 -- n ) 
: CONTAINING? ( adres-spec /spec adr-search /search -- next-adr /next flag ) 
: CONTINUE-W-SEARCH? ( /search /spec result - /search flag ) 
VALUE LAST-CNT 
: NEVER ( flag - false ) 
: NEXT-SEARCH ( >adr-spec max-spec adr-spec /spec adr-search /search - >adr-spec max-spec adr-spec1 /spec2 adr-search /search  ) 
CODE S-EXCHANGE ( ... n[k]..0 k -- ... 0..n[k] ) 
: SCAN-FOR-WILDCARD ( adr-spec /spec - adr len flag ) 
: SEARCH-WINDOW ( adr cnt - hwnd|0 ) 
CODE SEARCHIA ( adr1 len1 adr2 len2 -- adr3 len3 flag ) 
: STARTING-WITH? ( adres-spec /spec  adr-search /search - next-adr /next flag ) 
: TARGET-SEARCH ( >adr-spec max-spec adr-spec /spec adr-search /search - >adr-spec1 max-spec1 adr-spec /spec adr-search /search ) 
: W-SEARCH ( adr-spec /spec adr-search /search flag - adr len flag ) 
: WILDCARD ( >adr-spec max-spec adr-spec /spec adr-search /search - >adr-spec max-spec adr-spec1 /spec2 adr-search /search  ) 
VALUE WILDCARD-CHAR 
: WINDOWTOFOREGROUND ( hwnd -  ) 
ANEW W_SEARCH.F \ October 7th, 2002  By J.v.d.Ven.
\ July 27th, 2002
\ Corrected a number of bugs. Now w-search returns the found string.
\ May 23rd, 2003
\ - Made w-search case insensitive
\ July 7th, 2003
\ - Made this source independed from toolset.f
\ - added an extra flag to w-search. The flag determines if the search
\ is case insensitive or not.
\ - *search puts a * before the specification string.
\ - Then it performs a w-search
\ July 21st, 2003
\ - Changed w_search. Now it will return the stack right when a search
\ buffer or a specification string has a lenght of 0.
\ February 21st, 2007
\ - Added "SetToForeground
\ February 21st, 2013
\ - Improved +training
\ From toolset.f \ load it here when you would like to use it.
MAP-FIELD+ >HFILE 
MAP-FIELD+ >HFILEADDRESS 
MAP-FIELD+ >HFILELENGTH 
MAP-FIELD+ >HFILEMAPPING 
MAP-FIELD+ >HFILEMAXLENGTH 
MAP-FIELD+ >HFILENAME 
: CLOSE-MAP-FILE ( map-handle -- f1 ) 
: CLOSE-SHARE ( memory_pointer handle -- ) 
: CREATE-FILE-MAP ( map-handle -- ) 
CFA-CODE DOMAP ( -- a1 ) 
\ runtime for CREATE and VARIABLE
: FLUSH-VIEW-FILE ( map-handle -- f1 ) 
\ flush the file to disk
VALUE I-WAS-FIRST 
: MAP-FIELD+ ( n1 n2 -<name>- n3 ) 
( a1 -- a2 ) 
: MAP-HANDLE ( -<name>- ) 
\ define a data structure to hold a mapped file
: MAP-NAME ( a1 n1 map-handle -- ) 
: MAP-VIEW-FILE ( map-handle -- ) 
: OPEN-MAP-FILE ( a1 n1 map-handle -- f1 ) 
: OPEN-SHARE ( z"name" length -- memory_pointer handle ) 
: UNMAP-VIEW-FILE ( map-handle -- f1 ) 
:M "SETMENUTEXT: ( a1 n1 -- ) 
BYTES &ANULL 
: (CLASSINIT) ( -- ) 
: (CLASSINIT) ( -- ) 
: (CLASSINIT) ( -- ) 
: (CLASSINIT) ( -- ) 
: (CLASSINIT) ( -- ) 
: (CLASSINIT:) ( -- ) 
:CLASS :MENUFUNC 
:CLASS :MENUFUNC 
:CLASS :MENUITEM 
:CLASS :MENUITEM 
: BREAKPOPUP ( -- ) 
\ make the next POPUP break on a new line
VALUE BREAK_FLAG 
INT BROKEN_FLAG 
VALUE BUILDMENU 
VALUE BUILDPOPUP 
:M CHECK: ( f1 -- ) 
INT CHECK_FLAG 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: 
:M CLASSINIT: ( check_flag -- ) 
:M CLASSINIT: 
:M CLASSINIT: 
:M CLASSINIT: 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: ( -- ) 
:M CLASSINIT: 
:M CLOSEMENU: ( -- ) 
:M CURRENTID: ( -- bid ) 
:M DOMENU: ( ID -- ) 
:M DOMENU: ( IDM -- ) 
\ function receives the address of the menu object
:M DOMENU: ( ID -- ) 
\ called from a WINDOW
:M DOMENU: ( ID -- ) 
:M DOMENU: ( IDM -- ) 
:M DOMENU: ( IDM -- ) 
:M DOMENU: ( IDM -- ) 
:M DOMENU: ( IDM -- ) 
:M DOMENU: ( IDM -- ) 
:M ENABLE: ( f1 -- ) 
: ENDBAR ( -- ) 
\ finish defining a menubar
: ENDSUBMENU ( -- ) 
DEFER EXECUTE-MENUFUNC 
:M GETBAR: ( -- hmb ) 
:M GETMENUTEXT: ( -- a1 n1 ) 
:M GETPOPUP: ( -- hpm ) 
:M GETPOPUP: ( -- hpm ) 
:M GETPREV: ( -- mprev ) 
:M GETPREV: ( -- pprev ) 
:M GETPREV: ( -- pprev ) 
INT HMB \ head pointer of the menubar's menu list
INT HMENU \ handle to the menubar
INT HPM \ handle for the popup menu head pointer
INT HPM \ handle for the popup menu head pointer
VALUE IDCOUNTER 
CONSTANT IDSTART 
:M LOADMENU: ( pid parent -- ) 
:M LOADMENU: ( pid parent -- ) 
:M LOADMENU: ( pid parent -- ) 
:M LOADMENU: ( mb parent -- ) 
:M LOADMENU: ( mb parent -- ) 
:M LOADMENU: ( pid parent -- ) 
:M LOADMENU: ( parent -- ) 
:M LOADMENU: ( mb parent -- ) 
: M"TEXT" ( -<"text">- ) 
INT MB \ temporary variable used for menubar traversal
: MENU-APPEND ( hmenu flags id string -- ) 
:CLASS MENUBAR 
:CLASS MENUBAR 
VARIABLE MENUBAR-LINK 
|CLASS MENUCONSOLE 
|CLASS MENUCONSOLE 
:M MENUHANDLE: ( -- hmenu ) 
|CLASS MENUITEM 
|CLASS MENUITEM 
:CLASS MENUITEMS 
:CLASS MENUITEMS 
|CLASS MENULINE 
|CLASS MENULINE 
|CLASS MENUMESSAGE 
|CLASS MENUMESSAGE 
|CLASS MENUSEPARATOR 
|CLASS MENUSEPARATOR 
INT MFUNC \ the menu function
INT MFUNC \ the menu function
INT MID \ menu ID and also used as a temp for PREV menu item
INT MID 
INT MID 
MENUBAR MIN-MENU-BAR 
INT MPREV 
BYTES MSTRING \ the menu text
INT MTEXT 
: NEXTID ( -- bid ) 
INT PARENT \ the parent window
INT PARENT 
INT PARENT 
INT PARENT 
INT PID 
INT PID 
INT PM \ temp for popup menu list processing
INT PM \ temp for popup menu list processing
INT POPID 
INT POPID 
INT POPID \ handle of this items popup menu
|CLASS POPUP 
|CLASS POPUP 
:CLASS POPUPBAR 
:CLASS POPUPBAR 
|CLASS POPUPITEM 
|CLASS POPUPITEM 
:M POSENABLE: ( flag pos -- ) 
INT PPREV 
INT PPREV 
INT PREVBAR 
VALUE PREVPOP 
INT PTEXT 
:M PUTBAR: ( hmb -- ) 
:M PUTPOPUP: ( hpm -- ) 
:M PUTPOPUP: ( hpm -- ) 
:M REDRAWMENU: ( -- ) 
:M SETMENUFUNC: ( cfa -- ) 
:M SETMENUTEXT: ( z$ -- ) 
:M SETMENUTEXT: ( z$ -- ) 
:M SETPREV: ( pprev -- ) 
:M SETPREV: ( pprev -- ) 
:M SETPREV: ( mprev -- ) 
:M START: ( parent -- ) 
:M START: ( parent -- ) 
|CLASS SUBMENU 
|CLASS SUBMENU 
INT SUBPOPUP 
|CLASS SYSPOPUP 
|CLASS SYSPOPUP 
:M TRACK: { win-handle | point -- } 
: TRIM-MENUS ( nfa -- nfa ) 
:M UNSUBMENU: ( -- ) 
:M ZEROMENU: ( -- ) 
: _EXECUTE-MENUFUNC ( cfa -- ) 
: (PRIVATE) ( xt-of-voc -- ) 
\ W32F         Module System
\ Set the vocabulary for internal definitions for the next module to be built.
\ This is a non-parsing version of the word PRIVATE.
: (RESET-STACKS) ( -- ) 
\ Used by RESET-STACKS for protection
: EXTERNAL ( -- ) 
\ W32F         Module System
\ Make the external vocabulary the current vocabulary.
DEFER HIDDEN-VOC 
: INTERNAL ( -- ) 
\ W32F         Module System
\ If a module hasn't yet been started or the internal vocabulary isn't the context
\ vocabulary add the internal vocabulary to the search order and save the current
\ vocabulary as the external vocabulary, then make the current vocabulary the internal
\ vocabulary. If a module is already being built then make the current vocabulary
\ the internal vocabulary.
: MODULE ( -- ) 
\ W32F         Module System
\ Complete the module by making the external vocabulary the current vocabulary,
\ removing the internal vocabulary from the search order if it's the context
\ vocabulary and resetting the internal vocabulary to hidden.
VALUE PRE-VOC \ previous vocabulary
: PRIVATE ( -<voc>- ) 
\ W32F         Module System
\ Set the vocabulary for internal definitions for the next module to be built.
\ This is a parsing version of the word (PRIVATE).
: SET-HIDDEN 
: (FORGET) ( cfa -- ) 
\ assumes count follows name
: ANEW ( "name" -- ) 
( Run: -- ) 
: DO-MARK ( -- ) 
\ mark must redefine the name that was forgotten
\ -rbs modified to reset vocabs and not generate redef warnings when marked
\ word is executed.
: DO-MARKER ( -- ) 
VARIABLE FENCE \ cannot forget below this address
: FORGET ( -<name>- ) 
: FULL-TRIM ( nfa link -- ) 
\ Order-independent trim
: MARK ( -<name>- ) 
: MARKER ( -<name>- ) 
( ANS) 
: POSSIBLY ( "name" -- ) 
: SYS-TRIM? ( nfa addr -- f ) 
\ TRUE if forgetting nfa removes addr from dict
: TRIM-CHAINS ( nfa -- nfa ) 
\ trim down the chain linked list
: TRIM-DEFER ( nfa -- nfa ) 
\ trim deferred word list to nfa
: TRIM-HANDLES ( nfa -- nfa ) 
\ trim handles list
: TRIM-WINLIBS 
: TRIM-WINPROCS 
DEFER TRIM? 
: VTRIM ( nfa voc-thread -- ) 
\ trim VOC-THREAD back to nfa
: -IFZEROTHROW ( n -- n ) 
: -VE-TEST ( addr len -- addr' len' ) 
\ skip possible - sign, set -ve-num?
: 0XL-NUMBER? ( addr len -- d1 ) 
: BASE-NUMBER? ( addr len -- d1 ) 
\ [-][$&%'][-]n[n*][.n*]
: BASE-TONUM ( addr len base -- d1 ) 
DEFER DISCARD-NUMBER 
: DOTTED-NUMBER? ( addr len -- d1 ) 
: HEX-NUMBER? ( addr len -- d1 ) 
\ xxxxH type numbers
: IP-NUMBER? ( addr len -- d ) 
\ convert ip address
: IP-SEG ( addr len -- addr' len' n ) 
\ IP segment before .
: IS-NUMBER? ( addr len -- f ) 
\ number check
: LASTCHAR ( addr len -- addr len char ) 
: NEW-NUMBER ( str -- d1 ) 
\ d1 is number, or -13 throw (undefined)
: NUMBER? ( addr len -- d f ) 
NEW-CHAIN NUMBER?-CHAIN 
: QUOTED-NUMBER? ( addr len -- d1 ) 
\ 'x' type numbers
: RUN-NUMCHAIN ( addr len -- d1 ) 
\ run number chain;
\ d1 is number, or -13 throw (undefined)
: SUPER-NUMBER? ( addr len -- d f1 ) 
: WINCON-CALL ( a1 n1 -- n f ) 
\ call to find constant
: WINCON-NUMBER? ( a1 n1 -- d ) 
{ \ con$ -- } 
CONSTANT WINCONLIB 
CONSTANT WINCONPTR \ for **WORDS.F**
CONSTANT WINENUMPTR \ for **WORDS.F**
: XBASE-CONVERT ( addr len base -- d1 ) 
: "ANYFIND { adr len \ find$ -- cfa f1 } 
: #LEXICON ( #threads -<name>- -- ) 
CONSTANT #LEXTHREADS \ deafult for a lexicon
CONSTANT #THREADS \ default number of threads for a vocabulary
: #VOCABULARY ( #threads -<name>- ) 
: #WORDLIST ( #threads -- wid ) 
: (VOC) ( #threads -<name>- -- ) 
: +ORDER ( wid - ) 
\ add wid to search order
: ALSO ( -- ) 
\ Duplicates topmost vocabulary in the search order
: ANYFIND ( a1 -- cfa f1 ) 
\ find a word in any vocabulary
VARIABLE ANYVOC 
#VOCABULARY ASSEMBLER 
: DEFINITIONS ( -- ) 
\ Sets the topmost context vocabulary as current
#VOCABULARY EDITOR 
: FORTH-WORDLIST ( -- wid ) 
: FORTH-WORDLIST ( -- wid ) 
: GET-CURRENT ( -- wid ) 
: GET-ORDER ( -- widn .. wid1 n ) 
\ get the whole search-order
: LEXICON ( -- ) 
\ like a vocabulary, but in APP space
: ONLY ( -- ) 
\ Removes all vocs from search order down to ROOT
: PREVIOUS ( -- ) 
\ Removes the topmost vocabulary from the search order
: SET-CURRENT ( wid -- ) 
: SET-ORDER ( widn .. wid1 n -- ) 
\ set the whole search-order
: SET-ORDER ( widn .. wid1 n -- ) 
\ set the whole search-order
: SWAP-CURRENT ( wid1 - wid2 ) 
\ change current to wid1, return old wid2
: VOC: ( wid 'word' - ) 
\ define 'word' in vocabulary wid
: VOCABULARY ( <name> -- ) 
\ create a new vocabulary
: WORDLIST ( -- wid ) 
: "CHDIR ( a1 n1 -- ) 
{ \ current$ } 
\ Set the current directory.
: "FBASE-PATH+ ( a1 n1 -- ) 
\ w32f path
\ Append a directory to the Forth search base path.
: "FILE-CLIP" { addr len limit | temp$ pre -- addr len2 } 
\ Clip filename to limit. If limit is less than 20 then the filename is clipped to
\ 20. len2=len if len < limit or len < 20. len2 = 20 if limit < 20. len2 = limt
\ otherwise. The string (if clipped) contains ... in the middle to indicate that#
\ it has been clipped.
: "FPATH+ ( a1 n1 -- ) 
\ w32f path
\ Append a directory to the Forth search path.
: "LOADED? ( addr len -- flag ) 
\ True if a file addr len is loaded. The filename must contain a full path.
: "PATH+ ( a1 n1 path -- ) 
\ w32f path
\ Append a directory to a path.
: "PATH-FILE ( a1 n1 -- a2 n2 f1 ) 
\ Find file a1,n1 in the Forth search path and return the full path. 
\ a2,n2 and f1=false, succeeded.
: .DIR ( -- ) 
\ Print the current directory.
: .FORTHDIR ( -- ) 
\ Type the forth directory.
: .FPATH ( -- ) 
\ w32f path system
\ Display the Forth directory search path list.
: .PATH ( path -- ) 
\ w32f path system
\ Display a directory search path list.
\ Note: The path source will be reset for this path.
: .PROGRAM ( -- ) 
\ Type the program path.
CREATE <ABSRELPATH$> 
: CHDIR ( -<optional_new_directory>- -- ) 
\ Set the current directory.
: FBASE-PATH+ ( -<directory>- -- ) 
\ w32f path system
\ Append a directory to the Forth search base path.
: FIND-PATH { a1 n1 basepath path \ filename$ current$ search-current$ -- a2 n2 f1 } 
\ Find the file  a1,n1  in the path  basepath  by scanning the sub folders
\ defined in  path . Returns the full path of the file if possible.
\  a2,n2  .  f1  = false if succeeded.
\ Note: We have to save the file name in a temporay buffer,
\ because a1 n2 can point to the internal buffer new$ and
\ this buffer can be changed during the search (by current-dir$
\ for example).
: FINDRELATIVENAME ( a1 n1 path - a2 n2 f ) 
\ Returns a relative name for file a1 n1 in path ( last-part ). 
\ n2=0 means not in search path.
: FINDRELATIVEPATH ( a1 n1 path - a2 n2 ) 
\ Returns a relative path for file a1 n1 in path ( first part ). 
\ n2=0 means not in search path.
: FIRST-PATH" ( path -- a1 n1  ) 
\ w32f path
\ Get the first forth directory path.
: FPATH+ ( -<directory>- -- ) 
\ w32f path system
\ Append a directory to the Forth search path.
: FULL-PATH { a1 n1 path \ searchpath$ filename$ current$ -- a2 n2 f1 } 
\ Find the file  a1,n1  in the path  path  and return the full path.
\  a2,n2  .  f1  = false if successful.
: GOHOME ( -- ) 
: ISPATHRELATIVETO? { a1 n1 a2 n2 -- f } 
\ Return true if path a1 n1 is relative to path a2 n2
: LOADED? ( -<name>- -- flag ) 
{ \ current$ } 
\ True if the following file is loaded. The filename may be relative.
: MAKEABSOLUTEPATH ( a1 n1 a2 n2 -- a3 ) 
\ Make path a1 n1 absolute to path a2 n2.
: MAKEPATHRELATIVETO ( a1 n1 a2 n2 -- a3 ) 
\ Make path a1 n1 relative to path a2 n2.
: N"OPEN ( a1 n1 -- handle f1 ) 
\ Open file a1,n1 with a Forth path search.
: NEEDS ( -<name>- ) 
\ Conditionally load file "name" if not loaded.
: NEXT-PATH" ( path -- a1 n1  ) 
\ w32f path
\ Get the next path from dir list.
NEWUSER OPEN-PATH$ 
CREATE PATH-FILE$ 
: PATH-SOURCE ( path  -- 2variable_path-source ) 
\ Path-source points to a substring in a path. 
\ Path-source returns this address.
: PATH: ( -- ) 
\ Defines a directory search path. 
\ The first cell holds a pointer to 2 cells in the user area which are used to handle a search path. 
\ The next 260 bytes are reserved for a counted string of a path. 
\ followed by null. 
\ At runtime it returns address of the counted string of a path.
: PREPEND<HOME>\ ( a1 n1 -- a2 n2 ) 
: PROGRAM-PATH-INIT ( -- ) 
\ Initialize the Forth directory search path list. Automatically done at program
\ initialization and when Paths.f is loaded.
: REQUIRE \ synonym of NEEDS
\ Forth 200X name for needs.
: REQUIRED ( addr len -- ) 
\ Non parsing version of Require.
: RESET-PATH-SOURCE ( path --  ) 
\ w32f path
\ Points the path-source to the whole path.
: RESTORE-CURRENT ( current$ -- ) 
\ Restore current dir
: SAVE-CURRENT ( current$ -- ) 
\ save current dir
PATH: SEARCH-BASE-PATH \ w32f path
\ The path buffer for the base search folders for Forth.
\ Applications that let Forth compile should not change it.
PATH: SEARCH-PATH \ w32f path
\ The path buffer for the sub folders to search in.
\ Applications that let Forth compile should not change it.
: VOLUME-INDICATION? ( addr -- flag ) 
\ True when the counted string at addr starts with x: or \\name
: \LOADED ( -<name>- ) 
\  If the following file IS LOADED interpret line.
: \LOADED- ( -<name>- ) 
\ If the following file IS NOT LOADED interpret line.
: %SIZEOF! ( bytes cfa -- ) 
\ set the size of pointer "cfa"
: %SIZEOF@ ( cfa -- bytes ) 
\ get the size of pointer "cfa"
: %UNPOINTER ( cfa -- ) 
\ deallocate pointer given the cfa
: (.POINTER) ( pfa -- ) 
: (ISPOINTER?) ( plink -- plink ) 
\ check for valid pointer structure
: (RESIZEPOINTER) ( size size pointer -- f ) 
: .POINTER ( cfa -- ) 
: .POINTERS ( -- ) 
: >POINTER ( cfa -- ptr ) 
\ move to ptr
CFA-FUNC DOPOINTER ( -- address ) 
\ it's location
VALUE DYN-OFFSET \ top of the dynamic string buffer
POINTER DYN-PTR ( -- addr ) 
\ Gives the address of the dynamic string buffer.
: DYNALLOC ( n -- addr ) 
\ Allocate n bytes from the dynamic string buffer and return the address. If n exceeds 2048 then the size
\ is limited to 2048 bytes.
: INIT-NEW$ ( -- ) 
\ Set new$ to perform _new$. This is performed as part of the initialisation chain, so is not normally
\ needed in an application.
: ISPOINTER? ( cfa -- cfa ) 
\ check for valid pointer structure
CONSTANT MAX-DYN-STRING \ Gives the size of the dynamic string buffer.
\ Increased to 32768 for improved multi-tasking performance.
: NAMED-NEW$ ( -<name>- ) 
\ a semi-static buffer of MAXSTRING length
VARIABLE PHEAD 
: POINTER ( bytes -<name>- ) 
\ make a pointer "name"
: POINTERS-INIT ( -- ) 
\ clear each pointer in turn
: RESIZEPOINTER ( size -<Pointer>- flag ) 
\ return FALSE if all went ok
: SIZEOF!> ( bytes | name -- ) 
\ set size of the following pointer
: SIZEOF@> ( -<name>- bytes ) 
\ get size of the following pointer
: TRIM-POINTERS ( a1 -- a1 ) 
: UNPOINTER> ( name -- ) 
\ deallocate a pointer name following
: _NEW$ ( -- addr ) 
\ Allocate MAXSTRING bytes from the dynamic string buffer and return the address. Used as the normal action
\ of NEW$ except during the early stages of initialisation, when NEW$ is a static buffer.
: INIT-IMAGE-HANDLES ( -- ) 
: INIT-TURNKEY-FIND ( -- ) 
: INIT-TURNKEY-NODEBUG ( -- ) 
: INIT?ENABLECONSOLEMESSAGES ( -- ) 
: PRE-INIT-SYSTEM-LOCKS-OFF ( -- ) 
\ Set all the system deferred words for locking and unlocking to noops in the image.
\ This is done for the system so that at start-up code that uses
\ them will work correctly before the locks are initialised.
\ Also the allocated memory link is zeroed.
: PREINITAPPID ( -- ) 
: TRIM-IMAGE-CHAINS ( -- ) 
\ Trim chains in image.
: TRIM-IMAGE-ERRORS ( -- ) 
: TRIM-IMAGE-LIST ( addr -- ) 
\ Given the head of a list or chain remove all those items not in the image.
\ This is designed to be used as part of the pre-save-image-chain.
: ZERO_CONHNDL ( -- ) 
\ Make sure console handle in image is zero.
CONSTANT #MLISTS \ Number of method lists; must be a non-zero power of 2.
CFA-CODE (&IV) 
CODE ((FINDM)) ( SelID addr -- 0cfa t | f ) 
CODE ((FINDV)) ( SelID addr -- 'ivar t | f ) 
CFA-CODE (IV!) 
CFA-CODE (IV+!) 
CFA-CODE (IV@) 
CFA-CODE (IVC!) 
CFA-CODE (IVC+!) 
CFA-CODE (IVC@) 
CFA-CODE (IVD!) 
CFA-CODE (IVD+!) 
CFA-CODE (IVD@) 
CFA-CODE (IVW!) 
CFA-CODE (IVW+!) 
CFA-CODE (IVW@) 
: (UNHASH) ( hash-val -- addr len flag ) 
: .M0NAME ( a1 -- ) 
: .M1NAME ( a1 a2 -- a3 ) 
: ?UNHASH ( hash-val -- f1 ) 
: ADD-HASH ( addr len hash-val -- ) 
DEFER CLASH ( hash-val -- ) 
#VOCABULARY CLASSES 
CFA-CODE DOOBJ 
SYNONYM EXITM exit 
SYNONYM EXITM exit 
CONSTANT HASH-WID 
#VOCABULARY HASHED 
CFA-CODE M0CFA 
CFA-CODE M1CFA 
CODE METHOD-HASH ( addr len -- hash-val ) 
VALUE OBJ-SAVE 
: OP! 
: OP@ 
: UNHASH ( hash-val -- addr len ) 
NCODE UNNESTM ( -- ) 
CONSTANT VOC-PFA-SIZE 
CODE ^BASE ( -- addr ) 
: ".EXT-ONLY" ( a1 n1 -- a1 n1 ) 
\ returns dotted file extension
: "ARG-NEXT" ( a1 n1 -- a2 n2 ) 
: "HOLD ( adr len -- ) 
: "LCLIP" ( a1 n1 -- a1 n1 ) 
\ clip a string to between 0 and LINE-MAX
DEFER "MESSAGE ( addr len -- ) 
: "MINUS-EXT" ( a1 n1 -- a2 n2 ) 
\ remove the file extension
: "PATH-ONLY" ( a1 n1 -- a2 n2 ) 
\ return path, minus final '\'
DEFER "TOP-MESSAGE 
: #DEFINE ( -<name expression>- ) 
: ("PATH-FUNC") ( a1 n1 xt -- a2 n2 ) 
\ execute path function
: (.) ( n1 -- a1 n1 ) 
\ convert number n1 to an ascii string
: (.CHAINS) ( link -- ) 
\ display the contents of chains
AS (CALL-PRE) 
AS (CALL-PRFS) 
DEFER (CLASSNAMELOCK) 
DEFER (CLASSNAMEUNLOCK) 
DEFER (CONSOLEBOOT) 
DEFER (CONSOLEHIDDENBOOT) 
DEFER (CONTROLLOCK) 
DEFER (CONTROLUNLOCK) 
: (D.#) ( d1 n1 -- a1 n1 ) 
\ display d1 with n1 places behind DP
DEFER (DIALOGLOCK) 
DEFER (DIALOGUNLOCK) 
: (DOSCONSOLEBOOT) ( -- ) 
( DosConsole ) 
DEFER (DYNLOCK) 
DEFER (DYNUNLOCK) 
DEFER (GDILOCK) 
DEFER (GDIUNLOCK) 
: (NOCONSOLEBOOT) ( -- ) 
( NoConsoleIO ) 
DEFER (POINTERLOCK) 
DEFER (POINTERUNLOCK) 
: (TRIM) ( addr1 addr2 -- addr1 addr3 ) 
: (UD,.) ( ud -- a1 n1 ) 
: (UT/) ( utlo utmid uthi n -- d1 n ) 
: (XUD,.) ( ud commas -- a1 n1 ) 
: +LNULL ( a1 -- ) 
\ append a NULL just beyond the counted chars
: +LPLACE ( addr len dest -- ) 
\ append string addr,len to LONG counted
\ string dest
: +Z", ( a1 n1 -- ) 
: +Z," ( -<text">- ) 
: ,"TEXT" ( -<"text">- ) 
\ parse out quote delimited text and compile
\ it at here  NO EXTRA SPACES ARE NEEDED !!!
: -NULL, ( -- ) 
: .. \ synonym of RESET-STACKS
: .CHAIN ( chain -- ) 
: .CHAINS ( -- ) 
: .R.1 ( n1 n2 -- ) 
\ print n1 right justified in field of n2
DEFER .RSTACK 
: .USERSIZE ( - ) 
\ Shows what is left in the user-area
: 2+! ( d1 a1 -- ) 
\ double accumulate
: 2+TO ( d <name> -- ) 
\ add a double to a 2VALUE
: 2TO ( d <name> -- ) 
\ store a double in a 2VALUE
: 2VALUE ( d1 -<name>- ) 
: ?+; ( a1 -- ) 
\ append a ';' if not already present
: ?+\ ( a1 -- ) 
\ append a '\' if not already present
: ?-\ ( a1 -- ) 
\ delete trailing '\' if present
: ?.NAME ( cfa -- ) 
\ try to display the name at CFA
DEFER ?ENABLECONSOLEMESSAGES 
: ?ISCLASS ( cfa -- f ) 
\ check if cfa point's to a class
: ?NAME { ?name-val \ ?name-max -- cfa } 
: ABS>REL ( absaddr -- reladdr ) 
\ v4 and previous versions : convert absolute to relative address
\ post v4 : is a noop (win32forth loads at an absolute address)
: ACTION-OF ( "<spaces>name" -- xt ) 
\ 200X   system      Core ext x:deferred
\ Return xt that deferred word name is set to. When compiling put into current def.
: ALLOT-TO ( n1 -- ) 
\ Extend the dictionary space of most recent word compile to length n1.
: ALT 
: APP-RESERVE ( n1 -- ) 
\ allot some bytes initialized to NULL
2VALUE ARG" 
: ARG-1" ( -- a1 n1 ) 
: ARG-EXT" ( -- a1 n1 ) 
: ARG-NEXT" ( -- a1 n1 ) 
2VALUE ARG-POS" 
: AS ( 'name' -- ) 
\ make name an alias of call last winproc
: ASCII 
: ASCIIZ ( addr len -- buff-z ) 
: B. ( n1 -- ) 
: BREAKER ( -- ) 
\ just a place to put a breakpoint if needed
: BU,.R ( n1 width -- ) 
: BUD,.R ( ud width -- ) 
: BUFFER: ( defining: +n "name" -- child's runtime: -- a-addr ) 
\ Create a buffer +n bytes long. The address of the buffer is aligned.
: C+LPLACE ( c1 a1 -- ) 
\ append char c1 to the LONG counted string at a1
: C+PLACE ( c1 a1 -- ) 
\ append char c1 to the counted string at a1
: CFA-CODE ( -<name>- ) 
: CFA-COMP, ( cfa -- ) 
\ compile or execute a CFA
: CFA-FUNC ( -<name>- ) 
: CHECKSTACK \ synonym of nostack1
: CONVERT ( ud1 c-addr1 -- ud2 c-addr2 ) 
\ ANSI       Core Ext
\ ud2 is the result of converting the characters within the text beginning at the
\ first character after c-addr1 into digits, using the number in BASE, and adding
\ each digit to ud1 after multiplying ud1 by the number in BASE. Conversion continues
\ until a character that is not convertible is encountered. c-addr2 is the location
\ of the first unconverted character. An ambiguous condition exists if ud2 overflows.
\  Note:  This word is obsolescent and is included as a concession to existing
\ implementations. Its function is superseded by >NUMBER.
: CS-PICK ( dest .. u -- dest ) 
\ pick both addr and ?pairs value
: CS-ROLL ( dest -- u .. dest ) 
\ roll both addr and ?pairs value
: CTRL 
: D.R.# ( d1 n1 n2 -- ) 
\ print d1 in a field of n1 characters,
\ display with n2 places behind DP
DEFER DEFAULTWINDOWPROC 
: DEFER! ( xt2 xt1 -- ) 
\ 200X               Core ext x:deferred
\ xt1 is deferred word. xt2 is new setting.
: DEFER@ ( xt1 -- xt2 ) 
\ 200X               Core ext x:deferred
\ xt1 is deferred word. xt2 is current setting.
CFA-FUNC DO2VALUE! 
CFA-FUNC DO2VALUE+! 
VALUE DOCLASS \ cfa for classes, initialized in CLASS.F
CFA-FUNC DOIMPORT ( i*x -- res ) 
: DOSCONSOLE ( -- ) 
\ switch to DOS console functions
VALUE DO|CLASS \ cfa for invisible classes, initialized in CLASS.F
: ENDCHAR? ( a1 char -- flag ) 
\ check the end character in a c-string
DEFER ENTER-ASSEMBLER 
: ERASE$ ( adr - ) 
: EXCEPTION@ 
: EXEC: ( n1 -- ) 
\ execute the n1 item following
DEFER EXIT-ASSEMBLER 
: EXPECT ( a1 n1 -- ) 
\ accept the text
NEW-SYS-CHAIN FORGET-CHAIN \ chain of types of things to forget
NEW-CHAIN FORTH-IO-CHAIN \ chain of things to to to restore forth-io
\ new-chain          ledit-chain  \ line editor function key chain
: GET-COMMANDLINE ( -- ) 
\ initialize TIB from the commandline
: GET-VIEWFILE ( cfa -- line# addr flag ) 
\ find source for word, very inefficent as
\ uses >name, >view@ and >ffa@
: HANDLE ( -<name>- ) 
\ handles are automatically zeroed during
( -- hndl ) 
\ Win32Forths startup initialization
: HANDLEMESSAGES { pMsg -- 0 } 
\ This is the word which handles the messages sent by windows. The chain
\ MSG-CHAIN can be used to prepend other message handlers, eg DoDialogMsg
\ DoAccelMsg DoMDIMsg. It is used by console in ACCEPT KEY etc. It is
\ also used by MessageLoop when a program is TURNKEYed without console.
\ This word is called by WINPAUSE
VARIABLE HANDLES-LIST 
: HIWORD ( n1 -- n2 ) 
: HOLDS ( c-addr u -- ) 
\ 200X core-ext
\ Add string c-addr u to pictured numeric output buffer.
: ID. ( nfa -- ) 
NEWPROC IDK_BASEPROC \ dummy base procedure showing syntax
\ procedure key constants should start with IDK_
\ and should be defined and used in UPPERCASE
: IMPORT: ( c "name" -- ) 
\ Create a word "name" in the current vocabulary that when it executes reverses the top c items on
\ the data stack and then executes the DLL function "name".
\  NOTE  this word also executes PROC, which can be aliased with AS that behaves the same as if
\ c PROC "name" has been executed.
: IN-APP-SPACE? ( addr -- flag ) 
: IN-CODE-SPACE? ( addr -- flag ) 
: IN-SYS-SPACE? ( addr -- flag ) 
NEW-CHAIN INITIALIZATION-CHAIN \ chain of things to initialize
: IS-DEFAULT ( cfa -<name>- ) 
\ Set the default field of a deferred word.
: ISWINCONSTANT ( str -- str FALSE | val TRUE ) 
{ \ WinVal -- } 
CONSTANT LMAXCOUNTED \ lines can be 1k characters long
CONSTANT LMAXSTRING \ room for leading cell count and trailing cell null
: LOWORD ( n1 -- n2 ) 
: LPLACE ( addr len dest -- ) 
: M*/ ( d1 n1 +n2 -- d2 ) 
: M+ ( d1 n -- d2 ) 
: MAKEDEFER ( cfa -<name>- ) 
DEFER MESSAGE-OFF 
: MESSAGELOOP ( -- ) 
\ This word launches a message loop. It will exit only when receiving a
\ WM_QUIT message. Used with programs TURNKEYed without console.
NEWUSER MESSAGESTRUCTURE 
NEW-CHAIN MSG-CHAIN \ chain of forth console Windows' messages
: MT* ( lo hi n -- tlo tmid thi ) 
VALUE MYAPPID 
VALUE MYRUNUNIQUE 
: N>R ( i*x +n -- ) 
( R: -- j*x +n ) 
\ "n-to-r"   200X TOOLS EXT
\ Interpretation: must be paired with NR> on the same line.
\ Execution: Remove n+1 items from the data stack and store them for later retrieval by NR>.
\ The return stack may be used to store the data. Until this data has been retrieved by NR>:
\ this data will not be overwritten by a subsequent invocation of N>R and
\ a program may not access data placed on the return stack before the invocation of
\ N>R.
\ NOTE: +n MUST not exceed 8191 (or 1023 during callbacks) minus the number of values previously
\ placed on the return stack OTHERWISE the user area (or for callbacks the data stack will be
\ corrupted probably causing a CRASH.
VALUE NEWAPPID 
: NEWPROC ( -<proc_name> ) 
\ define a unique procedure key code
( -- n1 ) 
\ return the procedures key code
: NOCONSOLEIO ( -- ) 
\ Reset all defered I/O words to noop's.
: NOSTACK ( -- ) 
: NOSTACK1 ( -- ) 
: NOT 
: NR> ( -- i*x +n ) 
( R: j*x +n -- ) 
\ "n-r-from" 200X TOOLS EXT
\ Interpretation: must be paired with N>R on the same line.
\ Execution: Retrieve the items previously stored by an invocation of N>R. n is the number of items
\ placed on the data stack. It is an ambiguous condition if NR> is used with data not stored by N>R.
VALUE OLDDEPTH 
: PAUSEFORMESSAGES { | pMsg -- } 
\ synonym of Winpause : this word is used to give control to Windows so that
\ any pending message can be handled.
NEW-SYS-CHAIN POST-FORGET-CHAIN \ chain of types of things to forget
NEW-SYS-CHAIN PRE-SAVE-IMAGE-CHAIN \ chain for things to be done to an image prior to saving
DEFER PRESETCONSOLEIO 
VALUE PROC_NEXT \ next procedure value
: REL>ABS ( relAddr -- absAddr ) 
\ v4 and previous versions : convert relative to absolute address
\ post v4 : is a noop (win32forth loads at an absolute address)
DEFER RESERVE 
NEW-CHAIN RESET-STACK-CHAIN \ chain for stack reset
DEFER RESETSRCINFO 
: RESTORE-DEFAULT ( -<name>- ) 
\ Reset name to its default function.
: ROLL ( n1 n2 .. nk k -- n2 n3 .. nk n1 ) 
\ Rotate k values on the stack, bringing the deepest to the top.
VALUE RUNUNIQUE 
DEFER SAVE-SOURCE 
NEW-SYS-CHAIN SEMICOLON-CHAIN \ chain of things to do at end of definition
VARIABLE SPAN ( -- a-addr ) 
\ ANSI        Core Ext
\ a-addr is the address of a cell containing the count of characters stored by the
\ last execution of EXPECT.
\  Note:  This word is obsolescent and is included as a concession to existing
\ implementations.
: STACK-CHECK-OFF ( -- ) 
: STACK-CHECK-ON ( -- ) 
: STACK-EMPTY? ( -- ) 
: STOP/START \ synonym of START/STOP
VALUE STOPLAUNCHING \ true if a new instance of me must be stopped
: STRING: \ Allocates strings
: SUPPRESS-SYSTEM 
: SYS-RESERVE ( n1 -- ) 
\ allot some bytes initialized to NULL
: TNEGATE ( t1lo t1mid t1hi -- t2lo t2mid t2hi ) 
: TRIM ( addr voc -- ) 
: U,.R ( n1 n2 -- ) 
\ display double unsigned, justified in field
: UD,.R ( ud l -- ) 
\ right justified, with ','
: UD. ( ud -- ) 
\ display double unsigned
: UD.R ( ud l -- ) 
\ right justified, WITHOUT ','
NEW-CHAIN UNLOAD-CHAIN \ chain of things to de-initialize
: UNUSED ( -- n1 ) 
\ return unused HERE in BYTES
NEWUSER USEROBJECTLIST \ For disposing of User Objects
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ Locking for Windows
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
: UT* ( ulo uhi u -- utlo utmid uthi ) 
: UT/ ( utlo utmid uthi n -- d1 ) 
: WAITFORMESSAGE { | pMsg -- } 
\ wait to handle next message only
VALUE WITH-SOURCE? 
NEWUSER Z-BUF 
: \+ ( "word" -- ) 
\ Interpret the rest of the line if "word" is defined.
: \- ( "word" -- ) 
\ Interpret the rest of the line if "word" isn't defined.
: \IN-SYSTEM-OK ( -<line_to_interpret>- ) 
\ Suppress in-system warnings for the rest of the current line, restoring the previous
\ state of the sys-warning? flag afterwards, even if an error occurs.
: _DEFAULTWINDOWPROC ( hwnd msg wparam lparam -- res ) 
: _IS-DEFAULT ( cfa -- ) 
: _RESTORE_DEFAULT ( -- ) 
: _\N->CRLF ( a1 n1 -- ) 
\ parse "\n" occurances, change to CRLF's
: AUTO-PRINT-INIT ( -- PrintDC ) 
: DEFAULTPRINTER ( -- ) 
CREATE DI 
CONSTANT DOCNAME 
: END-PAGE ( -- ) 
: GET-COPIES ( -- n ) 
: GET-FROMPAGE ( -- n1 ) 
: GET-TOPAGE ( -- n1 ) 
CONSTANT HDC 
CONSTANT HDEVMODE 
CONSTANT HDEVNAMES 
CONSTANT HOWNER 
CONSTANT HWNDOWNER 
VALUE JOB 
: LOCKDEVMODE ( -- a ) 
CONSTANT NCOPIES 
CONSTANT NFROMPAGE 
CONSTANT NMAXPAGE 
CONSTANT NMINPAGE 
CONSTANT NTOPAGE 
: PAGESETUPDLG ( -- f ) 
\ display the new Page Setup dialog
: PAPER-SIZE ( -- w h ) 
CREATE PD 
CONSTANT PDFLAGS 
: PRINT-CLOSE ( -- ) 
: PRINT-END ( -- ) 
: PRINT-FLAGS ( -- flag ) 
: PRINT-INIT ( -- PrintDC ) 
: PRINT-INIT2 ( Bitmapped Flags Topage -- PrintDC ) 
: PRINT-ORIENTATION ( f -- PrintDC ) 
: PRINT-PAGE ( -- ) 
: PRINT-SETUP ( window_handle -- PrintDC ) 
: PRINT-START ( -- ) 
: PRINTDLG ( -- f ) 
\ display the Print dialog
CREATE PSD 
CONSTANT PSDFLAGS 
CONSTANT PTPAPERSIZE 
: QUALITY-PRINT ( -- n ) 
CONSTANT RTMARGIN 
CONSTANT RTMINMARGIN 
: START-PAGE ( -- ) 
: UNLOCKDEVMODE ( -- ) 
: (REGCLOSEKEY) ( hKey -- f ) 
: (REGCREATEKEY) { hKey lpSubKey samDesired \ Class Disposition hkResult -- hkResult } 
: (REGOPENKEY) { hKey lpSubKey samDesired \ hkResult -- hkResult } 
: (REGQUERYVALUE) { hKey lpValueName rType lpData lpcbData \ -- f } 
: (REGSETVALUE) { hKey lpValueName rType lpData cbData \ -- f } 
CREATE BASEREG 
: BUILDSECTION ( sadr slen adr -- adr1 ) 
: GETSETTING ( a1,n1 -- a2 n2 ) 
\ a1,n1-key string, a2,n2=value string
CREATE PROGREG 
: PROGREG-INIT ( -- ) 
: PROGREG-SET-BASE-PATH ( -- ) 
VALUE REGACCESSMASK 
VALUE REGBASEKEY 
: REGGETKEY { sadr slen \ section$ -- regkey } 
\ read the key of a section
: REGGETKEYREAD { sadr slen \ section$ -- regkey } 
\ read the key of a section
: REGGETSTRING { vadr vlen sadr slen -- dadr dlen } 
VARIABLE REGLEN 
: REGSETSTRING { dadr dlen vadr vlen sadr slen \ val$ khdl -- } 
VARIABLE REGTYPE 
NAMED-NEW$ RETURNEDKEY$ 
: SETSETTING ( a1 n1 a2 n2 -- ) 
\ a1,n1=value string, a2,n2=key string
: 'SEE ( cfa -- ) 
\ see a word given its cfa
: ((SEE)) ( Cfa -- ) 
: (.LOCALS) ( t-1 n -- ) 
: (.WORD) ( IP  cfa -- IP' ) 
DEFER (SEE) ( cfa -- ) 
: .(;CODE) ( ip -- ip' ) 
: .(DOES>) ( ip -- ip' ) 
: .2VALUE ( cfa -- ) 
: .: ( cfa -- ) 
: .;CODE ( cfa -- ) 
: .BRANCH ( IP -- IP' ) 
: .CALL ( ip -- ip' ) 
: .CLASS ( cfa -- ) 
: .CODE ( cfa -- ) 
: .CONSTANT ( cfa -- ) 
: .DEFER ( cfa -- ) 
: .DEFINITION-CLASS ( cfa cfa -- ) 
: .DOES> ( pfa -- ) 
\ nop lea ecx, xxx [edi] ; pick up xxx
: .END ( ip -- ip'|0 ) 
\ advance ip by 1 cell, return false if there are no branches
\ past this address
: .EXECUTION-CLASS ( ip cfa -- ip' ) 
NEW-SYS-CHAIN .EXECUTION-CLASS-CHAIN 
: .FCONSTANT ( cfa -- ) 
: .FVALUE ( cfa -- ) 
: .IMMEDIATE ( cfa -- ) 
: .IMPORT ( cfa -- ) 
: .LOCALS ( IP -- IP' ) 
: .OBJECT ( cfa -- ) 
: .OFFSET ( cfa -- ) 
: .OTHER ( cfa -- ) 
NEW-SYS-CHAIN .OTHER-CLASS-CHAIN 
: .PFA ( cfa -- ) 
: .PROC-NAME ( cfa -- ) 
: .STRING ( IP -- IP' ) 
: .SYNONYM ( cfa -- ) 
: .USER ( cfa -- ) 
: .VALUE ( cfa -- ) 
: .VARIABLE ( cfa -- ) 
: .VOCABULARY ( cfa -- ) 
\ use VOCS to see all the vocabularies and lexicons
\ this word is used internaly by the code for SEE
: .WORD ( ip -- ip' ) 
NEW-SYS-CHAIN .WORD-CHAIN 
VALUE A_VALUE \ Classify a word based on its CFA                    09SEP83HHL
: BRANCH+ ( ip -- ip' ) 
\ advance ip by 1 cell and update hi-branch if necessary
VALUE DEBUGGING? 
DEFER DISCODE 
: D_CR ( -- ) 
VALUE HI-BRANCH 
: SEE ( <name> -- ) 
\ see a word parsed from input stream
: "FILE-LINK ( adr len hWnd -- ) 
\ open a local file in default browser
: "SHELLEXECUTE { addr cnt hWnd -- errorcode } 
\ open file using default application
: "WEB-LINK { adr len hWnd \ web$ -- } 
\ open the Web link supplied, using the web browser
: $EXEC ( a1 -- f1 ) 
\ Invoke a DOS command string with
\ preprocess for file and line parameters
\ f1 = TRUE on error
: $EXEC-WAIT ( a1 -- f1 ) 
\ Invoke a DOS command string with
\ preprocess for file and line parameters
\ and wait for terminating of the process.
\ f1 = TRUE on error
: $EXECBUF-PREPARE ( a1 -- ) 
\ preprocess for file and line parameters
: $SHELL ( a1 -- ) 
NAMED-NEW$ &EXECBUF 
VARIABLE &LINENUM 
: ("SHELLEXECUTE) { operation addr cnt hWnd --  errorcode } 
\ open file using default application
: (EXEC-PROCESS-WAIT) { hProcess -- } 
\ Wait for terminating of a process
: ,$ ( -< #text#>- ) 
: .$ ( -< #text#>- ) 
: .SHELL ( -- ) 
\ display the editor, browser, shell & dos strings
VALUE ?SHELL-PAUSE 
: BROWSE" ( -<string">- ) 
\ set the browser command string
CREATE BROWSE$ 
: DOS ( -<string>- ) 
: DOS" ( -<string">- ) 
\ set the dos command string
CREATE DOS$ 
: EDITOR" ( -<string">- ) 
\ set the editor command string
CREATE EDITOR$ 
: EXEC-CMD ( a1 -- f1 ) 
: EXEC-CMD-WAIT ( a1 -- f1 ) 
: EXEC-PROCESS-WAIT ( -- ) 
\ Wait for terminating the process
: EXECBUF+ ( a1 n1 a2 -- ) 
\ append to the exec buffer
VALUE NEW-PROMPT? 
: S$ ( -< #text#>- ) 
( -- a1 n1 ) 
: SHELL ( -<string>- ) 
: SHELL" ( -<string">- ) 
\ set the shell command string
CREATE SHELL$ 
CREATE SHELL-BUF 
CREATE SHELL-NAME$ 
: WEB ( -<www.???.com>- ) 
\ open the Web link specified, using the Web browser
: ZEXEC-CMD ( a1 -- f1 ) 
\ execute a command line
: ZEXEC-CMD-WAIT ( a1 -- f1 ) 
\ execute a command line, and wait for terminating of the process
: +FIELD ( n1 n2 "name" -- n3 ) 
: BEGIN-STRUCTURE ( -- addr 0 ) 
: BFIELD: ( n1 <"name"> -- n2 ) 
( addr -- 'addr ) 
: CFIELD: ( n1 <"name"> -- n2 ) 
( addr -- 'addr ) 
: END-STRUCTURE ( addr n -- ) 
: FIELD: ( n1 <"name"> -- n2 ) 
( addr -- 'addr ) 
: LFIELD: ( n1 <"name"> -- n2 ) 
( addr -- 'addr ) 
: WFIELD: ( n1 <"name"> -- n2 ) 
( addr -- 'addr ) 
: X:STRUCTURES 
: XFIELD: ( n1 <"name"> -- n2 ) 
( addr -- 'addr ) 
: +NO-WRAP ( a1 n1 -- a2 ) 
\ add n1 to a1, limit to address 0xFFFFFFFF
\ don't allow wrap around to address zero
ANEW -DUMP.F 
: DUMP ( adr len -- ) 
( hex byte format with ascii ) 
DEFER DUMPC@ 
ANEW -TOOLS.F 
DEFER .DFC 
DEFER .FORTHFORM 
DEFER .IDE 
DEFER .LDE 
DEFER .WINDOWS 
DEFER CLASS-BROWSER 
DEFER DEXH 
DEFER HELP-SYSTEM 
DEFER XREF 
: "FTYPE { \ locHdl typ$ -<name>- } 
\ type file "name" to the console
: #FLOAD ( n1 -<name>- ) 
\ load file "name" from line n1, 1 based
: $.VIEWINFO ( cfa -- line filename ) 
: .#" ( n1 n2 -- a1 n3 ) 
: .AM/PM ( -- ) 
\ Print time in 12hr format.
: .BUILTBY ( -- ) 
\ print the name of the person who built this copy of w32f
: .CUR-FILE ( -- ) 
: .CVERSION ( -- ) 
: .DATE ( -- ) 
\ Print date in short format, based on regional setting.
: .DEFERRED ( -- ) 
: .ELAPSED ( -- ) 
: .ERRORBOX ( n - ) 
\ W32F
\ Display the number n in a modal error message box.
: .FILE \ synonym of .CUR-FILE
: .LOADED ( -- ) 
: .MONTH,DAY,YEAR ( -- ) 
\ Print day and date in full.
: .PLATFORM ( -- ) 
\ W32F      Tools extra    in-system
\ Display the Windows platform the system is running on.
: .PLATFORM-NT ( -- ) 
\ W32F      Tools extra    in-system
\ Display the Windows-NT platform the system is running on.
: .REG_WNT\VERSION ( key$ len -- ) 
\ W32F      Tools extra    in-system
\ Display the string of the specified registry key in
\ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
: .TIME ( -- ) 
\ Print time in 24hr format.
: .VIEWINFO ( -<name>- line filename ) 
: 2LITERAL ( x1 x2 -- ) 
\ ANSI             Double
\  Interpretation:  Interpretation semantics for this word are undefined. 
\  Compilation:  ( x1 x2 -- )
\ Append the run-time semantics below to the current definition. 
\  Run-time:  ( -- x1 x2 )
\ Place cell pair x1 x2 on the stack.
: >AM/PM" ( time_structure -- ) 
: >DATE" ( time_structure -- ) 
: >LINE ( n1 -- ) 
\ move to line n1, 1 based
: >MONTH,DAY,YEAR" ( time_structure -- ) 
: >TIME" ( time_structure -- ) 
: ?ERRORBOX ( flag addr len -- ) 
\ W32F
\ If flag is true display the text addr len in a modal warning message box. If OK is
\ pressed then perform an abort, if cancel is pressed terminate the application.
: ?KEYPAUSE \ synonym of START/STOP
: ?MESSAGEBOX ( flag addr len -- ) 
\ W32F
\ If flag is true display the text addr len in a modal information message box.
: ?TERMINATEBOX ( flag addr len -- ) 
\ W32F
\ If flag is true display the text addr len in a modal stop message box. When OK is
\ pressed terminate the application.
: ?WIN-ERROR ( f1 -- ) 
\ f1=0=failed
\ ?win-error can only be used right after a CALL. It looks at the CALL word,
\ finds the PROC and extracts the name of the function. It's a pretty nasty
\ bit of code! The bit that does it is:
\ 
\ r@ 2 cells - @ .proc-name
\ 
\ Fetches the current IP, then goes 2 cells back (the pointer is always a
\ cell ahead at the next word, so 1 cell back is the ?win-error word, 2
\ cells is the CALL). This is the pointer to the CALL CFA in the PROC; then
\ it fetches the PROC address and displays the name. Horrible.
MAKE-CURSOR APPSTARTING-CURSOR 
MAKE-CURSOR ARROW-CURSOR 
CREATE COMPILE-VERSION 
: COPYFILE ( -<from to>- -- ) 
\ W32F
\ Copy a file to a directory. The from string is made up of the path (either absolute
\ or relative) and the file name (with extension). The to string is the path (either
\ absolute or relative) only; the filename is taken from the from string.
{ | from$ to$ } 
MAKE-CURSOR CROSS-CURSOR 
VARIABLE CUR-LINE 
NEWUSER DATE$ 
: DEFAULTOF ( -- ) 
\ define a default condition for CASE structure
\  must be last in the series of OF ***
\ avoids the use of SWAP in default CASE condition
: ELAPSE ( -<commandline>- ) 
: ERRORBOX ( addr len -- ) 
\ W32F
\ Display the text addr len in a modal error message box.
: FLIST \ Synonym of FTYPE
: FTYPE ( -<filename>- ) 
\ W32F System Utils
\ Type the contents of file -<filename>- at the console. If no extension is supplied
\ then the default extension (.f) is applied. Relative paths are relative to the Forth
\ search path.
: GET-LOCAL-TIME ( -- ) 
\ get the local computer date and time
MAKE-CURSOR HAND-CURSOR 
MAKE-CURSOR HARROW-CURSOR \ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
MAKE-CURSOR HELP-CURSOR 
MAKE-CURSOR IBEAM-CURSOR 
: IDIR ( -<optional_new_directory>- -- ) 
: LINELOAD ( n1 -- ) 
\ load the current file from line n1
: MACRO ( "name <char> ccc<char>" -- ) 
\ W32F (Wil Baden)
\ Create a definiton, "name and store the text cccc delimited by <char> so that when
\ "name is used the code is compiled or executed according to state. 
\  Note:  Because "name uses evaluate then the actual interpretation is sensitive to the
\ search order when "name is compiled or interpreted,  not  when defined. 
\ Also "name should not be postponed into a word or stored into a deferred word,
\ which is called in a turnkeyed application (it causes the application to crash).
MAKE-CURSOR MAGNIFY-CURSOR 
: MAKE-CURSOR ( cursor_constant|z.cur-adr  usingCURfile -- ) 
\ Enables various shapes of the mouse.
\ When a *.cur file is used the file must be in the search path
\ of the application.
\ When you have NT or better you could use resources.f
: MESSAGEBOX ( szText szTitle style hOwnerWindow -- result ) 
\ W32F
\ Display a standard windows message box, with the title sztitle and message sztext,
\ where both strings are null terminated. Style is one of the standard window message
\ box styles. If hOwnerWindow is null then the active window is used as the owner.
: MS@ ( -- ms ) 
MAKE-CURSOR NOWAY-CURSOR 
VALUE ORIG-LOC 
: PAUSE-SECONDS ( n1 -- ) 
: RANDOM ( n1 -- n2 ) 
\ W32F  Utils
\ Get a pseudo random number between 0 and n1 as n2. n2 has the same sign as n1.
: RANDOM-INIT ( -- ) 
\ W32F  Utils
\ Initialize the random number generator from the system clock. This is performed at
\ program initialisation.
: SCREEN-SIZE ( -- width height ) 
\ get windows screen size
: SECONDS ( n1 -- ) 
VALUE SEED1 
VALUE SEED2 
VALUE SEED3 
MAKE-CURSOR SIZEALL-CURSOR 
MAKE-CURSOR SIZENESW-CURSOR 
MAKE-CURSOR SIZENS-CURSOR 
MAKE-CURSOR SIZENWSE-CURSOR 
MAKE-CURSOR SIZEWE-CURSOR 
MAKE-CURSOR SPLITH-CURSOR 
MAKE-CURSOR SPLITV-CURSOR 
VARIABLE START-LINE \ Allows you to start including a file at a line number
\ other than 1.  Can't think of a serious use for it.
\ Not ANS. Dangerious, We are advised - don't use it.
VALUE START-TIME 
NEWUSER TIME$ 
: TIME&DATE ( -- sec min hour day month year ) 
NEWUSER TIME-BUF \ +0  year
\ +2  month
\ +4  day of week
\ +6  day of month
\ +8  hour
\ +10 minute
\ +12 second
\ +14 milliseconds
CONSTANT TIME-LEN 
: TIME-RESET ( -- ) 
: TIMER-RESET \ synonym of time-reset
MAKE-CURSOR UPARROW-CURSOR 
MAKE-CURSOR WAIT-CURSOR \ Cursors added from MFC
DEFER WIN-ABORT 
: _MS ( u -- ) 
\ delay u milli-seconds or forever if u=-1.
: _STACK-CHECK ( -- ) 
: (?ENABLECONSOLEMESSAGES) ( -- ) 
: (W32FAPPCMDLINE) ( addr len w32fappID -- addr len ) 
{ \ <CmdLine> -- } 
: .SHARED ( -- ) 
\ Show current contents of win32forth applications shared memory
: ?REMOVEGHOST { aAppId -- } 
\ remove any "ghost" instance
: BROADCASTW32FMSG { addr siz w32fmsg \ -- } 
\ Send an inter-process win32forth-specific message to all running processes
\ in a pool of win32forth applications, including myself. See Sendw32fMsg
: CLOSESHAREDMEMORY ( -- ) 
\ close win32forth application shared memory
CREATE COPYDATASTRUCT 
: DECODEW32FMSG ( hwnd msg wparam lparam -- addr siz w32fmsg w32fAppIDsender ) 
\ decode a WM_COPYDATA message received from a win32forth application
\ in a form ready for a CASE statement in a window message handler. 
\ w32fAppIDSender will be 0 if any problem with shared memory
: ENABLEW32FMSG ( hwnd -- ) 
\ Set the window handle of your application for inter-process communication 
\ Used to configurate your application
: EXECEDITOR ( addr len -- flag ) 
\ Launch or put in front if already present, the current editor,
\ either IDE or WinEd
: EXECFORTH ( addr len -- flag ) 
\ Launch win32Forth or use an existing instance who shares memory 
\ Automatically builds filename and prepends home 
\ addr len (len may be 0) is a commandline that will be appended
\ to the filename if the application is actually launched
\ Return -1 if failed, 0 if success
: EXECHELP ( addr len -- flag ) 
\ Launch Help if not already running 
\ Automatically builds filename and prepends home 
\ addr len (len may be 0) is a commandline that will be appended
\ to the filename if the application is actually launched
\ Return -1 if failed, 0 if success
: EXECIDE ( addr len -- flag ) 
\ Launch IDE if not already running 
\ Automatically builds filename and prepends home 
\ addr len (len may be 0) is a commandline that will be appended
\ to the filename if the application is actually launched
\ Return -1 if failed, 0 if success
: EXECW32FAPP ( addr len w32fappID -- flag ) 
\ Execute a win32forth application, whose communication features are enabled,
\ with a command line whose first token is the filename. If no path is given the
\ file will be searched in the current directory. You may specify a path. 
\ Example: (cf setup.f) 
\ s" WIN32FOR.EXE CHDIR HELP FLOAD HELPMAIN.F BYE" w32fHelp ExecW32FApp
\ Return -1 if failed, 0 if success
: EXECWINED ( addr len -- flag ) 
\ Launch IDE if not already running 
\ Automatically builds filename and prepends home 
\ addr len (len may be 0) is a commandline that will be appended
\ to the filename if the application is actually launched
\ Return -1 if failed, 0 if success
: INITSHAREDMEMORY ( -- ) 
\ Init win32forth application shared memory
: ISRUNNING? ( AppID -- flag ) 
\ true if an instance of AppID is already running
: RESETSHARED { AppID \ addrme addrend -- } 
\ remove AppId from shared memory
: RUNASNEWAPPID ( -- ) 
\ Set the application's inter-process communication
\ capabilities using current NewAppID and RunUnique flags
\ Remember: hwnd must be set again after use of this word
: SENDW32FMSG ( addr siz w32fmsg w32fappIDto -- result ) 
\ Send an inter-process win32forth-specific message 
\ w32fAppIDTo is the destination application ID 
\ w32fmsg is the win32forth-specific message number 
\ addr siz is the data area passed with the message 
\ result: <>0 (the message has been processed) or false
\ Note: it is supposed to be harmless to use this word
\ without the shared memory nor hwnd set.
: SET-TIME-TAKEN 
: SET?ENABLECONSOLEMESSAGES ( -- ) 
: SETSHARED ( AppID -- ) 
\ append AppID record in shared memory
: SHAREDAPPID ( hwnd -- w32fappID ) 
\ Get application ID in shared memory,
\ given its window handle, 0 = not found
: SHAREDHWND ( w32fAppID -- hwnd ) 
\ Get window handle in shared memory,
\ given an application ID, 0 = not found \n
\ (if multiple instance, the first one will be found)
VALUE TIME-TAKEN 
: UNINITSHAREDMEMORY ( -- ) 
\ Uninit win32forth application shared memory
VALUE W32FSHAREH \ win32forth application shared-memory handle
CREATE W32FSHARENAME \ a complex enough win32forth application shared-memory name
VALUE W32FSHAREP \ win32forth application shared-memory pointer
\ Shared memory data structure
\ ----------------------------
\ The shared memory contains one record for each currently running process.
\ Each record contains :
\ - the win32forth application unique ID
\ - the hwnd of the window that must handle messages
\ IMPORTANT NOTE :
\ *************
\ HWnd is a unique identifier across all w32fapps but w32fappID is not (if
\ multiple instances of the same process are running). This package uses only
\ the w32fappID parameter to communicate, so, in case of multiple instances,
\ you wouldn't know which one would receive any message sent.
\ No attempt was made to uniquely identify an instance by the couple appID/hwnd,
\ mainly because handling multiple instances would remain very complex from the
\ developper point of view.
\ Instead we ASSUME THAT ONLY ONE INSTANCE of each communicating process is present.
\ To "guarantee" that only one instance can communicate, the following features
\ are provided :
\ - you can force an application to run as a unique instance
\ - in case of multiple instances allowed, only one shares memory, the rules are :
\ - the first instance shares memory
\ - next ones won't share memory
\ - if the first instance is closed, the NEXT launched one will share memory.
CONSTANT ED_DEBUG \ receive debug (addr siz = ed-dbgline)
CONSTANT ED_NAME \ send currently debugged name
\ addr siz = string = word name
CONSTANT ED_OPEN_BROWSE \ "           file for browse only
CONSTANT ED_OPEN_EDIT \ remote open file for edit
CONSTANT ED_RESPONSE \ answer a WM_INQUIRE msg with result of evaluate
\ addr siz = string
CONSTANT ED_STACK \ send  stacks (addr siz contains:
\ 64 cells  = data stack
\ maxstring = return stack
CONSTANT ED_WATCH \ "           file for display source for debugger
\ in these 3 msgs, addr siz contains:
\ cell1 = line number ; maxpath+1 = filename
CONSTANT ED_WORD \ Forth tells the IDE to highlight the word (token)
\ currently pointed to by the debugger. Addr siz
\ contains: cell1 = line ; cell2 = column
: W32FAPPID>FILENAME ( w32fappID -- addr len ) 
\ Give the filename associated to an app ID
VALUE W32FEDITOR \ current editor, defaults to IDE, can be WINED
VALUE W32FFORTH 
VALUE W32FHELP 
VALUE W32FIDE 
VALUE W32FWINED 
CONSTANT WM_BEEPME \ ask the receiving app to beep (addr=len=0)
\ Sender : all     Receiver : Help
\ --------------------------------
CONSTANT WM_BEGNBP \ proceed to def again (addr=len=0)
CONSTANT WM_CONTBP \ continuous step till key (addr=len=0)
CONSTANT WM_DONEBP \ done, run the program (addr=len=0)
CONSTANT WM_HEREBP \ proceed to this point again (addr=len=0)
CONSTANT WM_HTML \ ask help to display an html sheet
\ addr size : string = url
\ Sender : Help     Receiver : Forth
\ ----------------------------------
CONSTANT WM_INQUIRE \ send a string to forth so that forth evaluate it
\ addr siz = string (result via WM_RESPONSE)
\ Sender : Forth   Receiver : IDE
\ -------------------------------
CONSTANT WM_JUMPBP \ Jump over next Word (addr=len=0)
CONSTANT WM_KEY \ give Forth a key (addr size contains: byte = key)
CONSTANT WM_LINEFILE \ ask Help to display file for a word
\ addr size : cell = line ; string = filename
CONSTANT WM_NESTBP \ nest into this definition (addr=len=0)
CONSTANT WM_PASTELOAD \ tell Forth to get text from the clipboard and
\ compile it - the sender is supposed to have
\ filled the clipboard with code (addr=len=0)
\ Sender : IDE (debugger)    Receiver : Forth
\ -------------------------------------------
CONSTANT WM_RSTKBP \ show Return stack (addr=len=0)
CONSTANT WM_SETBP \ tell the forth console to set a breakpoint on a word
\ ie: tell it to start debugging the word
\ addr size : word name   result =0 failed -1 success
CONSTANT WM_SHOWDEFER \ send DEFER name and expect that receiver will
\ display its current contents
\ addr size = word
\ Sender : all    Receiver : Forth
\ --------------------------------
CONSTANT WM_STEPBP \ single step (addr=len=0)
CONSTANT WM_UNESTBP \ unnest to definition above (addr=len=0)
CONSTANT WM_WORDHELP \ ask help to display quickinfo for a word
\ addr size = word (return 0 if not in database)
RECORD: &PS \ The PAINTSTRUCT for Begin- and EndPaint 
\ It will be valid only when handling the WM_PAINT message
\ (see On_Paint: method)
: (WNDPROC) ( hwnd msg wparam lparam -- res ) 
INT C-HEIGHT 
INT C-WIDTH 
INT C-X 
INT C-Y 
: CENTERAROUNDMIDPOINT { mx my w h -- xl yl } 
\ w32f
:M CENTERWINDOW: ( -- x y ) 
\ Calculate the position of the window to center it in the middle of it's parent window.
\ When the windows has no parent it will be placed in the middle of the primary display
\ monitor.
:M CLASSINIT: ( -- ) 
\ Initialise the class.
INT CLASSNAME 
VALUE CLASSNAMEID \ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\ Global windows procedure error, used here and in CONTROL.F
\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
INT CLICK-FUNC 
INT CLICKING? 
INT CLSEXTRA 
: CREATE-FRAME-WINDOW ( -- hwnd ) 
\ calc window rect
INT CURRENTMENU \ current menubar
INT CURRENTPOPUP \ current right mouse popup menu
INT CURSOR-ON? 
INT DBL-CLICK-FUNC 
WINDC DC \ The window's device context. 
\ It will be valid only when handling the WM_PAINT message
\ (see On_Paint: method)
: DEFAULT-CLASS-NAME ( -- ) 
\ The a default window class name for this window. Every window
\ will become it's own class name and it's own window class.
\ Note: If the window class name is set with SetClassName: before
\ the Start: method is called no default class name will be set.
: DEFAULT-WINDOW-CLASS ( -- ) 
\ Fill in the defaults for the window class.
:M DEFAULTCURSOR: ( -- cursor-id ) 
\ User windows should override the DefaultCursor: method to
\ set the default cursor for window. Default is IDC_ARROW.
:M DEFAULTICON: ( -- hIcon ) 
\ User windows should override the WindowStyle: method to
\ set the default icon handle for window. Default is the W32F icon.
VALUE DEFAULTMENUBAR \ Global default menubar
:M DEFWINDOWPROC: ( h m w l -- res ) 
\ Call the DefaultWindowProc for the window.
:M DESTROYCURSOR: ( -- ) 
\ Destroy the caret.
:M ENABLE: ( f1 -- ) 
\ Enable or disable the window.
VALUE ERRCFA 
CREATE ERRSTRING 
:M EXWINDOWSTYLE: ( -- extended_style ) 
\ User windows should override the ExWindowStyle: method to
\ set the extended window style. Default is NULL.
: FIND-WINDOW ( z"a1 -- hWnd ) 
\ w32f
\ Find a window.
: GET-DC ( -- ) 
:M GETCLASSLONG: ( offset -- long ) 
\ The GetClassLong function retrieves the specified 32-bit (long) value from
\ the WNDCLASS structure associated with the window.
:M GETCLASSNAME: ( -- addr len ) 
\ Get the window class name.
: GETDESKTOPSIZE ( -- w h ) 
\ Retrieves the size (width and height) of the work area on the primary
\ display monitor. The work area is the portion of the screen not obscured
\ by the system taskbar or by application desktop toolbars. \n
\ Width and height are expressed in virtual screen coordinates.
: GETINFO ( SelId -- height width ) 
:M GETPARENTWINDOW: ( -- hWndParent ) 
\ Get the handle of the owner window (0 if no parent).
: GETPOSITIONPARENT ( -- x y wb hb ) 
:M GETSIZE: ( --width height ) 
\ Get the size (width and height) of the window.
INT HAVE-FOCUS? 
INT HBRBACKGROUND 
INT HCURSOR 
INT HEIGHT \ current height of client area
:M HEIGHT: ( -- height ) 
\ Get the height of the window.
INT HICON 
:M HIDECURSOR: ( -- ) 
\ Hide the caret.
INT HINSTANCE 
INT HWNDPARENT \ handle of the parent window (added Sonntag, Juni 04 2006 dbu)
: LOADICONFILE ( adr len -- hIcon ) 
\ w32f
\ Load an icon from an icon file.
:M LOADMENU: ( parent -- menuhandle ) 
:M MAKECURSOR: ( gx gy width height -- ) 
\ Create the caret.
:M MAXSIZE: ( -- width height ) 
\ To change the maximum window size, override the MaxSize: method. Default is 8192 by 8192.
INT MENUNAME 
: MIDPOINT ( x y w h - mx my ) 
\ Calculate the middle point of the given rectangle
:M MINSIZE: ( -- width height ) 
\ To change the minimum window size, override the MinSize: method. Default is 10 by 10.
:M MOVECURSOR: ( gx gy -- ) 
\ Move the caret.
: NULL-CHECK ( a1 -- a1 ) 
:M ONWMCOMMAND: ( hwnd msg wparam lparam -- hwnd msg wparam lparam ) 
:M ON_ERASEBACKGROUND: ( hwnd msg wparam lparam -- res ) 
\ User windows should override the On_EraseBackground: method to handle
\ WM_ERASEBKGND messages. 
\ Default does nothing.
:M ON_KILLFOCUS: ( h m w l -- ) 
\ Override the method to handle the WM_KILLFOCUS message. 
\ Example: Use only when you are displaying a cursor in the window:
\            DestroyCursor: self
:M ON_PAINT: ( -- ) 
\ User windows should override the On_Paint: method to handle WM_PAINT messages. 
\ Before this method is called BeginPaint will be called so that the PAINTSTRUCT
\ (&PS ivar) and the window device context (DC ivar) are initialized. 
\ Check ps_fErase in your method to see if the background of the window should
\ be drawn and use ps_left, ps_top, ps_right and ps_bottom to see which part of
\ the window should be painted. 
\ Default does nothing.
:M ON_SETFOCUS: ( h m w l -- ) 
\ Override the method to handle the WM_SETFOCUS message. 
\ Example: When cursor is used, you will need something like the following
\ to control the position of the cursor in the window:
\            cursor-col char-width  *
\            cursor-row char-height *
\            char-width char-height MakeCursor: self
:M ON_SIZE: ( hndl msg wParam -- ) 
\ User windows should override the On_Size: method. When this method is
\ called, the variables Width and Height will have already been set. 
\ Default does nothing
INT ORIGINX 
INT ORIGINY 
INT PARENT \ object address of the parent window
\ Note: this ivar was moved here form the child-window class some
\ time ago. Altough it's not realy needed in the window class I
\ left it here in order not to break too much code (Sonntag, Juni 04 2006 dbu).
:M PARENTWINDOW: ( -- hWndParent ) 
\ Get the handle of the owner window (0 if no parent).
\ NOTE: This method is deprecated. Use GetParentWindow: instead.
INT PS_BOTTOM 
INT PS_FERASE 
INT PS_FINCUPDATE 
INT PS_FRESTORE 
INT PS_HDC 
INT PS_LEFT 
INT PS_RIGHT 
INT PS_TOP 
:M PUSHKEY: ( c1 -- ) 
\ override to process keys yourself.
: REGISTER-FRAME-WINDOW ( -- f ) 
\ Init the window class and register it.
: REGISTER-THE-CLASS ( -- f ) 
\ Register the window class.
: RELEASE-DC ( -- ) 
BYTES RGBRESERVED 
: SEND-WINDOW ( lParam wParam Message_ID hWnd -- ) 
\ w32f
\ Send a message to a window.
: SET-MOUSEXY ( l -- ) 
: SET-SIZE ( lParam -- ) 
:M SETCLASSLONG: ( long offset -- ) 
\ The SetClassLong method replaces the specified 32-bit (long) value at the
\ specified offset into the extra class memory or the WNDCLASS structure for
\ the class to which the window belongs.
:M SETCLASSNAME: ( addr len -- ) 
\ Set the window class name.
:M SETCLICKFUNC: ( cfa -- ) 
:M SETDBLCLICKFUNC: ( cfa -- ) 
:M SETMENUBAR: ( menubar -- ) 
:M SETORIGIN: ( x y -- ) 
\ To set the upper left corner of the window when it's created
\ call the SetOrigin: method before you create the window.
:M SETPARENT: ( hWndParent -- ) 
\ Set handle of the owner window (0 if no parent).
\ NOTE: This method is deprecated. Use SetParentWindow: instead.
:M SETPARENTWINDOW: ( hWndParent -- ) 
\ Set handle of the owner window (0 if no parent).
:M SETPOPUPBAR: ( menubar -- ) 
:M SETSIZE: ( width height -- ) 
\ Set the size of the window. 
\ Note: The window itself will not be resized.
:M SETTITLE: { adr len \ temp$ -- } 
\ Set the window title.
:M SETTRACKFUNC: ( cfa -- ) 
:M SETUNCLICKFUNC: ( cfa -- ) 
: SHIFT-PUSHKEY ( c1 -- ) 
\ push a special key with shift bits
:M SHOWCURSOR: ( -- ) 
\ Show the caret.
;RECORDSIZE: SIZEOF(PAINTSTRUCT) 
: SMALL-FONT ( -- ) 
:M START: ( -- ) 
\ Create the window.
\ Before the window is created a default window class name for this window will
\ be set. Every window will become it's own class name and it's own window class.
\ Note: If the window class name is set with SetClassName: before the Start: method
\ is called no default class name will be set.
\ The default window class is appropriate for frame windows. Child
\ windows will define their own window class. \n
\ The default window class has the following properties: \n
\ Style: CS_DBLCLKS, CS_HREDRAW and CS_VREDRAW \n
\ White background \n
\ Application icon
:M STARTPOS: ( -- left top ) 
\ User windows should override the StartPos: method to set
\ the upper left corner of the window when it's created.
:M STARTSIZE: ( -- width height ) 
\ To change the size of the window when it's created, override the StartSize: method
\ or call the SetSize: method before you create the window.
INT STYLE 
: SYSTEM-FIXED-FONT ( -- ) 
CALLBACK THEWNDPROC 
INT TRACK-FUNC 
INT TRACKING? 
INT UNCLICK-FUNC 
: VGA-SKEY ( c1 -- ) 
\ push a special key with control or shift bits
INT WIDTH \ current width of client area
:M WIDTH: ( -- width ) 
\ Get the width of the window.
:CLASS WINDOW 
:CLASS WINDOW 
BYTES WINDOWCLASSNAME 
:M WINDOWHASMENU: ( -- flag ) 
\ Flag is true if the window has a menu. Override this method if your window has a
\ menu. Default is false.
:M WINDOWSTYLE: ( -- style ) 
\ User windows should override the WindowStyle: method to
\ set the window style. Default is WS_OVERLAPPEDWINDOW.
:M WINDOWTITLE: ( -- Zstring ) 
\ User windows should override the WindowTitle: method to
\ set the window caption. Default is "Window".
:M WM_CHAR ( h m w l -- res ) 
\ normal & control chars
:M WM_CLOSE ( hwnd msg wparam lparam -- res ) 
:M WM_COMMAND ( hwnd msg wparam lparam -- res ) 
:M WM_DESTROY ( hwnd msg wparam lparam -- res ) 
:M WM_ERASEBKGND ( hwnd msg wparam lparam -- res ) 
:M WM_GETMINMAXINFO ( hwnd msg wparam lparam -- res ) 
:M WM_KEYDOWN ( h m w l -- res ) 
:M WM_KILLFOCUS ( h m w l -- res ) 
:M WM_LBUTTONDBLCLK ( h m w l -- res ) 
:M WM_LBUTTONDOWN ( h m w l -- res ) 
:M WM_LBUTTONUP ( h m w l -- res ) 
:M WM_MOUSEMOVE ( h m w l -- res ) 
:M WM_MOVE ( hwnd msg wParam lParam -- res ) 
:M WM_PAINT ( hwnd msg wparam lparam -- res ) 
\ Check if the window has an update region.
\ If not don't call On_Paint:
:M WM_RBUTTONDOWN ( h m w l -- res ) 
:M WM_SETFOCUS ( h m w l -- ) 
:M WM_SIZE ( hndl msg wParam lParam -- res ) 
:M WM_SYSKEYDOWN ( h m w l -- res ) 
RECORD: WNDCLASS 
:M WNDCLASSSTYLE: ( -- style ) 
\ User windows should override the WndClassStyle: method to
\ set the style member of the the WNDCLASS structure associated with the window.
\ Default style is CS_DBLCLKS, CS_HREDRAW and CS_VREDRAW.
\ To prevent flicker on sizing of the window your method should return CS_DBLCLKS
\ only.
INT WNDEXTRA 
INT WNDPROC 
: WNDPROCERROR ( error_value cfa -- 0 ) 
: (.FREE) ( link -- ) 
{ link \ addr tot used -- } 
: (.LIBS) ( lib-addr -- ) 
: (.MALLOCS) ( link-addr -- ) 
\ display one line
: (.PROCS) ( addr len proc-addr --  addr len ) 
: (TOT-MALLOC) ( n link-addr -- n' ) 
\ add in a single entry's byte count
: .FREE ( -- ) 
\ Display the amount of used and available program memory
: .LIBS ( -- ) 
: .MALLOCS ( -- ) 
\ display all dynamically allocated buffers
: .MEM \ synonym of .free
: .PROCS ( <optional name> -- ) 
{ \ str$ } 
: TOT-MALLOC ( -- n ) 
\ count allocated bytes
: USED ( -- ) 
\ Display the mount of memory used by the following command line
VALUE WINPROC-COUNT \ number of procs
VALUE WINPROC-FOUND \ that we found
BYTES &INFORECT 
: ("MESSAGE) ( addr len f -- ) 
\ display message window
:M CLASSINIT: ( -- ) 
:M CLOSE: ( -- ) 
\ close if its open
INT COLS 
INT EXTENTX 
INT EXTENTY 
:M EXWINDOWSTYLE: ( -- extended_style ) 
CONSTANT FHEIGHT 
CONSTANT FWIDTH 
:M GETACTIVE: ( -- f1 ) 
\ is the message window active
:OBJECT INFOWINDOW 
:M MAXSIZE: ( -- width height ) 
: MESSAGE-ON ( -- ) 
: MESSAGE-ORIGIN ( x y -- ) 
:M MESSAGETEXT: ( a1 n1 -- ) 
:M MINSIZE: ( -- width height ) 
INT MSG-LENGTH 
INT MSG-STRING 
MSGWINDOW MSG-WINDOW 
GDIFONT MSGFONT 
:CLASS MSGWINDOW 
:CLASS MSGWINDOW 
:M ONTOP: ( f1 -- ) 
\ should window float on top?
:M ON_PAINT: { \ vpos -- } 
:M REFRESH: ( -- ) 
INT ROWS 
:M START: ( -- ) 
\ create a new window object
:M STARTSIZE: ( -- width height ) 
\ starting window size
COLOROBJECT TIPCOLOR 
:M WINDOWSTYLE: ( -- style ) 
\ return the window style
:M WINDOWTITLE: ( -- Zstring ) 
: ZMESSAGE ( z& -- ) 
: _"MESSAGE ( a1 n1 -- ) 
\ a floating non-modal message box
: _"TOP-MESSAGE ( a1 n1 -- ) 
\ a floating ON-TOP message box
: _MESSAGE-OFF ( -- ) 
: (WORDS) { voc \ words-pad$ w#threads -- } 
: .VOC-ONCE ( -- ) 
CALLBACK: .WINCONSTANT ( abs_adr len value -- f ) 
CALLBACK: .WINCONSTANTCOUNT ( abs_adr len value -- f ) 
: .WORDS ( -- ) 
VALUE CONSTANT-CNT 
VALUE CONSTANT-TOT 
: CONSTANTS ( -<optional_name>- ) 
: COUNT-CONSTANTS ( -- n1 ) 
\ count the constants available to system
: HORIZONTAL-LINE ( -- ) 
: MATCH? ( addr len -- f ) 
: ON-ALLWORDS { theCFA \ vocBuf -- } 
: ORDER ( -- ) 
\ display current vocabulary search order
: VOCS ( -- ) 
\ display vocabularies
VARIABLE VOCSAVE 
: WITH-ADDRESS ( -- ) 
VALUE WITH-ADDRESS? 
VALUE WITH-TABS? 
: WORDS ( -<optional_name>- ) 
\ WORDS partial-string will focus the list
CREATE WORDS-POCKET 
: _WORDS ( -<optional_name>- ) 
\ WORDS partial-string will focus the list
ANEW -XFILEDLG.F \ ------------------- Common Open/Save/New Dialog funcs ----------------------
:M CLASSINIT: ( -- ) 
: FDLG-ADJFILE ( -- filename ) 
\ adjust filename returned
: FDLG-BUILD ( filename diraddr titleaddr specaddr owner -- ) 
: FDLG-CALL ( xt -- filename ) 
\ call GetxxxxFileName
: FDLG-FILTER ( abs-addr -- abs-addr ) 
\ change all | to \0 in filter
: FDLG-GETFILE ( -- filename ) 
\ fetch filename
: FDLG-NEWF ( -- ) 
\ set open flags in struct
: FDLG-NOFILE ( -- filename ) 
\ return null filename
AS FDLG-OPEN ( addr -- rc ) 
: FDLG-OPENF ( -- ) 
\ set open flags in struct
AS FDLG-SAVE ( addr -- rc ) 
: FDLG-SAVEF ( -- ) 
\ set save flags in struct
:CLASS FILEDIALOGS 
:CLASS FILEDIALOGS 
:CLASS FILENEWDIALOG 
:CLASS FILENEWDIALOG 
:CLASS FILEOPENDIALOG 
:CLASS FILEOPENDIALOG 
:CLASS FILESAVEDIALOG 
:CLASS FILESAVEDIALOG 
: GET-FILTER-INDEX ( -- n ) 
:M GETDIR: ( -- a1 n1 ) 
\ get the current dialog directory string
:M GETFILTER: ( -- a1 n1 ) 
\ return current file filter string
: NEW-DIALOG ( filename diraddr titleaddr specaddr owner -- filename ) 
: NEW-DIALOG2 ( filterindex filename diraddr titleaddr specaddr owner -- filename ) 
CREATE OFN-STRUCT 
: OPEN-DIALOG ( filename diraddr titleaddr specaddr owner -- filename ) 
: OPEN-DIALOG2 ( filterindx filenam diradr titleadr specadr owner -- filename ) 
: RUN-DIALOG ( owner_handle dialog-func-cfa -- a1 ) 
: SAVE-DIALOG ( filename diraddr titleaddr specaddr owner -- filename ) 
: SAVE-DIALOG2 ( filterindx filename diraddr titleaddr specaddr owner -- filename ) 
:M SETDIR: ( a1 n1 -- ) 
\ set the dialog directory string
:M SETFILTER: ( a1 n1 -- ) 
\ set new file filter spec
:M SETTITLE: ( a1 n1 -- ) 
:M START2: ( filterindex owner_handle -- a1 ) 
:M START2: ( filterindex owner_handle -- a1 ) 
:M START2: ( filterindex owner_handle -- a1 ) 
:M START: ( owner_handle -- a1 ) 
:M START: ( owner_handle -- a1 ) 
:M START: ( owner_handle -- a1 ) 
BYTES SZDIR 
BYTES SZFILE 
INT SZFILTER 
INT SZTITLE 
